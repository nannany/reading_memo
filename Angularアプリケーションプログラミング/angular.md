## 3.4
属性とプロパティは別物。属性は要素の初期値、プロパティは現在の値

### プロパティバインディング
プロパティバインディングでクラスを上書きすると、html側で指定していたものは消える。

### スタイルバインディング
あまり使うもんじゃない。クラスバインディングで制御すべき。

### イベントバインディング
ビュー側はシンプルにとどめるべき。

stopPropagation()でeventの伝播を止められる。

要素オブジェクトの受け渡しでは、$eventより、まずはテンプレート参照変数の利用を考える。

Enterキー用の専用イベントが用意されている。それがkeyup.enter

## 3.6 双方向バインディング
コンポーネントが変更されたらビューも変化する。また、ビューが変化すれば、コンポーネントも更新する。

ngModelディレクティブでフォーム要素をコンポーネントに紐づける。この際に要素を識別するためにname属性が必須となる。


# 4.標準パイプ/ディレクティブ

### 4.1.3 オブジェクトをJSONに変換-json
デバッグ用途でつかう

### 4.1.10 数値によって表示文字列を変化させる-i18nPlural
与えられた数値に応じてメッセージを切り替える。

### 4.1.11 文字列に応じて出力を切り替える-i18nSelect

## 4.2 ディレクティブ
ngForなど、標準的なHTML以外のカスタム要素/属性のことをディレクティブというらしい。

### 4.2.1 式の真偽によって表示/非表示を切り替える-ngIf
falseにした場合には要素そのものが破棄される。そのため、表示/非表示を頻繁に切り替える要素ではこれを使わず、スタイルバインディングでdisplayスタイルプロパティを設定する。

### 4.2.3 式の値によって表示を切り替える-ngSwitch
式の値に基づいて多岐分岐するのであれば、ngIfよりngSwitch使う。

### 4.2.4 配列をループ処理する-ngFor
trackBy関数で、要素が同一であるかどうかを何で判断するか定めることができる。これを使うことによって、ページ更新時に追加分の要素だけを作成する、といったことができるようになる。
sliceパイプとの組み合わせで、ページング機能を作成することができる。

### 4.2.5 要素にスタイルプロパティを付与する-ngStyle

### 4.2.6 スタイルクラスを着脱する-ngClass
ngStyleよりngClassを使用するのが基本方針。

### 4.2.7 数値に応じて出力を切り替える-ngPlural

### 4.2.8 用意されたテンプレートの内容をインポートする-ngTemplateOutlet


# 5章 フォーム開発
angularでは値検証機能を備えたリッチな入力フォームをシンプルに実装できる。

### 5.1.1 基本的なフォーム
HTML5の検証機能とバッティングすると不具合の原因となるので、novalidate属性を付与しておく。（angular4以降は自動で付与される）

## 5.4 モデル駆動型のフォーム
検証ルールをテンプレート側に記述するのではなく、コンポーネント側に記述する。

### 5.4.1 ReactiveFormsModuleモジュールの有効化
モデル駆動開発を利用するには、ReactiveFormsModuleを有効にする。


# 6章 コンポーネント開発

## 6.1 複数コンポーネントの連携
アプリに複数のコンポーネントを配置する方法、コンポーネント間で情報をやり取りする方法を記述。


### 6.1.1 コンポーネントを入れ子に配置する-@Inputデコレータ
@Component中のselectorで、タグ要素とコンポーネントを紐づける。
親コンポーネントから子コンポーネントに値を引き渡すのが@Inputでこれーた（子側に書く）

### 6.1.2 子コンポーネントからイベントを受け取る-@Outputデコレータ
EventEmitterで外に伝播させるイベントの宣言を行う。
emitメソッドで実際にイベントを発生させる。

### 6.1.4 モジュールの分離
モジュールを分離することで、各要素の役割を明確にする。
ルートモジュール以外では、CommonModuleをインポートする。

## 6.2 コンポーネントのライフサイクル
コンポーネントのライフサイクルは、
コンストラクター
↓
ngOnChanges
↓
ngOnInit
↓
ngDoCheck
↓
ngAfterContentInit
↓
ngAfterContentChecked
↓
ngAfterViewInit
↓
ngAfterViewChecked
↓
ngOnDestroyed
↓
コンポーネントの破棄

外部コンテンツとは、コンポーネント要素の配下で指定されたコンテンツのこと。
ビューは、コンポーネントで定義されたテンプレートそのもの。

### 6.2.1 ライフサイクルメソッドの確認

### 6.2.2 ページの初期化/終了処理を実施する-ngOnInit/ngOnDestroy
一般的に、コンポーネントの初期化処理はngOnInitに集約する。

### 6.2.3 入力プロパティの変更を検知する-ngOnChanges
SimpleChangesオブジェクトの中に変更前、変更後の値が詰められている。

### 6.2.4 ビューの初期化/変更時の処理を実装する-ngAfterViewInit/ngAfterViewChecked
@ViewChildrenデコレータで、現在のビューに配置された子コンポーネントを取得することができる。
setTimeoutメソッドを使って処理を非同期化？？

### 6.2.5 コンポーネント配下のコンテンツをテンプレートに反映させる-<ng-content>
<ng-content>は子要素側で使用する。
親のクラス、要素を子に反映させることができる。

### 6.2.6 外部コンテンツの初期化/変更時の処理を実装する-ngAfterContentInit/ngAfterContentChecked
外部コンテンツで定義された子コンポーネントを参照するには、@ContentChildデコレータを用いる。

## 6.3 コンポーネントのスタイル定義

### 6.3.1 コンポーネントのスタイル定義
コンポーネント内で定義したスタイルは外部に影響しない。

### 6.3.2 捕捉：スタイルカプセル化の仕組み

### 6.3.3 コンポーネントスタイルを定義する方法
いろいろあるけど基本はcss作ってスタイル分離すべき。

### 6.3.4 コンポーネントスタイルで利用できる特殊セレクター
:hostを使うと、自コンポーネントに対してのみスタイルを適用する。
:host-contextを使うと、コンポーネントの外部の状況に応じて、自コンポーネントのスタイルを変更できる。
/deep/セレクタを使うと（もしくは>>>）、子コンポーネントのスタイルに影響を与えることもできる。

### 6.3.5 

