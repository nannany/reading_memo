## 3.4
属性とプロパティは別物。属性は要素の初期値、プロパティは現在の値

### プロパティバインディング
プロパティバインディングでクラスを上書きすると、html側で指定していたものは消える。

### スタイルバインディング
あまり使うもんじゃない。クラスバインディングで制御すべき。

### イベントバインディング
ビュー側はシンプルにとどめるべき。

stopPropagation()でeventの伝播を止められる。

要素オブジェクトの受け渡しでは、$eventより、まずはテンプレート参照変数の利用を考える。

Enterキー用の専用イベントが用意されている。それがkeyup.enter

## 3.6 双方向バインディング
コンポーネントが変更されたらビューも変化する。また、ビューが変化すれば、コンポーネントも更新する。

ngModelディレクティブでフォーム要素をコンポーネントに紐づける。この際に要素を識別するためにname属性が必須となる。


# 4.標準パイプ/ディレクティブ

### 4.1.3 オブジェクトをJSONに変換-json
デバッグ用途でつかう

### 4.1.10 数値によって表示文字列を変化させる-i18nPlural
与えられた数値に応じてメッセージを切り替える。

### 4.1.11 文字列に応じて出力を切り替える-i18nSelect

## 4.2 ディレクティブ
ngForなど、標準的なHTML以外のカスタム要素/属性のことをディレクティブというらしい。

### 4.2.1 式の真偽によって表示/非表示を切り替える-ngIf
falseにした場合には要素そのものが破棄される。そのため、表示/非表示を頻繁に切り替える要素ではこれを使わず、スタイルバインディングでdisplayスタイルプロパティを設定する。

### 4.2.3 式の値によって表示を切り替える-ngSwitch
式の値に基づいて多岐分岐するのであれば、ngIfよりngSwitch使う。

### 4.2.4 配列をループ処理する-ngFor
trackBy関数で、要素が同一であるかどうかを何で判断するか定めることができる。これを使うことによって、ページ更新時に追加分の要素だけを作成する、といったことができるようになる。
sliceパイプとの組み合わせで、ページング機能を作成することができる。

### 4.2.5 要素にスタイルプロパティを付与する-ngStyle

### 4.2.6 スタイルクラスを着脱する-ngClass
ngStyleよりngClassを使用するのが基本方針。

### 4.2.7 数値に応じて出力を切り替える-ngPlural

### 4.2.8 用意されたテンプレートの内容をインポートする-ngTemplateOutlet


# 5章 フォーム開発
angularでは値検証機能を備えたリッチな入力フォームをシンプルに実装できる。

### 5.1.1 基本的なフォーム
HTML5の検証機能とバッティングすると不具合の原因となるので、novalidate属性を付与しておく。（angular4以降は自動で付与される）

## 5.4 モデル駆動型のフォーム
検証ルールをテンプレート側に記述するのではなく、コンポーネント側に記述する。

### 5.4.1 ReactiveFormsModuleモジュールの有効化
モデル駆動開発を利用するには、ReactiveFormsModuleを有効にする。


# 6章 コンポーネント開発

## 6.1 複数コンポーネントの連携
アプリに複数のコンポーネントを配置する方法、コンポーネント間で情報をやり取りする方法を記述。


### 6.1.1 コンポーネントを入れ子に配置する-@Inputデコレータ
@Component中のselectorで、タグ要素とコンポーネントを紐づける。
親コンポーネントから子コンポーネントに値を引き渡すのが@Inputでこれーた（子側に書く）

### 6.1.2 子コンポーネントからイベントを受け取る-@Outputデコレータ
EventEmitterで外に伝播させるイベントの宣言を行う。
emitメソッドで実際にイベントを発生させる。

### 6.1.4 モジュールの分離
モジュールを分離することで、各要素の役割を明確にする。
ルートモジュール以外では、CommonModuleをインポートする。

## 6.2 コンポーネントのライフサイクル
コンポーネントのライフサイクルは、
コンストラクター
↓
ngOnChanges
↓
ngOnInit
↓
ngDoCheck
↓
ngAfterContentInit
↓
ngAfterContentChecked
↓
ngAfterViewInit
↓
ngAfterViewChecked
↓
ngOnDestroyed
↓
コンポーネントの破棄

外部コンテンツとは、コンポーネント要素の配下で指定されたコンテンツのこと。
ビューは、コンポーネントで定義されたテンプレートそのもの。

### 6.2.1 ライフサイクルメソッドの確認

### 6.2.2 ページの初期化/終了処理を実施する-ngOnInit/ngOnDestroy
一般的に、コンポーネントの初期化処理はngOnInitに集約する。

### 6.2.3 入力プロパティの変更を検知する-ngOnChanges
SimpleChangesオブジェクトの中に変更前、変更後の値が詰められている。

### 6.2.4 ビューの初期化/変更時の処理を実装する-ngAfterViewInit/ngAfterViewChecked
@ViewChildrenデコレータで、現在のビューに配置された子コンポーネントを取得することができる。
setTimeoutメソッドを使って処理を非同期化？？

### 6.2.5 コンポーネント配下のコンテンツをテンプレートに反映させる-<ng-content>
<ng-content>は子要素側で使用する。
親のクラス、要素を子に反映させることができる。

### 6.2.6 外部コンテンツの初期化/変更時の処理を実装する-ngAfterContentInit/ngAfterContentChecked
外部コンテンツで定義された子コンポーネントを参照するには、@ContentChildデコレータを用いる。

## 6.3 コンポーネントのスタイル定義

### 6.3.1 コンポーネントのスタイル定義
コンポーネント内で定義したスタイルは外部に影響しない。

### 6.3.2 捕捉：スタイルカプセル化の仕組み

### 6.3.3 コンポーネントスタイルを定義する方法
いろいろあるけど基本はcss作ってスタイル分離すべき。

### 6.3.4 コンポーネントスタイルで利用できる特殊セレクター
:hostを使うと、自コンポーネントに対してのみスタイルを適用する。
:host-contextを使うと、コンポーネントの外部の状況に応じて、自コンポーネントのスタイルを変更できる。
/deep/セレクタを使うと（もしくは>>>）、子コンポーネントのスタイルに影響を与えることもできる。

### 6.3.5 カプセル化の挙動を変更する-encapsulationパラメーター
とりあえずEmuated（デフォルト）

## 6.4 アニメーション機能


### 6.4.1 アニメーション機能を利用するための準備
* @angular/animationsパッケージをインストールするために、package.jsonに追記（ここでnpmがJavaでいうmavenみたいなものと気づく）
* systemjs.config.jsに追記。
* ルートモジュールにアニメーションモジュールを追加。
* メインページにポリフィルを追加。

### 6.4.2 アニメーションの基本
アニメーション定義は大きく2つ、状態と遷移に分類される。
state関数で状態を定義する。
transition関数で遷移を定義する。
transition関数内でアニメーション（遷移の方法）を取るが、それはanimate関数で表現される。

状態、遷移の情報をまとめるのがtrigger関数。

### 6.4.3 状態/遷移のさまざまな設定方法
transition関数の中でアニメーション前後のスタイルを定義できるが、アニメーション実行後にはそのスタイルは残らない。
viewにアタッチされていない状態はvoidで表現する。
キーフレームを用いて、アニメーションの途中経過を表現することができる
group関数を使えば複数のアニメーションを並列実行できる。

### 6.4.4 アニメーションの前後で任意の処理を実行する-アニメーションコールバック
start/doneイベント構文を使用することで、アニメーションの前後で処理を行うことができる。


## 6.5 コンポーネントのその他の話題

### 6.5.1 テンプレートの外部ファイル化-templateUrlパラメータ
一定規模以上の開発であれば、デザイナーとプログラマーの作業分担のために、templateUrlパラメータを利用して、htmlをコンポーネントの外に出すべき。

### 6.5.2 テンプレート構文の制約
Angularのテンプレートにはいくつか制限がある。

* script要素は削除される。
* 一部の要素（html、head、title、body等）の要素は意味をなさない。
* 「{」は利用できない。文字列として使いたい場合は{{''}}とする。（}については普通に出せる）

### 6.5.3 コンポーネント要素の操作-hostパラメーター


# 7章 サービス開発

## 7.1 サービスの基本
コンポーネントはビューとのやり取りに徹して、アプリ固有のビジネスロジックはサービスにゆだねる。

### 7.1.1 コンポーネント/サービスの連携
サービスクラスには@Injectableを付与する
@NgModule内のprovidersに対象クラスを登録する

### 7.1.2 依存性注入

### 7.1.3 依存性注入の基本
コンストラクターの引数型と登録済みのサービスを照合して、注入すべきサービスを決定する。

## 7.2 依存性注入の仕組み

### 7.2.1 providersパラメーターの記法

### 7.2.2 サービス生成のアプローチ-useXxxxxプロパティ
useClassプロパティ：注入のたびに常に新しいインスタンスを生成する。
useValueプロパティ：常に同じオブジェクトを注入する。
useExistingプロパティ：トークンのエイリアスを生成する。
useFactoryプロパティ：ファクトリー関数を使ってサービスを生成する。

### 7.2.3 依存性注入のためのトークンを宣言する-provideプロパティ
トークンを活用する必要が生じるのは、注入したい値がクラスでない場合


### 7.2.4 単一のトークンに複数のサービスを紐づける-multiプロパティ

## 7.3 依存性注入の高度な話題

### 7.3.1 インジェクターの階層構造
一般に、アプリ全体で利用するサービスはルートモジュールでグローバルに登録し、特定のコンポーネントのみで利用するサービスはコンポーネント側でローカルに登録する。
トークンの定義を上書きすることができる。が、コンポーネントツリーをまたいだ再登録は可読性を損なうので減速すべきでない。

### 7.3.2 任意のサービスを宣言する-@Optionalデコレータ
@Optionalをつけることによって、サービスが任意であることを宣言できる。（存在チェックと共に使用する）

### 7.3.3 外部コンテンツからアクセスできないサービスを登録する-viewProvidersパラメーター
viewProvidersパラメータを用いると、現在のコンポーネントとその子のみ有効なProviderを宣言する。

### 7.3.4 インジェクターを手動で呼び出す-injectメソッド
Injectorを利用すれば、任意のタイミングでサービスをインスタンス化できる。

## 7.4 非同期通信の実行-Http/Jsonpサービス

### 7.4.1 SPAとXMLHttpResponseオブジェクト

### 7.4.2 Httpサービスの基本
Httpサービスを利用するには、
* HttpModuleをルートモジュールでインポートする
* Httpサービスを自作サービスから呼び出す
* 非同期通信を処理するサーバ側のコードを用意する
* Webサーバ等で上記のサーバ側のコードを動かす

Reactive Extensions:非同期処理を実装する際に役立つライブラリ

### 7.4.3 HTTP POSTによる非同期通信
application/x-www-form-urlencodedだと、キー名=値&の形式でデータ送信される。
application/json形式だとデータをjson形式で送ることになる。

### 7.4.4 JSON形式のWeb APIにアクセスする
Httpサービスにはクロスドメイン制約なるものが存在する。
クロスドメイン制約とは、JavaScriptからは原則異なるドメインに対する通信ができない、というもの。
この制約を超える手段として、JSONPがある。
Jsonpを使用するには、
* JsonpModuleモジュールをインポートする
* 自作サービスからJsonpサービスを呼び出す
* callbackキーとして、固定でJSONP_CALLBACKを指定する

### 7.4.5 例：非同期通信処理をサービスに分離する

### 7.4.6 ローカル環境でWebAPIをエミュレートする-angular-in-memory-web-api
ローカル環境での開発を支えるための仕組み。
InMemoryDbServiceを実装することで疑似DBを用意できる。

### 7.4.7 Observable/Promise経由で渡された値を取得する-asyncパイプ
非同期処理が値を返したタイミングで、その値を取得することができる。

### 7.4.8 標準のリクエストオプションを上書きする
BaseRequestOptionsクラスを継承して、目的のオプションを追加することができる

### 7.4.9 Httpサービスのセキュリティ対策
CookieXSRFStragegyを使用することで、CSRFの対策をうてる
クロスサイトスクリプトインクルージョン対策は、Httpサービス側でよしなにやってくれるのでアプリ実装者はあまり意識しないでいい。具体的には、サーバーサイドからレスポンスを返す際に、ダミー文字列を先頭に付与したりしている。

# 8章 ルーティング

## 8.1 ルーティングとは
ルーティング：リクエストに基づいて処理を振り分けること
ルーター：ルーティング機能を提供するモジュール。AngularではRouterModuleでルーター機能を実現。

## 8.2 ルーティングの基本

### 8.2.1 基底パスの設定-メインページ
ルータの基点となるパスをbase要素で宣言。

### 8.2.2 ルートの定義
ルートは、基本的にはパスと対応するコンポーネントの組み合わせ。
RouterModule.forRootメソッドでRouterModuleを生成する。

### 8.2.3 ルート対応のリンク/表示領域の準備-ルートコンポーネント
ルーター経由でページ遷移を行うときは、hrefの代わりに、routerLinkディレクティブを利用する。
routerLinkActiveディレクティブでは、リンク先が現在と同じ場合に適用されるスタイルを指定。

ルーター経由で呼び出されたコンポーネントは<router-outlet>要素で確保された領域に反映される

### 8.2.4 ルート対応コンポーネントの作成

### 8.2.5 別のルートにリダイレクトする
redirectToパラメータを使ってリダイレクト先を指定できる

## 8.3 ルーター経由で情報を渡す手段

### 8.3.1 パスの一部としてパラメータを引き渡す-ルートパラメータ
パラメータを受け取る側は、params[パラメータ名]の形式で受け取れる

### 8.3.2 ハイパーリンクにクエリ情報/フラグメントを引き渡す-queryParams/fragment属性
queryParams属性で値を渡すこともできる
値はsubscribeメソッド経由で取得
queryParamsHandling="preserve" preserveFragment とすると、クエリ情報を引き継ぐことができる


### 8.3.3 ルーティング情報に任意のデータを指定する-dataプロパティ
ルート定義の際にdataパラメータを指定して値を渡し、受け取り側は、ActivatedRouteオブジェクトで取得する

### 8.3.4 可変長のパラメータを引き渡す
可変長のルートパラメータを取得するには、ActivatedRouteのurlプロパティを利用する。

### 8.3.5 ルーティング情報に任意のデータを指定する（非同期データ）
リゾルバーを利用することによって任意のデータを指定することができる。

## 8.4 マルチビュー/入れ子のビュー/ガード

### 8.4.1 テンプレートに複数のビュー領域を設置する
<router-outlet>要素に任意のnameを付与すれば、複数のビューのテンプレートとコンポーネントを紐づけることができる

### 8.4.2 入れ子のビューを設置する
ルーティング情報として、childrenパラメータを使用する
ルートコンポーネントにリンクを追加する。この時、子の呼び出しが必要ないときは、親ルートだけ呼び出すことが可能
1段目のコンポーネントに子コンポーネントを埋め込む領域を準備する必要がある

### 8.4.3 捕捉：ルーターのマッチング戦略（prefixとfull）
デフォルトはprefixでマッチングに行く。

### 8.4.4 ルート遷移の可否を判定する-ガード
遷移の可否を判定する仕組みとして、ガードというものがある
CanActivate、CanLoad等のインターフェースを実装することでガードを定義できる

# 9章 パイプ/ディレクティブの自作

## 9.1 パイプの自作

### 9.1.1 パイプの基本
パイプクラスを定義するには、PipeTransformインターフェースを実装する。
パイプの実態を実装するのはtransformメソッド。
パイプクラスは@Pipeデコレータで定義する

### 9.1.2 例：改行文字を<br>要素に変換するnl2brパイプ


### 9.1.3 パラメータ付きのパイプを定義する
パイプにパラメータを追加するにはtransformメソッドの第2引数を利用する

### 9.1.4 例：配列の内容を任意の条件でフィルターする
callback型を使用してフィルターしている

### 9.1.5 pureなパイプとimpureなパイプ
pureなパイプの評価は、プリミティブ型の値が変更されたとき、オブジェクト型の参照が変更されたときだけ。
impureなパイプでは、すべての変更で再評価される。

impureなパイプを乱用するとパフォーマンスの低下につながるので、乱用してはならない
そもそもパイプは、ビューを更新する際に頻繁に呼び出されるので、シンプルにとどめておくべき。

##　9.2 属性ディレクティブの自作
標準のディレクティブでは要件を満たせなくなった場合でも、コンポーネント/サービスから文書ツリーを操作するのは避けるべき。
そのような場合のビューの操作/生成部分は自作ディレクティブとして切り出す。

### 9.2.1 属性ディレクティブの基本
ディレクティブを定義するにおいては、
* ElementRefクラスを有効にする
* ネイティブの要素オブジェクトを取得する
* @Directiveデコレータでディレクティブであることを宣言する

### 9.2.2 パラメータ付きのディレクティブを定義する
対象となるプロパティを@Inputデコレータで修飾し、ngOnInitメソッドで処理を記述する
通常は、ディレクティブ名と同名の属性を宣言し、属性の指定をコンパクトにできるようにする。（myColored="#f0f"）

### 9.2.3 イベント処理を伴うディレクティブ
@HostListenerデコレータでディレクティブに対してイベントハンドラーを紐づけることができる
イベントハンドラーに値を引き渡すことも可能

### 9.2.4 例：検証ディレクティブを準備する
検証ルールはvalidateメソッドで定義する。
検証機能を動作させるには、ngModelをselectorパラメータに含める必要がある。
また、providersパラメータでNG_VALICATORSトークンを指定して、multi:trueにしてやることで、Angular標準の検証ルールに加えることができる

## 9.3 構造ディレクティブの自作
angular標準の構造ディレクティブは、ngIf、ngSwitch、ngForなど。

### 9.3.1 構造ディレクティブとは？
Angularの「 * 」要素は、ターゲット要素を<ng-template>要素に展開するためのシンタックスシュガー。
構造ディレクティブとは、テンプレート化された要素をもとにコンテンツを生成＆ページに反映させる機能を持ったディレクティブ

### 9.3.2 構造ディレクティブの実装
ディレクティブ本体について、

* TemplateRef、ViewContainerRefを使用してテンプレート化された要素を挿入する。 
* コンストラクタで上記2つを注入。 
* createEmbeddedViewメソッドで、指定されたテンプレートをもとに要素を作成し、現在の領域に埋め込む。 



