# Part 1 Understanding the Domain

## Chapter 1 Introducing Domain-Driven Design

### The Importance of a Shared Model

ドメインエキスパート、開発チーム、その他のステークホルダーが共有できるメンタルモデルを作ることがDDDの目的。

ソフトウェアをビジネスドメインにそって作ることで得るうまみとは？

```
市場投入までの時間を短縮。開発者とコードベースが、問題を抱えている人と同じモデルを共有することで、チームは適切なソリューションを迅速に開発できる可能性が高くなります。

ビジネスの価値を高める。問題を正確に把握しているソリューションは、お客様を幸せにし、道を踏み外す可能性を減らします。

無駄の削減。要件が明確であれば、誤解や手戻りによる時間の無駄が減ります。さらに、要件が明確になることで、価値の高いコンポーネントが明らかになり、価値の低いコンポーネントを減らして、そのコンポーネントにより多くの開発労力を割くことができます。

メンテナンスと進化が容易になる。コードで表現されたモデルがドメインエキスパート自身のモデルと密接に一致している場合、コードへの変更が容易になり、エラーの発生も少なくなります。さらに、新しいチームメンバーは、より早くスピードアップすることができます。
```

ここから先で、どのようにして共有のメンタルモデルを作成するのかをみていく。

### Understanding the Domain Through Business Events

- まずはビジネスイベントに着目する
    - ビジネスとは、データを何かに変換することである
    - その変換を理解することが大事
    - *これは始めよう要件定義でもいってた気がする*
- ドメインイベント
    - 物事が変換されるトリガーのことを指している？
    - ドメインイベントは常に過去形。過去に起こった過去形の事象をさす

イベント、コマンド、ビジネスワークフローを正確に定義するとどうなる？

#### Using Event Storming to Discover the Domain

- イベントを見つけるなら、イベントストーミング
    - 開発者やドメインエキスパートとその他のステークホルダーを巻き込んだワークショップ
    - イベントストーミング
        - https://www.eventstorming.com/

#### Discovering the Domain: An Order-Taking System

- イベントストーミングの利点
    - ビジネスの理解を共有できる
    - 知らない部分をしれたり、洞察を深められたりする

#### コラム

```
シナリオは、お客様（または他のユーザー）が達成したいゴール（例えば、注文など）を記述したものです。これは、アジャイル開発における「ストーリー」に似ています。ユースケースは、シナリオをより詳細にしたもので、ゴールを達成するために必要なユーザーとのやり取りやその他のステップを一般的な言葉で表現したものです。シナリオもユースケースもユーザー中心の概念であり、ユーザーの視点から見たインタラクションに焦点を当てています。
ビジネス・プロセスは、（個々のユーザーではなく）ビジネスが達成したいと思う目標を記述したものです。シナリオと似ていますが、ユーザー中心ではなく、ビジネス中心に考えられています。
ワークフローは、ビジネスプロセスの一部を詳細に記述したものです。つまり、ビジネスゴールやサブゴールを達成するために、従業員（またはソフトウェアコンポーネント）が行う必要のある正確なステップを記載したものです。ここでは、ワークフローを一人の人間やチームができることに限定することで、ビジネスプロセスが複数のチームにまたがっている場合（注文プロセスのように）、全体のビジネスプロセスを一連の小さなワークフローに分割し、それらを何らかの方法で調整することができます。
```

#### Expanding the Events to the Edges

#### Documenting Commands

コマンドがトリガーとなって、ドメインイベントが発生する。

```
これらのイベントをいくつか壁に貼ったら、"何がこれらのドメインイベントを起こしたのか？"と尋ねてみるかもしれません。誰かが、あるいは何かが、ある活動を起こそうとしたのです。例えば、お客様が注文書を受け取ってほしいと思っていたり、上司があなたに何かをしてほしいと頼んでいたりします。
これらの要求をDDDの用語ではコマンドと呼びます（OOプログラミングで使われるコマンドパターンと混同しないでください）。コマンドは常に命令形で書かれます："Do this for me."
```

### Partishoning the Doamin into SubDomain

ドメインをサブドメインに区切っていく。

### Creating s Solution Using Bounded Context

- 問題空間と解決空間
- 境界づけられたコンテキスト

#### Getting the Contexts Right

どうやったら境界をうまくひけるのか？

- ドメインエキスパートに耳を傾ける
- 現在の部署構造に着目する
- 境界を引くことを忘れない
- 疎結合な設計
- ビジネスワークフローを優先して考える

#### Creating Context Maps

- コンテクストマップ
    - 境界づけられたコンテクスト間でのやりとりを表現するためのマップ

#### Focusing on the Most Important Bounded Contexts

- ドメインの中でも特に重要な役割を果たすものがコアドメイン
- そのほかにsupportive domain, generic domainという区分けをしている

何がコアドメインになるかは、その事業の内容による。 コアドメインに注力して取り組むべし。

### Creating a Ubiquitous Language

- Ubiquitous Language
    - プロジェクトの設計、ソースコードで共通して利用する言葉
    - どの境界づけられたコンテキストで使われるかによって意味合いが変わってくるはず

### Summarizing the Concepts of Domain-Driven Design

```
ドメインとは、私たちが解決しようとしている問題に関連する知識の領域であり、簡単に言えば、「ドメイン・エキスパート」が精通している領域のことです。
ドメイン・モデルは、特定の問題に関連するドメインの側面を表現する単純化のセットです。ドメインモデルは解決空間の一部であり、ドメインモデルが表現するドメインは問題空間の一部です。ユビキタス言語 
ユビキタス言語とは，ドメインに関連する概念や語彙の集合であり，チームメンバーとソースコードの両方で共有される．
境界のあるコンテキストとは，他のサブシステムと区別できる明確な境界を持った解決空間内のサブシステムである．境界のあるコンテキストは，しばしば問題空間のサブドメインに対応します．また、境界のあるコンテキストは、独自の概念と語彙を持ち、ユビキタス言語の独自の方言を持っています。
コンテキスト・マップとは、バウンデッド・コンテキストの集合体とそれらの間の関係を示す高レベルの図である。
ドメインイベントとは、システム内で起こったことを記録したものです。イベントは常に過去形で記述される。イベントは多くの場合、追加のアクティビティを引き起こします。
コマンドとは、あるプロセスの実行を要求するもので、人や他のイベントによって起動されます。プロセスが成功すると、システムの状態が変化し、1つまたは複数のドメインイベントが記録されます。
```

### Wrapping Up

`Focus on events and processes rather than data.`
これよく分からない。データの中身はとりあえずまだいいよ、後で詳細詰めるからって話なのか？

#### Events and Processes

この本で出す具体例の話。

#### Subdomains and Bounded Contexts

この本で出す具体例の話。

#### The Ubiquitous Language

この本で出す具体例の話。

#### What's Next

## Chapter 2 Understanding the Domain

### Interview with a Domain Expert

ドメインエキスパートとの会話の中で気づきをえる。 会話の中で、自分の勘違いに気づけることがある。

#### Understanding the Non-functional Requirements

システムの可用性、デザインに関わる情報をえる。

#### Understanding the Rest of the Workflow

#### Thinking About Inputs and Outputs

インプットは注文フォーム、アウトプットは？

確認書送付は副作用。

OrderPlaced event をBillingコンテキストにnotifiy

### Fighting the Impulse to Do Database-Driven Design

バイアスを入れない

### Fighting the Impulse to Do Class-Driven Design

バイアスを入れない。  
技術的詳細はまだ入れない。ここではドメインエキスパートが理解できるようにする。

### Documenting the Domain

Workflow の書き方とか。

### Driven Deeper into the Order Taking Workflow

会話。ドメイン知識を貯める。

### Representing Complexity in Our Domain Model

#### Representing Constraints

#### Representing the Life Cycle of an Order

### Wrapping Up

```
後半のモデリングの段階に移るときに、必要なものがたくさんあるので、要求の収集は今はやめておきましょう。
その前に、この章で学んだことを振り返ってみましょう。

設計中に実装の詳細に入り込まないことが重要であることを学びました。
DDDはデータベースドリブンでもクラスドリブンでもありません。
DDDはデータベース駆動でもクラス駆動でもありません。

そして、ドメインエキスパートの話をよく聞くと、今回のような比較的シンプルなシステムであっても、多くの複雑さが見えてきました。
例えば、当初は単一の「オーダー」が存在すると考えていましたが、調査を進めていくうちに、オーダーのライフサイクルを通じて、それぞれがわずかに異なるデータや動作を持つ、多くのバリエーションがあることがわかりました。
```

#### What's Next

```
この注文受付のワークフローをF#の型システムを使ってどのようにモデル化するかをまもなく見ていきます。
しかし、その前に、一歩下がって全体像を見つめ直し、完全なシステムをソフトウェア・アーキテクチャに変換する方法について議論しましょう。
これが次の章のテーマになります。
```

## Chapter 3 A Functional Architecture

C4アプローチの用語を使う。

### Bounded Contexts as Autonomous Software Components

最初からマイクロサービス目指さなくても良い。

### Communicating Between Bounded Contexts

#### Transferring Data Between Bounded Context

- Domain ObjectとDTOについて

#### Trust Boundaries and Validation

- workflowの最初と最後にゲートを用意
    - 入力ゲートでやることはいわゆるバリデーション
        - not nullとか何文字以下だとか
    - 出力ゲートでやることは他のコンテキストに出していいか否かのチェック
        - PANを削除するとか

### Contracts Between Bounded Contexts

```
Shared Kernel関係とは、2つのコンテキストが何らかの共通のドメインデザインを共有しており、関係するチームが協力する必要がある場合です。
たとえば、私たちのドメインでは、受注コンテキストと出荷コンテキストは、配送先住所について同じ設計を使用しなければならないと言うかもしれません。
受注コンテキストは住所を受け入れ、それを検証し、出荷コンテキストは同じ住所を使用してパッケージを出荷します。
この関係では、イベントまたはDTOの定義の変更は、影響を受ける他のコンテキストの所有者との協議によってのみ行われる必要があります。

顧客/サプライヤーまたは消費者主導型契約[17]の関係は、下流のコンテキストが、上流のコンテキストに提供させたい契約を定義するものである。
2つのドメインは、上流のコンテキストが契約の義務を果たす限り、独立して進化することができます。
このドメインでは、課金コンテキストが契約を定義し（「これは顧客に請求するために必要なものです」）、次に受注コンテキストがその情報のみを提供し、それ以上は提供しないかもしれません。

適合的な関係は、消費者主導型とは正反対である。
下流のコンテキストは、上流のコンテキストから提供された契約を受け入れ、それに合わせて自身のドメインモデルを適応させる。
私たちのドメインでは、受注コンテキストは、製品カタログによって定義された契約を受け入れ、それをそのまま使用するようにコードを適応させるだけかもしれない。
```

#### Anti-Corruption Layers

- 腐敗防止層の主な役目は2つのコンテキスト間の翻訳
    - バリデーションなどは主な役目ではない(が、やるのは事実てことだよね？)

#### A Context Map with Relationship

```
受注(order-taking)と出荷(shipping)のコンテクスト間の関係は、「Shared Kernel」、つまり通信契約を共同で所有することになります。

受注(order-taking)と請求(billing)の関係は "消費者主導の契約 "であり、請求コンテキストが契約を決定し、受注システムが請求コンテキストに必要なデータを正確に供給することを意味する。

受注(order-taking)と商品カタログ(product-catalog)の関係は、"Conformist "であり、受注コンテキストは商品カタログと同じモデルを使用するようにサブミットすることを意味する。

最後に、外部のアドレスチェックサービスは我々のドメインと全く似ていないモデルを持っているので、それとのインタラクションに明示的なアンチコラプションレイヤーを挿入することにします。
これはサードパーティーコンポーネントを使用する際によくあるパターンです。
ベンダーロックインを回避し、後で別のサービスに乗り換えることができるようになる。
```

逆コンウェイの法則
https://www.thoughtworks.com/radar/techniques/inverse-conway-maneuver

### Workflows Within a Bounded Context

- 7章と関連

#### Workflow Inputs and Outputs

- PlaceOrder が入力
- OrderPlaced イベントが出力
- order-takingとbillingには`customer/supplier`関係があるので、Billingが必要とする情報をworkflowで生み出す
- Workflow は戻り値としてイベントを戻す
- `OrderAcknowledgementSent`これは何者だ？
    - メールを送ったことを認知するためのイベントかな

#### Avoid Domain Events Within a Bounded Context

- 隠れた依存関係
    - 内部限定のイベントを持つのではなくて、外部に出してしまう
    - globalでmutableな状態を持たない
        - この辺りは2章3章でも扱う

### Code Structure Within a Bounded Context

- layered architectureの問題
    - transaction script

#### The Onion Architecture

- 9章

#### Keep I/O at the Edges

- 副作用を避けたい
- database or file system に対する処理が副作用
- I/Oをオニオンの外側に追い込む
- 12章

### Wrapping Up

```
この章では、さらにいくつかのDDD関連の概念や用語を紹介してきましたので、それらを1つにまとめてみましょう。
- ドメインオブジェクト（Domain Object）は、データ転送オブジェクト（Data Transfer Object）とは対照的に、あるコンテキストの境界内でのみ使用するために設計されたオブジェクトです。
- Data Transfer Object（DTO）とは、コンテキスト間でシリアル化して共有するように設計されたオブジェクトのことです。
- Shared Kernel、Customer/Supplier、Conformist は、境界のあるコンテクスト間の異なる種類の関係です。
- ACL（Anti-Corruption Layer）とは、結合を減らしてドメインが独立して進化できるように、あるドメインから別のドメインに概念を変換するコンポーネントです。
- Persistence Ignorance（永続性無視）とは、ドメインモデルがドメイン自体の概念のみに基づいており、データベースやその他の永続性メカニズムを意識したものであってはならないということです。
```

### What's Next

```
これで、ドメインの理解と、そのソリューションを設計するための一般的なアプローチができたので、個々のワークフローのモデリングと実装という課題に移ることができます。
これからの数章では、F#の型システムを使って、ワークフローとそれが使用するデータを定義し、ドメインの専門家や開発者でない人でも理解できるコンパイル可能なコードを作成します。
まずは、関数型プログラマにとって型とは何か、オブジェクト指向設計におけるクラスとはどう違うのかを理解する必要があります。
それは次の章のテーマです。
```

---

# Part 2 Modeling the Domain

ドメインの分解について、functionalなアプローチとオブジェクト指向なアプローチでの違いを見ていく。

## Chapter 4 Understanding Types

代数的データ型

### Understanding Functions

#### Type Signatures

F#では返却する型を明示しなくても良い。 関数の中にサブ関数を置くこともできる。

#### Functions with Generic Types

#### Types and Functions

`type`はオブジェクト指向言語で言うところの`class`とは別物。

関数のoutputがまた関数であることもアリエル。

##### コラム

valuesとobjectsの違いは？

- valueはtypeのうちの1メンバー
    - 関数がvalueでもあり得る
    - immutable
- objectはデータ構造をカプセル化したもの
    - 状態を持つことを期待されている

### Composition of Types

型のcompositionについて語っていく。

#### "AND" Types

#### "OR" Types

[discriminated union](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/discriminated-unions)

直積が `product types` で、直和が `sum types` か？

### Simple Types

### Algebraic Type Systems

代数データ型はドメインモデリングをするにおいて、素晴らしいツールであるらしい。

### Working With F# Types

### Building a Domain Model by Composing Types

実例いっぱい。
*ここをJavaで表現したらどうなるか興味深い*

### Modeling Optional Values, Errors, and Collections

#### Modeling Optional Values

基本、F#は必須属性。 null許容するときはoptionをつける

#### Modeling Errors

エラーをResult型の1つの列挙子として表現する。
*Flutterとかもこのパターンだった気がする。非同期系の処理はこのパターンかしら*

#### Modeling No Value at All

基本的にはF#でvoidすることはできない。 が、unitと書くことで、何も返さないことはできる。

unitがあるということは、どこかで副作用が起きているということ

#### Modeling Lists and Collections

F#でのリストの持ち方。

Mapはあまり使わないらしい。なぜだ？

#### Organizing Types in Files and Projects

どうやって型をファイルごとに分割するか、依存順とかどうかくかについて述べている。

### Wrapping Up

```
この章では、型の概念と関数型プログラミングとの関係を説明し、F#の代数的な型システムを使って、小さな型からより大きな型を作るために型の合成をどのように利用するかを説明しました。

データをANDで結合して作られるレコード型や、データをORで結合して作られる選択肢型（判別型ユニオンとも呼ばれる）、さらにこれらを基にしたOptionやResultなどの一般的な型について紹介しました。

型がどのように機能するかを理解したので、要件を再検討して要件を再検討し、学んだことを使って文書化してみましょう。
```

## Chapter 5 Domain Modeling with Types

### Reviewing the Domain Model

2章で見たモデルを再掲している。

### Seeing Patterns in a Domain Model

- simple value
- combinations of values with and
- choices with or
- workflows

これらをF#の型を使ってどう表現していくかを見ていく。

### Modeling Simple Values

実態としてはintそのものであっても、ドメインエキスパート目線からみたら別々のものであるものを区別するように型をつける。

```
type CustomerId = CustomerId of int
```

こういうのを`simple types`という。

#### Working with Single Case Unions

#### Constrained Values

simple valuesの制限については次の章で扱う。

#### Avoiding Performance Issues with Simple Types

- 高いパフォーマンスが求められる領域で、シンプルな値をラッピングすることについて
    - F#の例で説明してるからそんな意味かも。。
    - structなるものを使う
    - 配列の話はそのままプリミティブバリューを持っていいよってこと？？

### Modeling Complex Data

代数的データ型を使ってどうなるか見ていく。

#### Modeling with Record Types

#### Modeling Unknown Types

- まだ型が決まっていないところのために、Undefinedエイリアスを用意する。
    - 設計過程で一旦こうしとくみたいな感じ
    - Javaだとからのクラスにする？->それだと設計途中であることはわからない。

#### Modeling with Choice Types

- 決まった個数の中から選べる型
    - *Javaだとenumかsealedクラス使うところかな*

### Modeling Workflows with Functions

- 動詞系で表すところについて

#### Working with Complex Inputs and Outputs

- 複数のアウトプットがある部分はそれようにrecordつくってやる

*ここでいう変換をメソッドとして表現するか、関数変数として表現すべきか？*

複数のインプットがある時は `A -> B -> C`みたいな感じにできるし、`A`と`B`をひっくるめた型を作成することもできる。

```
どの方法が良いのでしょうか？上記のケースでは、ProductCatalogが「実際の」入力ではなく依存関係にある場合、セパレート・パラメータ・アプローチを使用したいと思います。これにより、機能的にはディペンデンシー・インジェクションに相当するものを使うことができます。これについては、注文処理のパイプラインを実装する際の「依存関係の注入」で詳しく説明します。
一方で、両方の入力が常に必要であり、互いに強く結びついている場合は、レコードタイプでそのことを明確にします。(状況によっては、単純なレコード型の代わりにタプルを使うこともできますが、一般的には名前付きの型を使った方が良いでしょう)。
```

DIの絡みは9章ぽい

#### Documenting Effects in the Function Signature

effects
https://levelup.gitconnected.com/what-is-effect-or-effectful-mean-in-functional-programming-7fc7323b52b4

monadを使って表現するものがeffects？ monadは下記参照。
https://qiita.com/koher/items/6f4a8d8b3ad3142bf645#%E3%83%A2%E3%83%8A%E3%83%89%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AEoptional

### A Question of Identity: Value Objects

DDDの世界では、一意に特定できるものがEntityで、そうでないものがValue Object

#### Implementing Equality for Value Objects

structural equality
https://kotlinlang.org/docs/equality.html

### A Question of Identity: Entities

自分が名前を変えたとしても同じ自分であるように、ある種識別子を持つようなオブジェクトをEntityという。

置かれるコンテキストによって、その物体がEntityにもValue Objectにもなり得る。

#### Identifiers for Entities

Entityを識別する値を割り振る必要がある。

#### Adding Identifiers to Data Definitions

識別子を型の外側におくか、内側におくか？ パターンマッチングの時に、IDも含めて取れるので、内側に置くことが多い。

#### Implementing Equality for Entities

識別子の比較のみでequalかどうかみれるようにしておく必要がある。

そのためにequalsとhashCodeをオーバーライドしている

オブジェクト同士の比較を禁じることもできるっぽい。
(コンパイルで弾ける)
これは多分Javaだと無理。

#### Immutability and Identity

イミュータブルにどうEntityを扱う？

### Aggregates

Orderlineってなんだっけ？

Orderの中にOrderLineがあるような構造であるとき、つまり、Orderの中にOrderlineフィールドがあるような状況の時に、
Order,OrderLineともにimmutableならば、OrderLineを変更した時にOrderも変更しないといけない。

トップレベルのEntity、上記でいうOrderみたいなものを aggregate とよぶ。

#### Aggregates Enforce Consistency and Invariants

詳細は６章で

#### Aggregates References

OrderにCustomerを関連づけたい場合は、Customerをフィールドに持たせるのではなく、CustomerIdを持たせるのがよかろう。
(第三正規化みたいな考え方と思った)

aggregateがテーブルやserializeの単位になるだろう。

`consistency boundary`?

domain modelにおけるaggregatesが持つ重要な役割は以下。

- アグリゲートは、トップレベルのエンティティが "ルート" として機能し、単一のユニットとして扱うことができるドメインオブジェクトのコレクションです。
- アグリゲート内部のオブジェクトに対するすべての変更は、トップレベルを経由してルートに適用されなければならず、アグリゲート内部のすべてのデータが同時に正しく更新されることを保証する一貫性の境界として機能する。
- アグリゲートは、永続性、データベーストランザクション、およびデータ転送の原子単位である。

#### Column

DDDの用語について

- Value ObjectはIDを持たないドメインオブジェクトである。同じデータを含む2つのValue Objectは同一とみなされます。Value Object は不変でなければならず、一部でも変更されると別の Value Object になる。バリューオブジェクトの例としては、名前、住所、場所、お金、日付などがあります。
- エンティティは、ドメインオブジェクトであり、プロパティが変更されても持続する本質的な同一性を持っています。エンティティオブジェクトは一般的にIDまたはキーフィールドを持ち、同じID/キーを持つ2つのエンティティは同じオブジェクトとみなされます。エンティティは通常、寿命があり、変更の履歴があるドメインオブジェクトを表します（ドキュメントなど）。エンティティーの例としては、顧客、注文、製品、請求書などがある。
- 集約は、関連するオブジェクトの集まりで、ドメイン内の一貫性を確保し、データトランザクションで原子単位として使用するために、単一のコンポーネントとして扱われるものである。他のエンティティは、集約をその識別子によってのみ参照すべきである。これは、"ルート "として知られる集約の "トップレベル "メンバのIDである。

### Putting It All Together

`and`はなんだ？

#### The Challenge Revisited: Can Types Replace Documentation?

F#はC#やJavaより読みやすかろうと述べておる。

### Wrapping Up

```
この章では、F#の型システムを使って、単純な型、レコード型、選択肢型を使ってドメインをモデル化する方法を学びました。
この章では、stringやintなどの開発者向けの言葉ではなく、ProductCodeやOrderQuantityなどのドメインのユビキタス言語を使用しました。
マネージャー型やハンドラー型を定義したことは一度もありません。

また、さまざまな種類のアイデンティティーや、DDDのコンセプトであるValue ObjectやEntityを型を使ってモデル化する方法についても学びました。
また、一貫性を確保する方法として、「集約」という概念も紹介されました。

そして、この章の最初に出てきたテキストドキュメントとよく似た型のセットを作りました。
大きな違いは、これらの型定義はすべてコンパイル可能なコードであり、アプリケーションの他のコードに含めることができるということです。
これにより、アプリケーションのコードは常にドメイン定義と同期しており、ドメイン定義が変更されると、アプリケーションのコンパイルに失敗することになります。
デザインをコードと同期させようとする必要はありません-デザインこそがコードなのです

型をドキュメントとして使用するこのアプローチは非常に一般的であり、他のドメインにも適用できることは明らかでしょう。
現時点では実装がされていないので、ドメインエキスパートと共同作業をする際に、アイデアをすぐに試すのに最適な方法です。
もちろん、単なるテキストなので、ドメインエキスパートは特別なツールを必要とせずに簡単にレビューすることができますし、もしかしたら自分でいくつかのタイプを書くこともできるかもしれません。

しかし、デザインについてはまだいくつかの点で課題があります。
単純な型が常に正しく制約されるようにするにはどうすればよいか？
アグリゲートの整合性をどうやって確保するか？
秩序の異なる状態をどのようにモデル化するのか？これらのトピックは次の章で取り上げます。
```

## Chapter 6 Integrity and Consistency in the Domain

境界づけられたコンテキスト内の、信頼できるドメインについて、`integrity`と`consistency`という側面から見ていく章。
`integrity`は完全性と訳されるらしい。

```
ここでいう「完全性（または妥当性）」とは、データの一部が正しいビジネスルールに従っていることを意味する。例えば 
- 例えば、UnitQuantityは1〜1000の間であると言いました。
- コード内でこれを何度も確認する必要があるでしょうか。注文は、常に少なくとも1つの注文行を持つ必要があります。
- 注文は、出荷部門に送信される前に、有効な配送先住所を持つ必要があります。
```

`consistency`は一貫性。

```
ここでいう一貫性とは、ドメインモデルの異なる部分が事実について同意していることを意味する。以下はその例である．
- ある注文の請求金額の合計は、個々の行の合計であるべきです。もし合計が異なれば、データに矛盾がある。
- 注文が行われると、それに対応する請求書が作成されなければならない。注文書は存在するが、請求書が存在しない場合、データの整合性がとれなくなる。
- 注文時に割引クーポンコードを使用する場合、そのクーポンコードを使用済みとマークし、再度使用できないようにしなければならない。注文書がそのバウチャーを参照しているにもかかわらず、バウチャーが使用済みとマークされていない場合、データの整合性がとれない。
```

上記のようなことを、どのように型を使って表現していくか？

### The Integrity of Simple Values

前の章で、Stringやintで表現できる値でも型を与えるようにしていた。

現実世界のドメインでは、何らかの制限があることがほとんど。`CustomerName`にはtabを含まないとか。

immutableな値であることが保証されているならば、生成時のチェックだけで、他の使用箇所においては防御的なコーディングをする必要がない。
これは結構immutableを推す上で大事なことかもしれない。mutableなものだと、途中で変えられることがあるし。(my opinion)

constructorをprivateにしちゃう。 これ、インスタンス生成の中で値のチェックを必ずさせることが目的としてあるはずだが、それのみならコンストラクタでもできるくない？

- コンストラクタは受け取った値をはめ込むだけ、という暗黙の了解がある？
- F#だとロジックを書けない？

なんか後者な気がする。

署名ファイル？
-> Rustの所有権みたいな話につながったりするのかしら？

### Units of Measure

[測定単位](https://docs.microsoft.com/ja-jp/dotnet/fsharp/language-reference/units-of-measure)

[国際単位系](https://ja.wikipedia.org/wiki/%E5%9B%BD%E9%9A%9B%E5%8D%98%E4%BD%8D%E7%B3%BB) はF#にはデフォで入ってるようだ。

Javaにもあるっぽい。  
https://www.baeldung.com/javax-measure

### Enforcing Invariants with the Type System

型によってデータの完全性を担保する。

リストが空でないということも、`NonEmptyList`なる型を使える。(F#の言語そのものにはないが、3rdパーティライブラリとして提供されてるっぽい)
Javaだと良さげなライブラリはなさそう。

### Capturing Business Rules in the Type System

お客さんのメールアドレスに対して、認証済みのものであるか、未認証のものであるかを見分けるにあたっても、

- 認証済みのメールアドレス
- 未認証のメールアドレス

で型を作成するべき。

また、認証済みのメールアドレスを作成できるものは限定しておくべき。

---
email, 郵便番号のいずれかは必要となる、というような場合においては、

```f#
type Contact = {
   Name: Name
   Email: EmailContactInfo option
   Address: PostalContactInfo option
}
```

とすると、両方がない場合を型以外の部分で制御しないといけないので、

```f#
type ContactInfo = 
    | EmailOnly of EmailContactInfo
    | AddrOnly of PostalContactInfo 
    | EmailAndAddr of BothContactMethods
```

みたいに型で分ける。

これ、類似のもので数が増えた場合結構大変そう。。
とはいえ、上記のようにすると、ContactInfoが3つ以外の状態ではありえないことはすぐにわかる。

-> 増えた場合は別の構造を考えるのがよかろう。

#### Making Illegal States Unrepresentable in Our Domain

今回この本で考えているケースだと、validate済みのorderと未validateのorderで型を分けられる。

### Consistency

```
この章ではこれまで、ドメイン内のデータの完全性を強制する方法について見てきました。

では最後に、関連する概念である「一貫性」について見ていきましょう。本章の冒頭で、一貫性の要件の例をいくつか見てきました。
注文の合計金額は、個々の行の合計金額でなければなりません。もし合計が異なれば、データに一貫性がありません。
注文が行われると、それに対応する請求書が作成されなければならない。注文書が存在し、請求書が存在しない場合、データの整合性がとれなくなる。
注文時に割引クーポンコードを使用する場合、そのクーポンコードを使用済みとマークし、再度使用できないようにしなければならない。
注文書がそのバウチャーを参照しているにもかかわらず、バウチャーが使用済みとマークされていない場合、データに一貫性がない。

ここで説明するように、一貫性は技術用語ではなくビジネス用語であり、一貫性が意味するものは常に文脈に依存する。
例えば、商品の価格が変更された場合、未出荷の注文は直ちに新しい価格に更新されるべきでしょうか。
顧客のデフォルトの住所が変更された場合はどうでしょうか？未出荷の注文は直ちに新しい住所に更新すべきでしょうか？これらの質問に対する正しい答えはありません。

しかし、一貫性を保つことは設計に大きな負担をかけることになり、コストもかかるので、できることならその必要性を回避したいものです。
要件収集の際、プロダクトオーナーはしばしば、望ましくない、現実的でないレベルの一貫性を求めることがあります。
しかし、多くの場合、一貫性の必要性を回避したり、遅らせたりすることができる。

最後に、一貫性と永続性の原子性は関連していることを認識することが重要である。
例えば、注文がアトミックに永続化されない場合、注文が内部的に一貫していることを保証する意味はありません。
注文のさまざまな部分が別々に永続化され、ある部分が保存されなかった場合、後でその注文を読み込む人は、内部的に一貫性のない注文を読み込むことになります。
```

#### Consistency Within a Single Aggregate

aggregateが一貫性を保つ単位。

aggregateを永続化する場合には、1つのトランザクションで行うべき。

#### Consistency Between Different Contexts 

別のコンテキストと関わる一貫性を維持するためにどうするか？

[スターバックスの話](https://code.google.com/archive/p/gregors-ramblings-ja/wikis/18_starbucks.wiki) を引き合いに出していた。

結果整合性
即時に一貫した状態になる必要がないのであれば、イベントを発行して、リスナーがそれを処理する形に持っていけば良い。

補正トランザクションパターン
https://docs.microsoft.com/ja-jp/azure/architecture/patterns/compensating-transaction

#### Consistency Between Aggregates in the Same Context

同じ境界づけられたコンテキスト内で上記と同様の状況が起きたらどうするか？
-> 場合によるが、原則1つのアグリゲートを1つのトランザクションで行うべき。
集約をどうにか使い回すよりは、新しい集約の単位を作るべき。

#### Multiple Aggregates Acting on the Same Data

```
先ほど、アグリゲートは整合性制約を適用するために機能すると強調しましたが、同じデータに対して機能する複数のアグリゲートがある場合、どのようにして制約が一貫して適用されることを確認できるでしょうか。
例えば、口座の残高に作用し、残高がマイナスにならないことを保証する必要がある、口座アグリゲートと送金アグリゲートがあるとします。

多くの場合、制約が型を使用してモデル化されている場合、複数の集約間で共有することができます。
例えば、口座残高が決してゼロ以下にならないという要件は、NonNegativeMoney型を使用してモデル化することができます。
これが適用できない場合は、共有の検証関数を使用することができます。
これは、オブジェクト指向モデルに対する関数型モデルの利点のひとつです。
検証関数は特定のオブジェクトに添付されず、グローバルな状態に依存しないので、異なるワークフローで容易に再利用できます。
```

ここのオブジェクト指向モデルとの比較はよくわからないなぁ。


### Wrapping Up

```
この章では、ドメイン内のデータが信頼できることを保証する方法を学びました。

単純な型には「スマートなコンストラクタ」を、より複雑な型には「不正な状態を表現できないようにする」ことを組み合わせることで、型システムそのものを使って多くの種類の整合性ルールを強制できることを確認しました。
これにより、コードの自己文書化が進み、ユニットテストの必要性も少なくなります。

また、1つの境界コンテキスト内と境界コンテキスト間で一貫したデータを維持することについて調べ、1つの集合体内で作業するのでなければ、即時の一貫性よりも最終的な一貫性のために設計すべきだと結論付けました。

次の章では、注文を出すワークフローをモデル化しながら、これらすべてを実践していきます。
```

## Chapter 7 Modeling Workflows as Pipelines

### The Workflow Input

#### Commands as Input

#### Sharing Common Structures Using Generics

同様の構造を共有したい場合、ooでは基底クラスを作ったりする。
functionalの世界では、それをgenericsで実行する。

#### Combining Multiple Commands in One Type

受け取るコマンドが複数ある場合の話？ -> 選択型を使って云々やっている。
あんまり腹落ちはしていない

### Modeling an Order as a Set of States

orderは静的なドキュメントではなくて、さまざまな状態を変遷していくものである。
馬鹿正直にやると、各状態のフラグをもたせることになる。
このアプローチは色々な問題を抱えている。

- このシステムは、さまざまなフラグによって示されるように、明らかに状態を持っています。しかし、状態は暗黙的なもので、これを処理するためには多くの条件コードが必要になります。
- また、状態によっては他の状態では不要なデータもあり、それらをすべて1つのレコードに入れると設計が複雑になる。例えば、AmountToBillは "priced "ステートでのみ必要ですが、他のステートには存在しないため、フィールドをオプションにする必要があります。
- どのフィールドがどのフラグに対応するのかが明確ではありません。AmountToBillはIsPricedが設定されているときに設定される必要がありますが、設計上それが強制されないため、データの一貫性を保つためにコメントに頼らざるを得ません。

これよりは、各状態で別の型を作ってあげたほうが良い。


`Quote`ってなんだっけ？ -> 見積もりか

#### Adding New State Types as Requirements Change

型で状態を分けるメリットとしては、既存のコードに変更を加えなくても拡張できることにある

### State Machines

stateの遷移を表す図のことをstate machineと呼んでいる。

stateの遷移の例としては、
- emailの検証済み、未検証、
- カートのempty, active, 支払い済み
- 配送において、荷物の、配送中、配送済み、配達されていない
みたいな感じ
  
- [StatePattern](https://ja.wikipedia.org/wiki/State_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)との絡みとかある？
  
#### Why Use State Machines?

state machineを利用することによって得られる利点。

- それぞれの状態は、許容される動作が異なる場合があります。
  - たとえば、ショッピングカートの例では、アクティブなカートだけが支払いを行うことができ、支払われたカートは追加することができません。前の章で、未確認/確認済みメールの設計について説明したとき、確認済みメールアドレスにのみパスワードリセットを送信できるというビジネスルールを見ました。各状態に個別の型を使用することで、その要件を関数の署名に直接エンコードし、コンパイラーを使用してそのビジネスルールが遵守されていることを確認することができました。
- すべての状態が明示的に文書化されている。
  - 暗黙の了解で文書化されていない重要な状態を持つことは容易である。ショッピングカートの例では、「空のカート」は「アクティブなカート」と異なる動作をするが、これがコードで明示的に文書化されることは稀だろう。
- このように、起こりうるすべての可能性を考えさせるのが、設計ツールなのです。
  - 設計でよくあるエラーの原因は、特定のエッジケースが処理されていないことです。ステートマシンは、すべてのケースを強制的に考えさせます。例えば
    - すでに認証されているメールアドレスを認証しようとするとどうなりますか？
    - 空のショッピングカートから商品を削除しようとするとどうなりますか？
    - すでに「配達済み」になっている荷物を配達しようとするとどうなるのでしょうか？

オートマトンとかとの絡み。
どういう関係なんだろう。
-> 
有限オートマトンという概念が、有限個の状態と遷移と動作の組み合わせからなる振る舞いのモデルをさす。
それを具体的に表現する手段の1つがステートマシン。
https://ja.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E3%82%AA%E3%83%BC%E3%83%88%E3%83%9E%E3%83%88%E3%83%B3

#### How to Implement Simple State Machines in F#

### Modeling Each Step in the Workflow with Types

state machineの各ステップをみていく

各ステップとは,validate, pricing, acknowledgement

#### The Validation Step

validateOrderというステップにおいては、ProductCode、住所のチェックに依存している。
これをどう表現するか？

ここでいう依存とはなんだろう?

dependencyとなる引数を先に持ってきているが、これはアプリケーションの分割？を容易にすることにつながるらしい。
-> partial application

#### The Pricing Step

#### The Acknowledge Order Step

受注確認の文言を作って、メールをお客さんに送る。

PricedOrderを受け取って、メールを送信する感じ

#### Creating the Events to Return

配送のために`OrderPlaced`,課金のために`BillableOrderPlaced`も`OrderAckowledgementSent`に加えてアウトプットとして必要。

これら3つを内包した型を定義するよりは、これら3つの選択型である`PlaceOrderEvent`のリストを返却するのが良い。

### Documenting Effects

#### Effects in the Validation Step

effectsは言葉通り、物理世界に影響を与えるものと捉えるのが良かろう。
http://like-a-boss.net/2014/12/31/effects-versus-side-effects.html

ここだと、バリデーションで外部に問い合わせる必要があって、それをAsync,Resultで囲んでいる。

#### Effects in the Pricing Step

金額がマイナスだったり、めちゃデカかったりする時はエラーになるので、それを考慮してResultにした感じ。

#### Effects in the Acknowledge Step

### Composing the Workflow from the Steps 

AsyncResultとかにくるまっているから、functionをそのまま繋げるといったsimpleなことはできない。
ここの解決は実装の章で見ていく

### Are Dependencies Part of the Design?

workflowの依存関係を引数に入れるべきかはガイドラインがある。

- publicなAPIの場合は隠す。
  - 呼ぶ人はそんなもの知ったこっちゃないので
- 内部で使われるものに関しては引数でとる。
  - 何に依存しているか明らかになるので良い。

モノリスなアプリにおけるドメインわけの話に見える。普通ならドメインごとにapiで連携するはずなので。

### The Complete Pipeline

#### The Internal Steps

### Long-Running Workflows

他のステップから値が返ってくるスピードが遅い場合、storageに情報を保存してやり取りするのもあり。

long-running workflowをSagasと呼ぶらしい。
http://vasters.com/archive/Sagas.html

### Wrapping Up

```
この章では、型のみを使用してワークフローをモデル化する方法について学びました。

私たちは、ワークフローへの入力を文書化することから始め、特にコマンドをどのようにモデル化するかについて学びました。
次に、ステートマシンを使って、ドキュメントやライフサイクルを持つ他のエンティティをどのようにモデル化するかを検討しました。
また、各ステップの依存関係や効果を文書化することにも力を入れました。

その過程で、何百もの型を作成したように思います（実際には約30の型しかありませんでした）。
これは本当に必要だったのでしょうか？多すぎるのでしょうか？
多いように見えるかもしれませんが、私たちは実行可能なドキュメント、つまりドメインを伝えるコードを作成しようとしていることを思い出してください。
もしこれらの型を作らなかったとしても、検証済み注文と価格決定済み注文の違いや、ウィジェットコードと通常の文字列の違いを文書化しなければならないでしょう。

なぜ、ドキュメントをコードそのものにしないのでしょうか？もちろん、常にバランスは必要です。
ここでは、すべてをこの方法で文書化した場合にどのように見えるかを示すために、意図的に極端な方法をとっています。
もし、この方法があなたの状況にとって行き過ぎだと思われるなら、あなたのニーズに合わせて自由に縮小してください。
いつものように、あなたは、ドメインに貢献し、目の前のタスクに最も役立つことを行う必要があります。
```

### What's Next

```
この4章はモデリングに終始してきましたが、ついに最終章に到達し、実際の実装に手を染めることができるようになりました!

この章では、先に進む前に明らかにしておきたいことがあります。
この本では、要求の収集、モデリング、コーディングをそれぞれ別のセクションに分けました。
これは、直線的な「ウォーターフォール」型の開発を推奨しているように見えるかもしれませんが、全くそのような意図はありません。
実際のプロジェクトでは、要件収集とモデリング、モデリングとプロトタイピングを継続的に組み合わせ、顧客や専門家にできるだけ早くフィードバックできるようにする必要があります。
実際、型を使ったモデリングの要点は、ドメインエキスパートが直接モデルを読むことができるため、要件からモデリングへ、そしてまたモデリングへ、数日ではなく数分で戻ることができるようにすることなのです。

これで、実装の章を始める準備ができました。
最初のステップとして、関数がどのように機能するのか、そして関数からどのようにアプリケーションを構築するのかを理解することを確認しましょう。
次の章でそれを行います。
```

# Part 3 Implementing the Model

関数型のテクニックを使って実装していく。
コンポジション、部分アプリケーション？、モナド

## Chapter 8 Understanding Functions

関数型言語のいいところをみていく

### Functions, Functions, Everywhere

オブジェクト指向言語と関数型言語は色々な面で考え方が違う。

### Functions Are Things 

Inputとparameterの違いって何だっけ？

#### Treating Functions as Things in F#

#### Functions as Input

関数をInputととしてとる例をみていく

#### Functions as Output

関数をOutputとしている例を見ていく

#### Currying

複数のパラメータをもつ関数を、1つのパラメータを持つ関数に変換することをカリー化という。

F#では明示的にカリー化をせずとも、すでにカリー化された関数になっている？

#### Partial Application

パラメータを織り込んでしまう技法をpartial applicationと呼ぶらしい。日本語訳は？

### Total Functions

全てのインプットには紐づくアウトプットがあるという考え方のこと？

https://softwareengineering.stackexchange.com/questions/334874/in-the-context-of-functional-programming-what-are-total-functions-and-partia

どうやら、インプットとして考えうる値を全て定義した関数という意味合いっぽい

### Composition

関数の合成の話っぽい

#### Composition of Functions in F#

ある関数のアウトプットと、ある関数のインプットが同じ場合に、`piping`という手段で合成を行うことが多い。
linuxのパイプと同じ

#### Building an Entire Application from Functions

小さなfunctionを繋げていって、繋げていって、アプリケーションを作る

#### Challenges in Composing Functions

アウトプットとインプットの型が合わない時はどうやって合成する？
->
何らかの関数をかます。例えば、intからOption<int>に変換するのなら、Someをかます。

### Wrapping Up 

```
この章では、F#における関数型プログラミングの基本的な概念、すなわち、あらゆる場所で関数をビルディングブロックとして使用し、それらを構成可能なように設計することを紹介しました。
この原則を理解した上で、いよいよ本格的なコーディングに入ります。次の章では、これらの概念を実践し、発注ワークフローのパイプラインを構築することから始めます。
```

## Chapter 9 Implementation: Composing a Pipeline

これまで見てきた例について、関数の合成を行っていく。
関数の合成を行っていく際には、依存に関わる部分とeffectsが生じる関数が単純な合成を阻む。

この章ではDIについて見ていく。effectsに関するところについては次の章で見る。

### Working with Simple Types

createというファクトリメソッド
値を容易に取り出すためにvalueメソッドを用意

### Using Function Types to Guide the Implementation

function型を使う利点について述べているが全く分からない。
F#に限定された話か？

### Implementing the Validation Step

`toCustomerInfo`や`toAddress`は変換ヘルパーメソッド

#### Creating a Valid, Checked Address

addressをチェックするところの実装

F#の実装方法でつまづくようになってきたな。。

#### Creating the Order Lines

letで出てくる()ってなんだっけ?
->
https://docs.microsoft.com/ja-jp/dotnet/fsharp/language-reference/functions/let-bindings#type-annotations

`to~~`みたいなファクトリメソッドの紹介

#### Creating Function Adapters

汎用的に利用できるadapterのようなものを作成
function transformer

### Implementing the Rest of the Steps

#### Implementing the Acknowledgment Step

`sendAcknowledgment`の実装詳細はまだ明らかにしなくとも良い

#### Creating the Events

`createBillingEvent`で`BillableOrderPlaced`イベントを作成する

最小公倍数の手法(lowest common multiple approach)ってなんだっけ？
-> 多分そのまま最小公倍数の意味

`listOfOption`でoption をlistにする。

yieldとはなんだっけ？
https://docs.microsoft.com/ja-jp/dotnet/fsharp/language-reference/sequences#the-yield-keyword
yieldを使えば、シーケンスの要素を返すことができる。
yield []の形にすれば、listの中の要素をバラしてシーケンスの要素とすることができる。

互換性のないものを共有型にするテクニックを使っているらしい。
上記でいくとどこだ？
PlaceOrderEventで選択型を作っているところか？

### Composing the Pipeline Steps Together

```F#
let placeOrder: PlaceOrderWorkflow = 
  fun unvalidateOrder -> 
    unvalidatedOrder
    |> validateOrder
    |> priceOrder
    |> acknowledgeOrder
    |> createEvents
```

形の異なる関数を合成することが関数型プログラミングの課題。
解決のほとんどはモナドだが、ここでは部分適用(partial application)を適用してみる

下記みたいに１つのパラメータを持つ関数に変形する。

```F#
let validateOrder' = validateOrder checkProductCodeExists checkAddressExists
```

次に依存性の注入方法を見ていく

### Injection Dependencies



### Wrapping Up

```
この章では、パイプラインのステップの実装と依存関係の処理に全面的に集中した。
各ステップの実装は、1つのインクリメンタルな変換を行うことに焦点を絞ったもので、単独での推論やテストが容易なものでした。

しかし、ステップを合成するときに、型が一致しないことがありました。そこで、3つの重要な関数型プログラミングの手法を導入しました。
- 「adapter function」を使って、関数をある「形」から別の「形」に変換する。この例では、checkProductCodeExistsの出力をboolからProductCodeに変更する。
- イベントと同じように、異なる型を共通の型に「Lifting」することで、すべての型を共通のPlaceOrderEvent型に変換する。
- 部分的なアプリケーションを使用して依存関係を関数に焼き付けることで、関数をより簡単に構成できるようになり、また呼び出し元から不要な実装の詳細を隠すことができます。

本書の後半で、これらの同じテクニックを再び使用することになります。

まだ、1つ触れていないことがあります。
この章では、エフェクトの処理を避け、代わりにエラー処理に例外を使用しました。
これは構成する上では便利ですが、文書化する上では最悪で、私たちが望むような、より明示的な関数シグネチャではなく、まやかしの関数シグネチャを導くことになります。
次の章では、それを修正します。すべての結果型を関数型に戻し、それをどのように扱うかを学びます。
```

## Chapter 10 Implementation: Working with Errors 

### Wrapping Up 

```
エラー処理と非同期効果に対する型安全なアプローチを取り入れた、パイプラインの改訂版実装が完成しました。
上のメインのplaceOrderの実装はまだ非常に明確で、流れを乱す醜いエラー処理コードはありません。
確かに、すべての型を正しく揃えるために厄介な変換をしなければなりませんでしたが、その余分な努力は、すべてのパイプラインコンポーネントが何の問題もなく一緒に機能するという確信に報われるのです。

次の数章では、ドメインと外界の間のインタラクションの実装に取り組みます。
データのシリアライズとデシリアライズの方法と、データベースへの状態の永続化の方法です。
```

## Chapter 11 Serialization 

### Wrapping Up

```
この章では、境界のあるコンテキストとクリーンなドメインを離れ、インフラの厄介な世界へと足を踏み入れました。
この章では、境界のあるコンテキストと外の世界をつなぐ仲介役として、直列化可能なデータ転送オブジェクトを設計する方法を学び、独自の実装に役立つ多くのガイドラインを調べました。

シリアライゼーションは外の世界との相互作用の一種ですが、それだけではありません。
ほとんどのアプリケーションでは、ある種のデータベースと対話する必要があります。
次の章では、リレーショナルデータベースやNoSQLデータベースでドメインモデルを動作させるための、永続化のテクニックと課題に目を向けます。
```

## Chapter 12 Persistence

### Wrapping Up

```
この章では、まず、クエリとコマンドを分離する、I/Oをエッジに留める、境界のあるコンテキストが自身のデータストアを所有する、といった永続化の高レベルな原則をいくつか見てきました。
そして、リレーショナルデータベースと対話するための低レベルのメカニズムに飛び込みました。

そして、本書の第3部の終わりを迎えました。
ドメイン内の純粋な型と関数 (第9章実装: パイプラインの構成)、エラー処理 (第10章実装: エラーの処理)、エッジでのシリアライズ (第11章シリアライズ)、そして本章では状態を保存するためのデータベースです。
しかし、私たちはまだ全く終わっていません。
軍隊のことわざに、"敵と接触して生き残る計画はない "というのがあります。
では、新しいことを学び、設計を変更する必要があるときはどうするのでしょうか？それが、次の最終章のテーマです。
```

## Chapter 13 Evolving a Design and Keeping It Clean

### Wrapping Up 

```
この章では、4つの要件変更に対応して設計を進化させる中で、型駆動のドメインモデリングと、関数からワークフローを作成する構成的アプローチのメリットを確認しました。

型駆動設計では、ドメイン型に新しいフィールドを追加すると（ValidatedOrderにVipStatusを追加するなど）、すぐにコンパイラーエラーが発生し、データの出所を特定することを余儀なくされました。
その結果、コンパイラーエラーがなくなるまで、他の型を修正するように誘導される。

同様に、プロモーションコードの例で依存関係の1つを変更したとき（GetProductPriceからより複雑なGetPricingFunctionへ）、これも多くのコンパイラーエラーを引き起こしました。
しかし、コードが修正され、コンパイラーエラーがなくなった後、私たちの実装が再び正しく動作していることに非常に自信を持つことができます。

また、ワークフローを構築する上で、関数合成を利用することのメリットも分かりました。
ワークフローに新しいセグメントを簡単に追加することができ、他のセグメントはそのままにしておくことができます。
もちろん、既存のコードに変更を加えないということは、バグが発生する可能性も低くなります。

最後に、「営業時間」の例では、「インターフェースとしての関数型」のおかげで、既存のコードとのプラグイン互換性を維持しながら、関数全体を強力に変換できることを確認しました。
```

### Wrapping Up the Book

```
この本では、bounded contextsのような抽象度の高いものから、シリアライズ形式の細かなものまで、さまざまな分野をカバーしています。

Webサービス、セキュリティ、運用の透明性など、多くの重要なトピックをカバーする機会はありませんでしたが、そのうちのいくつかを紹介します。
しかし、本書を読み進める過程で、どのような設計問題にも適用できるテクニックやスキルが身についていれば幸いです。

ここでは、これまで述べてきた中で最も重要なプラクティスをいくつか紹介します。
- 低レベルの設計を開始する前に、ドメインについて深く、共通の理解を深めることを目指すべきである。私たちは、このプロセスで非常に役立つ発見技術（イベントストーミング）とコミュニケーション技術（ユビキタス言語の使用）をいくつか取り上げました。
- そして、各ワークフローは、入力と出力を明示した独立したパイプラインとして表現されるべきです。
- コードを書く前に、ドメインの名詞と動詞の両方を捕らえるために、型に基づいた表記法を使用して要件を捕らえることを試みるべきである。これまで見てきたように、名詞はほとんど常に代数的な型システムで、動詞は関数で表すことができる。
- 重要な制約やビジネスルールは、可能な限り型システムに取り込むようにしなければならない。私たちのモットーは、「違法な状態を表現できないようにする」ことです。" 
- また、関数は「純粋」で「完全」であるように設計する必要があり、可能なすべての入力は明示的に文書化された出力を持ち（例外なし）、すべての動作は完全に予測可能です（隠れた依存関係なし）。

このようなプロセスを経て、受注・発注のワークフローでは、実装の指針と制約となる詳細な型のセットを作成することができました。

そして、実装の過程では、次のような関数型プログラミングの重要なテクニックを繰り返し使用しました。
- 小さな関数の組み合わせだけで、完全なワークフローを構築する。
- 依存関係や後回しにしたい意思決定があるときは、関数をパラメータ化する。
- 部分適用を使用して依存関係を関数に焼き付けることで、関数をより簡単に構成し、不要な実装の詳細を隠すことができます。
- 他の関数を様々な形に変換できる特殊な関数を作成する . 特に、bind - エラーを返す関数を、簡単に合成できる2トラック関数に変換するために使用する「アダプタブロック」について学びました。
- 異種の型を共通の型に " リフトアップ " することで、型の不一致の問題を解決する。

この本では、関数型プログラミングとドメインモデリングが非常に相性が良いことを納得してもらうことを目的としました。
そして、あなたが学んだことを自分のアプリケーションに応用する自信を得てくれることを願っています。
```

