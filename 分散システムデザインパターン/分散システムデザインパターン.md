1章 はじめに
=======

分散システムの構築は困難。だが、技術の進歩によってその難しさがいくらか低減されてきた。
その技術の進歩とは、コンテナとコンテナオーケストレータである。


1.1 システム開発の歴史概観
------

分散システム ⇒ ネットワークで接続された複数のコンピュータで作業を分担して行うシステム
(https://hnavi.co.jp/knowledge/blog/distribution_system/)

1.2 ソフトウェア開発におけるパターンの歴史概観
-------
パターン、慣例、再利用可能なコンポーネント、といった考え方は分散システムに当てはめられる前からあった。

1.2.1 アルゴリズムによるプログラミングの形式化
各プログラムの背景にある、アルゴリズムを抽出し、アルゴリズムから汎用的な考え方を学ぶ。

1.2.2 オブジェクト指向プログラミングパターン

1.2.3 オープンソースソフトウェアの隆盛



1.3 パターン、慣習、コンポーネントの価値
----------------------

1.3.1 巨人の肩の上に立つ

1.3.2 1つのやり方を議論するための共通言語

1.3.3 簡単に再利用できる共有コンポーネント

1.4 まとめ
-----
分散システムのデザインを改善できるように、共通パターン、やり方を明らかにすることが本書の目的。


第Ⅰ部 シングルノードパターン
===============

シングルノードパターンを使う理由
----------------

* リソースの分離のため
* モジュールを再利用するため
* テスト、更新、デプロイが容易になり、アプリケーションのすばやさ、柔軟性が向上するため


2章 サイドカー
========

2.1 サイドカーの例：レガシーサービスのhttps対応
----------------------------

* レガシーなサービスをpod上にのせて、このpodはlocalhostからの通信のみ受け付けるようにして、外部からの通信は遮断する。そのpodと同じネットワーク内にサイドカーとなるnginxのpodをたてて、これをエンドポイントにし、SSLプロキシの役目を果たさせる。

2.2 サイドカーによる動的な設定
-----------------
 
* APIによる設定の更新を受け付けていないようなレガシーなアプリケーションに対して、サイドカーモジュールを作用させることによって、APIによる変更を可能にさせることができる。

2.3 モジュール化されたアプリケーションコンテナ
-------------------------

* 対象の既存モジュールに対して、topコマンドなどのリソース使用状況をみるインターフェースを提供するためのモジュールを付け加える。

2.3.1 ハンズオン：topzコンテナのデプロイ

2.4 サイドカーを使ったシンプルなPaaSの構築
-------------------------

* デプロイされているアプリケーションが、Gitリポジトリのソースと常に同期しているようなPaaSの実現に際してもサイドカーパターンが用いられる。

2.5 モジュール化と再利用性を考えたサイドカーの設計
---------------------------

サイドカーはモジュール化されていて、再利用可能であるべき。
それを満たすために、以下のようなことが大事になってくる。

* コンテナのパラメータ化
* コンテナのAPI仕様の設計
* コンテナのオペレーションのドキュメント化

2.5.1 パラメータ化されたコンテナ

2.5.2 各コンテナのAPI仕様の設計

2.5.3 コンテナのドキュメント化

2.6 まとめ

3章 アンバサダ
========

アンバサダは他とのやり取りを仲介する役目をになう。

3.1 サービスのシャーディングへの利用
--------------------

そもそもシャーディングとは、ストレージレイヤを複数に分割し、それぞれが別のマシンでホストされるようにする仕組みのことを指す。
アンバサダモジュールは、シャーディングされたどのマシンに命令を振り分けるかを担当してくれる。
元のアプリケーションで振り分けのロジックも組み込んでしまう手もあるが、そこは要件に応じて適宜使い分ける。

3.2 サービスブローカとしての利用
------------------

ポータブルなアプリケーションは、その環境に応じて接続先のDBなどを探しに行く必要がある。このプロセスのことをサービスディスカバリという。
このサービスディスカバリを何とかしてくれるのがサービスブローカ。
アンバサダモジュールはサービスブローカの役割を担ったりする。

3.3 新システムの実験的運用やリクエスト分割への利用
---------------------------

タイトル通り。

4章 アダプタ
=======

アダプタはアプリケーションのインターフェースを変更するために用いる。


4.1 監視
------------------

アダプタコンテナは、アプリケーションコンテナが公開している監視インターフェースを汎用的な監視システムが利用するインターフェースに変換する。

4.2 ロギング
-----------

アダプタによってログの正規化ができる。

4.3 ヘルスモニタの追加
------

アダプタで対象アプリケーションの死活監視をする。

第Ⅱ部 マルチノードパターン
========

Ⅱ.1 マイクロサービス入門
-----

5章 レプリカがロードバランスされたサービス
=====


5.1 ステートレスなサービス
-----

5.1.1 ロードバランスのためのReadinessProbe

ReadinessProbeはアプリケーションがユーザーからのリクエストに応答する準備が整っているかチェックする。
コンテナの起動が済んでいるだけでなく、DB接続やプラグインのロードがなされていることもチェックする。

5.2 セッションを保存するサービス
-----
ロードバランシングするときに、同じユーザーからの通信を同じサーバーに送るため、送信元、送信先のIPのハッシュを取る。

5.3 アプリケーションレイヤでレプリカを扱うサービス
-----

5.4 キャッシュレイヤの導入
---

キャッシュの導入には、サイドカーパターンを使って、1つのPodにWebキャッシュコンテナとWebサービスコンテナを入れ込むことが一番シンプル。

ただし、そのような構成にするとWebサーバと一緒にキャッシュサーバもスケールするようにせねばならない。

キャッシュには大きなリソースを割り当てつつ、レプリカ数は小さくしたい。
一方、Webサーバーは小規模なものをたくさん用意したい。(ここの理由がいまいち？？)

よって、Webサーバーの一段上のレイヤにキャッシュサーバーを配置すべき。

5.5 キャッシュレイヤの拡張
-------

5.5.1 帯域制限とDoS攻撃に対する防御

DoS対策のために、ユーザーの制限をしたり、キャッシュサーバーでの帯域制限を行うべき。

5.5.2 SSL終端
??

5.5.3 ハンズオン：nginxとSSL終端のデプロイ

5.6 まとめ
---

6章 シャーディングされたサービス
===

レプリカを使ったサービスでは、各レプリカはどのリクエストにも対応できる。
一方シャーディングされたサービスでは、各レプリカ（シャード）はリクエストの一部に対応できる。

レプリカはステートレスなサービスを作るのに用いられ、シャーディングはステートフルなサービスを作るのに用いられる。
データのシャーディングは、保存すべきデータのサイズが1台のマシンで処理するには大きすぎる場合に行われる。

6.1 シャーディングされたキャッシュ
-----

6.1.1 シャーディングされたキャッシュの必要性
キャッシュの場合、同じデータをメモリ上に保有するレプリカを用意しても効率が悪い。
それぞれ別のデータをシャーディングしたほうが効率は良い。

6.1.2 アーキテクチャ内でのキャッシュの役割
キャッシュヒット率はシステムのキャパシティとパフォーマンスに影響する。

例えばリクエストの処理レイヤの前段に50%のキャッシュヒット率のキャッシュを用意すれば、理論上は2倍のRPSをさばけることになる。
（キャッシュの障害を加味して、最大許容RPSは1.5倍位にしとくべき）

また、キャッシュの応答時間は、キャッシュなしの応答に比べて短いので、待ち時間が短くなる。

シャーディングされたキャッシュがアップグレードしたりデプロイされたりすると、一時的に負荷が上がるので注意。

6.1.3 シャーディングされたキャッシュのレプリカ


6.1.4 ハンズオン：アンバサダのデプロイとシャーディングされた memcached

アンバサダとシャードルータのどちらを使うかはトレードオフの関係にある。

* シャードルータを使うと、複雑さは小さくなる。
* 負荷が増えた時にルータをスケールさせる必要がある
* ルータを使う分ネットワークのホップが1つ増え、レイテンシが大きくなる

6.2 シャーディング関数を試してみる
------

シャーディング関数にとって大事なのは、決定性と均一性。つまり、同一のリクエストは必ず同じシャードに送られ、負荷はシャード間で均一であるようにするべきということ。

```
Shard = hash(Req) % N 
```

こんな感じ。

6.2.1 キーの選択

シャーディングされたシステムをただしくデザインするには、シャーディング関数に適切なキーを使用することが重要

6.2.2 コンシステントハッシュ関数

キャッシュの数を増やした場合に、普通のキャッシュ関数だとたくさんのキャッシュミスが起こるが、コンシステントハッシュ関数を使えばreマッピングを少なく抑えらえる


6.2.3 ハンズオン：コンシステントなHTTPシャーディングプロキシの構築

シャーディング関数のキーには、一般的には、リクエストパス、クエリパラメータ、フラグメントが指定されることが多い

6.3 シャーディングされたレプリカを使ったシステム
-------

大規模ゲームなんかでもシャーディングは用いられる。
その場合のシャーディング関数のキーはプレーヤーの地域になったりする。

6.4 ホットシャーディングシステム
--------

理想的にはシャーディングされたキャッシュに対する負荷は均等であるべきだが、何かばずったりして、特定のシャードに負荷が集中することはあり得る。
そのような場合は、負荷が集中しているサーバをスケールする。


7章 スキャッタ・ギャザー
=========

7.1.1 ハンズオン：分散ドキュメント検索

7.2 リーフをシャーディングしたスキャッタ・ギャザー
--------
対象とするデータ量が膨大である場合、データをシャーディングして保持する。そこでもスキャッタ・ギャザーの仕組みは使える。

7.2.1 ハンズオン：シャーディングされたドキュメント検索

7.2.2 適切なリーフ数の決め方

* ノード毎のオーバーヘッドがあるので、リーフノードを増やすにしても限界はある。
* ルートノードはすべてのリーフノードからの応答を待つ必要があるので、一番遅いレスポンスに引っ張られる。

これらを考慮してリーフ数を決める。

7.3 信頼性とスケーラビリティのためのスキャッタ・ギャザーのスケール
---------


8章 ファンクションとイベント駆動処理
========

8.1 FaaSを使うべき時の判断
-------------

8.1.1 FaaSの利点

クラウド上へのコードの移行がシンプル。
自動的にスケールしてくれる。

8.1.2 FaaSの課題

サービス運用が難しくなる可能性がある。

8.1.3 バックグラウンド処理の必要性

通常はファンクションを実行するインスタンスの実行時間には制約がある。
そのため、データ処理が必要となるような処理はFaaSには向いていない。
例えば、動画変換、ログの圧縮など。


8.1.4 データをメモリに置いておく必要性

8.1.5 リクエストベースの処理を保持しておくコスト

FaaSはリクエスト数に対する課金が生じるビジネスモデル。
サービス初期はリクエスト数が少なくても、サービス成長につれてリクエストが増えて、FaaSの選択が経済的でなくなる可能性がある。

解決策としては、コンテナオーケストレータ上で動くオープンソースのFaaSを使うこと。（??どんなん）

8.2 FaaSのパターン
-------

8.2.1 デコレータパターン：リクエストまたはレスポンスの変換

メインの処理の前段でメイン処理に流すリクエストを変換するFaaSを置く感じ。

例えば、あるフィールドのデフォルト値をtrueにしたいとする。
JSONのデフォルト値はnullであることが多く、nullはfalseと解釈されることが多い。
このnullをtrueに変換する処理をFaaSで持つ。
メインの処理に持つべきという考えもあるが、メインの処理とこの変換処理は独立した処理なので分けたほうが理想的。
シングルノードとして1つのコンテナの中にパッケージングするという意見がある。が、この変換処理は軽いもので、メインの処理とともにスケールしていきたくはない。

8.2.2 ハンズオン：リクエスト処理前のデフォルト値設定
kubeless を使って試している。

8.2.3 イベントの扱い

リクエストは大きなやり取りの中の一部であるのに対し、イベントは1回限りのインスタンスであり、非同期である傾向がある。

8.2.4 ハンズオン：2要素認証の実装

8.2.5 イベントベースのパイプライン


8.2.6 ハンズオン：新規ユーザ登録のパイプライン実装

9章 オーナーシップの選出
=====

複数あるレプリカの中から、どのレプリカがオーナーシップを取るか決める。

9.1 マスタ選出の必要性の判断
------

サービスに一台しかインスタンスがいない状態であれば、シンプルさを保つことができる。
SLAとシンプルさのトレードオフを考えて設計するべき。

9.2 マスタ選出の基本
------

分散キーバリューストアを使う。
etcd、ZooKeeper、Consulなど。

9.2.1 ハンズオン：etcdのデプロイ

9.2.2 ロックの実装

9.2.3 ハンズオン：etcdでのロックの実装

9.2.4 オーナーシップの実装

9.2.5 ハンズオン：etcdでの期間指定付きロックの実装

この章は難しい。

第Ⅲ部 バッチ処理パターン
====

10章 ワークキューシステム
--------------------------

バッチ処理の最も簡単が形がワークキュー。

10.1 汎用ワークキューシステム
------

10.1.1 ソースコンテナインタフェイス




