1章 はじめに
=======

1.3 パターン、慣習、コンポーネントの価値
----------------------

### 1.3.1 巨人の肩の上に立つ

### 1.3.2 1つのやり方を議論するための共通言語

### 1.3.3 簡単に再利用できる共有コンポーネント

第Ⅰ部 シングルノードパターン
===============

シングルノードパターンを使う理由
----------------

* リソースの分離のため
* モジュールを再利用するため
* テスト、更新、デプロイが容易になり、アプリケーションのすばやさ、柔軟性が向上するため


2章 サイドカー
========

2.1 サイドカーの例：レガシーサービスのhttps対応
----------------------------

* レガシーなサービスをpod上にのせて、このpodはlocalhostからの通信のみ受け付けるようにして、外部からの通信は遮断する。そのpodと同じネットワーク内にサイドカーとなるnginxのpodをたてて、これをエンドポイントにし、SSLプロキシの役目を果たさせる。

2.2 サイドカーによる動的な設定
-----------------
 
* APIによる設定の更新を受け付けていないようなレガシーなアプリケーションに対して、サイドカーモジュールを作用させることによって、APIによる変更を可能にさせることができる。

2.3 モジュール化されたアプリケーションコンテナ
-------------------------

* 対象の既存モジュールに対して、topコマンドなどのリソース使用状況をみるインターフェースを提供するためのモジュールを付け加える。

2.4 サイドカーを使ったシンプルなPaaSの構築
-------------------------

* デプロイされているアプリケーションが、Gitリポジトリのソースと常に同期しているようなPaaSの実現に際してもサイドカーパターンが用いられる。

2.5 モジュール化と再利用性を考えたサイドカーの設計
---------------------------

サイドカーはモジュール化されていて、再利用可能であるべき。
それを満たすために、以下のようなことが大事になってくる。

* コンテナのパラメータ化
* コンテナのAPI仕様の設計
* コンテナのオペレーションのドキュメント化

3章 アンバサダ
========

アンバサダは他とのやり取りを仲介する役目をになう。

3.1 サービスのシャーディングへの利用
--------------------

そもそもシャーディングとは、ストレージレイヤを複数に分割し、それぞれが別のマシンでホストされるようにする仕組みのことを指す。
アンバサダモジュールは、シャーディングされたどのマシンに命令を振り分けるかを担当してくれる。
元のアプリケーションで振り分けのロジックも組み込んでしまう手もあるが、そこは要件に応じて適宜使い分ける。

3.2 サービスブローカとしての利用
------------------

ポータブルなアプリケーションは、その環境に応じて接続先のDBなどを探しに行く必要がある。このプロセスのことをサービスディスカバリという。
このサービスディスカバリを何とかしてくれるのがサービスブローカ。
アンバサダモジュールはサービスブローカの役割を担ったりする。

3.3 新システムの実験的運用やリクエスト分割への利用
---------------------------

タイトル通り。

4章 アダプタ
=======

アダプタはアプリケーションのインターフェースを変更するために用いる。


4.1 監視
------------------

アダプタコンテナは、アプリケーションコンテナが公開している監視インターフェースを汎用的な監視システムが利用するインターフェースに変換する。

4.2 ロギング
-----------

アダプタによってログの正規化ができる。

4.3 ヘルスモニタの追加
------

アダプタで対象アプリケーションの死活監視をする。

第Ⅱ部 マルチノードパターン
========

Ⅱ.1 マイクロサービス入門
-----

5章 レプリカがロードバランスされたサービス
=====


5.1 ステートレスなサービス
-----

5.1.1 ロードバランスのためのReadinessProbe

ReadinessProbeはアプリケーションがユーザーからのリクエストに応答する準備が整っているかチェックする。
コンテナの起動が済んでいるだけでなく、DB接続やプラグインのロードがなされていることもチェックする。

5.2 セッションを保存するサービス
-----
ロードバランシングするときに、同じユーザーからの通信を同じサーバーに送るため、送信元、送信先のIPのハッシュを取る。

5.3 アプリケーションレイヤでレプリカを扱うサービス
-----

5.4 キャッシュレイヤの導入
---

キャッシュの導入には、サイドカーパターンを使って、1つのPodにWebキャッシュコンテナとWebサービスコンテナを入れ込むことが一番シンプル。

ただし、そのような構成にするとWebサーバと一緒にキャッシュサーバもスケールするようにせねばならない。

キャッシュには大きなリソースを割り当てつつ、レプリカ数は小さくしたい。
一方、Webサーバーは小規模なものをたくさん用意したい。(ここの理由がいまいち？？)

よって、Webサーバーの一段上のレイヤにキャッシュサーバーを配置すべき。

5.5 キャッシュレイヤの拡張
-------

5.5.1 帯域制限とDoS攻撃に対する防御

DoS対策のために、ユーザーの制限をしたり、キャッシュサーバーでの帯域制限を行うべき。

5.5.2 SSL終端
??

5.5.3 ハンズオン：nginxとSSL終端のデプロイ

5.6 まとめ
---

6章 シャーディングされたサービス
===

レプリカを使ったサービスでは、各レプリカはどのリクエストにも対応できる。
一方シャーディングされたサービスでは、各レプリカ（シャード）はリクエストの一部に対応できる。

レプリカはステートレスなサービスを作るのに用いられ、シャーディングはステートフルなサービスを作るのに用いられる。
データのシャーディングは、保存すべきデータのサイズが1台のマシンで処理するには大きすぎる場合に行われる。

6.1 シャーディングされたキャッシュ
-----

6.1.1 シャーディングされたキャッシュの必要性
キャッシュの場合、同じデータをメモリ上に保有するレプリカを用意しても効率が悪い。
それぞれ別のデータをシャーディングしたほうが効率は良い。

6.1.2 アーキテクチャ内でのキャッシュの役割
キャッシュヒット率はシステムのキャパシティとパフォーマンスに影響する。

例えばリクエストの処理レイヤの前段に50%のキャッシュヒット率のキャッシュを用意すれば、理論上は2倍のRPSをさばけることになる。
（キャッシュの障害を加味して、最大許容RPSは1.5倍位にしとくべき）

また、キャッシュの応答時間は、キャッシュなしの応答に比べて短いので、待ち時間が短くなる。

シャーディングされたキャッシュがアップグレードしたりデプロイされたりすると、一時的に負荷が上がるので注意。

6.1.3 シャーディングされたキャッシュのレプリカ


6.1.4 ハンズオン：アンバサダのデプロイとシャーディングされた memcached

アンバサダとシャードルータのどちらを使うかはトレードオフの関係にある。

* シャードルータを使うと、複雑さは小さくなる。
* 負荷が増えた時にルータをスケールさせる必要がある
* ルータを使う分ネットワークのホップが1つ増え、レイテンシが大きくなる

6.2 シャーディング関数を試してみる
------

シャーディング関数にとって大事なのは、決定性と均一性。つまり、同一のリクエストは必ず同じシャードに送られ、負荷はシャード間で均一であるようにするべきということ。

```
Shard = hash(Req) % N 
```

こんな感じ。

6.2.1 キーの選択

シャーディングされたシステムをただしくデザインするには、シャーディング関数に適切なキーを使用することが重要

6.2.2 コンシステントハッシュ関数

キャッシュの数を増やした場合に、普通のキャッシュ関数だとたくさんのキャッシュミスが起こるが、コンシステントハッシュ関数を使えばreマッピングを少なく抑えらえる


6.2.3 ハンズオン：コンシステントなHTTPシャーディングプロキシの構築

シャーディング関数のキーには、一般的には、リクエストパス、クエリパラメータ、フラグメントが指定されることが多い

6.3 シャーディングされたレプリカを使ったシステム
-------

大規模ゲームなんかでもシャーディングは用いられる。
その場合のシャーディング関数のキーはプレーヤーの地域になったりする。

6.4 ホットシャーディングシステム
--------

理想的にはシャーディングされたキャッシュに対する負荷は均等であるべきだが、何かばずったりして、特定のシャードに負荷が集中することはあり得る。
そのような場合は、負荷が集中しているサーバをスケールする。


7章 スキャッタ・ギャザー
=========

処理時間をスケールさせるためにスキャッタ・ギャザーパターンを使う。

スキャッタ・ギャザーパターンでは、リクエストは全レプリカに分割してゆだねられる。
各レプリカは分割された分を処理して、ルートノードに投げ返す。ルートノードでそれらを統合する。
あるリクエストを扱うのに必要な処理が独立していて、大量にあるときに便利なパターン。

7.1 ルートによる分散とスキャッタ・ギャザー
---------
特定の子ノードのレスポンスが遅い場合は、ルートがゆだねる処理の再分散をできる。

7.1.1 ハンズオン：分散ドキュメント検索




