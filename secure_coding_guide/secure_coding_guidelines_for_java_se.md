# 概要

Oracleから[Secure Coding Guidelines for Java SE](https://www.oracle.com/java/technologies/javase/seccodeguide.html)なる資料が発行されている。

上記資料は、[ Effective Java ](https://www.amazon.co.jp/dp/4621303252)や[ Software Security: Building Security In ](https://www.amazon.co.jp/dp/0321356705)の出版物で扱われた指針にさらにトピックを加えたガイドになっている。

対象読者は全てのJava開発者。  

章構成は、0~3章ではあらゆる種類のソフトウェアに共通して適用できる事項を、4~9章で信頼できないアプリケーションとやりとりするソフトウェアに焦点を当てている。

```
Javaプラットフォームの主な設計上の考慮点の一つは、異なる許可レベルのコードを実行するための制限された環境を提供することです。Javaには、独自のセキュリティ上の課題があります。Javaのセキュリティ・アーキテクチャ[1]は、多くの場合、敵対的なコードや誤動作するコードからユーザやシステムを保護するのに役立ちますが、信頼されたコードで発生する実装バグを防ぐことはできません。このようなバグは、セキュリティ・アーキテクチャが封じ込めるように設計された穴を、意図せずに開けてしまう可能性があります。ひどい場合には、ローカルプログラムが実行されたり、Java セキュリティが無効になったりすることもあります。これらのバグは、マシンやイントラネットから機密データを盗んだり、システムリソースを悪用したり、マシンの有用な動作を妨げたり、さらなる攻撃を支援したり、その他多くの悪意ある活動に利用される可能性があります。
言語システムの選択は，あらゆるソフトウェアプログラムの堅牢性に影響を与える．Java言語[2]と仮想マシン[3]は，よくあるプログラミング上のミスを軽減するための多くの機能を備えています．Java言語は型安全であり，ランタイムは自動的にメモリを管理し，配列の境界チェックを行います．また，Javaプログラムやライブラリは，不正な状態を早期にチェックします．これらの機能により，Javaプログラムは，C言語やC++で可能なスタック・スマッシング[4]やバッファ・オーバーフロー攻撃に対する高い耐性を備えています．Javaの明示的な静的型付けは、コードの理解を容易にし（静的解析を容易にし）、動的なチェックは、予期しない状況が予測可能な動作をもたらすことを保証します。
プログラマーのミスに起因するセキュリティ脆弱性の可能性を最小限に抑えるために、Javaの開発者は推奨されるコーディング・ガイドラインを遵守する必要があります。Effective Java」[6]などの既存の出版物には、Java ソフトウェアの設計に関する優れたガイドラインが記載されています。また、『Software Security: Building Security In [7]など、ソフトウェア・セキュリティの指針となる原則を示しています。本文書は、このような出版物をまとめたものであり、追加のトピックも含まれています。この文書は、Javaプログラミング言語を対象とした、セキュリティに特化したコーディングガイドラインのより完全なセットを提供します。これらのガイドラインは、信頼できるエンドユーザ・アプリケーションを作成する人、セキュリティ・コンポーネントの内部を実装する人、一般的なプログラミング・タスクを実行する共有Javaクラス・ライブラリを開発する人など、すべてのJava開発者にとって興味深いものです。実装上のバグは、深刻なセキュリティ上の影響を及ぼす可能性があり、ソフトウェアスタックのどの層にも現れる可能性があります。
第0章から第3章まではさまざまな種類のソフトウエアに共通して適用できるが、第4章から第9章までのガイドラインのほとんどは、信頼できないコードとやりとりするアプリケーションに焦点を当てている（ただし、これらの章のガイドラインの中には、他の状況にも当てはまるものがある）。開発者は、アプリケーションの信頼境界を越えて発生する相互作用を分析し、関係するデータの種類を特定して、どのガイドラインが適切であるかを判断する必要があります。脅威のモデル化を行い、信頼境界を確立することは、この目的を達成するのに役立ちます（ガイドライン0-4を参照）。
本ガイドラインは、開発者が安全なソフトウェアを構築することを目的としていますが、セキュリティ機能を実装するソフトウェアに特化したものではありません。そのため、暗号技術などのトピックは本書では取り上げていません（Javaでの暗号技術の使用については[9]および[10]を参照してください）。ソフトウェアに機能を追加することで、セキュリティ関連の問題を解決できる場合もありますが、セキュリティ上の欠陥をなくすことを目的としたものではありません。
この文書は、Java SE の新しいバージョンで導入された機能をカバーするため、また、すべての Java SE バージョンに適用されるベストプラクティスをよりよく説明するために、定期的に更新されます。
```

# 0 Fundamentals

Javaでのセキュリティを考慮するにあたって遵守すべき原則について述べる章。

## Guideline 0-0 / FUNDAMENTALS-0: Prefer to have obviously no flaws rather than no obvious flaws

基本的にはこのガイドラインに従うべしということが記述されている。

```
安全なコードを作成することは必ずしも容易ではありません。Javaは非常に堅牢であるにもかかわらず、欠陥は驚くほど簡単にすり抜けてしまいます。安全であることを確認するために巧妙なロジックを必要としないようなコードを設計・記述してください。具体的には、よほどの理由がない限り、このドキュメントのガイドラインに従ってください。
```

## Guideline 0-1 / FUNDAMENTALS-1: Design APIs to avoid security concerns

APIの設計段階でセキュリティについて考慮しておけということが記述されている。
クラスをfinalにすることや、SecurityManagerの利用について述べられている。*がよく分からない*

```
セキュリティを考慮してAPIを設計する方がよい。既存のAPIにセキュリティを後付けしようとすると、より難しく、エラーが発生しやすくなります。例えば、クラスをfinalにすることで、悪意のあるサブクラスがfinalizerを追加したり、クローンを作ったり、ランダムなメソッドをオーバーライドしたりすることを防ぐことができます（ガイドライン4-5）。また、SecurityManagerを使用する際には、精査すべき点があります。
```

## Guideline 0-2 / FUNDAMENTALS-2: Avoid duplication

コード、データの重複を避けよ。

```
コードやデータの複製は多くの問題を引き起こす。コードもデータも、重複すると一貫して扱われない傾向があります。例えば、変更がすべてのコピーに適用されないことがあります。
```

## Guideline 0-3 / FUNDAMENTALS-3: Restrict privileges

コードに与える権限を最小限にしておけ。
SecurityManagerを利用して、コードに与える権限を制御することができる。

```
最善の努力をしても、十分にレビューされたコードであっても、すべてのコーディング上の欠陥が排除されるわけではありません。しかし、コードが軽減された権限で動作していれば、欠陥の悪用は阻止される可能性が高いのです。この最も極端な方法は、最小特権の原則として知られています。Javaのセキュリティメカニズムを使用すると、ポリシーファイルによる静的な権限制限や、java.security.AccessController.doPrivilegedメカニズムを使用した動的な権限制限を行うことができます（セクション9参照）。この方法をとる場合、セキュリティマネージャはできるだけ早く（理想的にはコマンドラインから）インストールする必要があることに注意してください。インストールが遅れると、セキュリティマネージャが導入される前に、セキュリティ上重要な操作が実行されてしまい、セキュリティチェックの効果が低下したり、過剰なパーミッションでオブジェクトが作成されたりする可能性があります。
リッチ・インターネット・アプリケーション（RIA）は、アプレットのパラメータやJNLP1で要求されるパーミッションを指定することができます。署名されたJARは、サンドボックスで実行しなければならないか、すべての権限で実行しなければならないかを指定するマニフェスト属性を含むこともできます（[11]参照）。サンドボックス化されたアプレットやアプリケーションがセキュリティ上問題のあるコードを実行しようとすると、JREはセキュリティ例外を発生させます。RIA は最小特権の原則に従うべきで、必要最小限のパーミッションで実行するように構成されるべきです。すべてのパーミッションでRIAを実行することは、可能な限り避けるべきです。
```

## Guideline 0-4 / FUNDAMENTALS-4: Establish trust boundaries

信頼の境界を確立せよ。
ブラウザとwebサーバーは互いにセキュリティ的に依存してはならない。

```
システムを確実に保護するためには、信頼の境界を確立する必要があります。この境界を越えたデータは、使用前にサニタイズし、検証する必要があります。また、セキュリティ監査を効率的に実施するためにも、信頼境界が必要です。信頼境界の完全性を保証するコードは、それ自体の完全性が保証されるようにロードされなければなりません。
例えば、WebブラウザはWebサーバのシステムの外にあります。同様に、WebサーバはWebブラウザのシステムの外にあります。したがって、Webブラウザとサーバソフトウェアは、セキュリティのために相手の動作に依存してはいけません。
信頼の境界を監査する際には、いくつかの質問を念頭に置いておく必要があります。使用されているコードやデータは十分に信頼できるものか？ライブラリが悪意のある実装に置き換えられていないか？信頼されていない設定データが使用されていないか？低い権限で呼び出されるコードは十分に保護されているか？
```

## Guideline 0-5 / FUNDAMENTALS-5: Minimise the number of permission checks

*どういうことだ。。9章を見たらわかる？*

```
Javaは主にオブジェクト機能を持つ言語です。SecurityManagerのチェックは、最後の手段と考えるべきです。いくつかの定義されたポイントでセキュリティチェックを行い、クライアントコードが保持するオブジェクト（ケイパビリティ）を返すことで、それ以上のパーミッションチェックは必要ありません。ただし、適切なパーミッションを持たないコードにケイパビリティが漏れないように、チェックを実行するコードと呼び出し元の両方が注意を払わなければならないことに注意してください。詳細はセクション9を参照してください。
```

## Guideline 0-6 / FUNDAMENTALS-6: Encapsulate

可視性の設計をちゃんとしよう。

```
ビヘイビアを割り当て、簡潔なインターフェイスを提供する。オブジェクトのフィールドはプライベートにし、アクセサは避けるべきである。メソッド、クラス、パッケージ、モジュールのインターフェイスは、一貫したビヘイビアのセットを形成すべきであり、それ以上のものであってはならない。
```

## Guideline 0-7 / FUNDAMENTALS-7: Document security-related information

セキュリティに関連するドキュメントをJavadocなどにちゃんと残せ。

```
APIドキュメントは、必要なパーミッション、セキュリティ関連の例外、呼び出し側の感度（このトピックに関する追加情報は、ガイドライン9-8から9-11を参照）、セキュリティに関連する前提条件や後条件などのセキュリティ関連情報をカバーする必要があります。これらの情報をJavadocのようなツールのコメントで文書化することは、最新の情報を確保するのにも役立ちます。
```

## Guideline 0-8 / FUNDAMENTALS-8: Secure third-party code

サードパーティーのソフトウェアの脆弱性に気をつけよ。
パッチアップデートをちゃんとしたり、そのソフトウェアのセキュリティに関するベストプラクティスに従うこと。

```
ライブラリ、フレームワーク、その他のサードパーティ製ソフトウェアは、特に最新の状態に保たれていない場合、
セキュリティ上の脆弱性や弱点をもたらす可能性があります。筆者が公開したセキュリティアップデートは、
バンドルされているアプリケーションや依存するライブラリ、OSのパッケージ管理の更新に到達するまでに時間がかかる場合があります。
したがって、使用しているサードパーティ製コードのセキュリティアップデートを把握し、
タイムリーにアップデートが適用されるようにすることが重要です。
これには、アプリケーションで使用されているフレームワークやライブラリ、およびそれらのライブラリやフレームワークの依存関係も含まれます。
依存性チェックツールは、これらのタスクを実行するために必要な労力を軽減するのに役立ち、
通常、開発とリリースのプロセスに組み込むことができます。

サードパーティ製ソフトウェアのセキュリティモデルとベストプラクティスを理解することも重要である。
安全な設定オプション、コードが実行するセキュリ ティ関連のタスク（暗号関数やシリアライズなど）、
使用する API のセキュリティに関する考慮事項などを確認する。
コードに対する過去のセキュリティ問題や攻撃パターンを理解することも、より安全な方法でコードを使用するのに役立ちます。
例えば、過去のセキュリティ問題が特定の機能や構成に適用されていた場合、それらを回避することで暴露を最小限に抑えることができます。

また、サードパーティ製コードのセキュリティ対策についても、定期的に見直す必要があります。
セキュリティアップデートがリリースされるたびに適用するだけでなく、
より安全なAPIや設定オプションを時間をかけて利用できるようにすることもできます。
```

# 1 Denial of Service

DoS攻撃への対応

## Guideline 1-1 / DOS-1: Beware of activities that may use disproportionate resources

DoS系攻撃の具体例。*こんなのがあるんだって感じでためになる。*

```
攻撃の例としては以下のようなものがあります。

- ベクターグラフィックスで大きな画像サイズを要求する。例えば、SVGやフォントファイルなどです。
- 整数オーバーフローのエラーにより、サイズのサニティチェックが失敗することがある。
- テキストやバイナリストリームを解析して構築されたオブジェクトグラフは、元のデータの何倍ものメモリを必要とする場合があります。
- 短いファイルを非常に高度に圧縮する "Zip bomb"。例えば、ZIPやGIF、gzipでエンコードされたHTTPコンテンツなどがこれにあたります。ファイルを解凍する際には、圧縮されたサイズやメタデータに頼るのではなく、解凍されるデータのサイズに制限を設けた方が良いでしょう。
- 「Billion laughs attack (10億笑い攻撃) XMLエンティティの拡張により、解析時にXML文書が急激に大きくなること。XMLConstants.FEATURE_SECURE_PROCESSING機能を設定して、合理的な制限をかけてください。
- ハッシュテーブルに同じハッシュコードで多数のキーを挿入すると、O(n)程度のアルゴリズムがO(n^2)になります。
- 正規表現が壊滅的なバックトラックを起こす可能性がある。
- XPath式は、任意のプロセッサ時間を消費する可能性があります。
- Java デシリアライゼーションと Java Beans 悪意のあるデータの XML デシリアライゼーションでは、メモリや CPU の使用量が制限されることがあります。
- 異常な動作を詳細に記録すると、ログファイルに過剰な出力が行われることがあります。
- コーナーケースのデータを解析すると、無限ループが発生することがあります。ループの各反復処理が確実に進行するようにしてください。
- 信頼できないソースからの JAR を処理すると、リソースの枯渇やランタイムの予期せぬ動作につながる可能性があります。
```

## Guideline 1-2 / DOS-2: Release resources in all cases

リソースの開放もれをするな。
防ぐためには[ Execute Around Method ](https://java-design-patterns.com/patterns/execute-around/)パターンを使ったりする。
このパターンは、ある関数の前後に必ず挟みたいロジックを入れる場合に利用するものと理解。

```
オープンファイルやロック、手動で割り当てられたメモリなど、一部のオブジェクトはリソースとして動作するため、
アクイジション操作のたびに明確なリリースが必要になります。例外が発生すると、実行経路に大きな可能性があることを見落としがちになります。
リソースは何があっても速やかに解放しなければなりません。

経験豊富なプログラマであっても、リソースの扱いを誤ることがあります。誤りを減らすためには、重複を最小限に抑え、
リソースの取り扱いに関する問題を分離する必要があります。Execute Around Methodパターンは、
アクイジションとリリースの操作をペアで抽出する優れた方法を提供します。
このパターンは、Java SE 8のラムダ機能を使って簡潔に使うことができます。
```

try-with-resourceとかも有用。

tryの中でリソースにアクセスしに行って、ロックする、みたいなことはできるので、そこは注意すること。


## Guideline 1-3 / DOS-3: Resource limit checks should not suffer from integer overflow

*よく理解できず。後でもうちょい見る。*

```
Java言語では、配列の境界チェックを行うことで、大部分の整数オーバーフロー攻撃を軽減することができます。
しかし，プリミティブな整数型に対する演算の中には，静かにオーバーフローするものがあります．
そのため、リソースの制限をチェックする際には注意が必要です。これはディスクスペースのような永続的なリソースでは特に重要で、
再起動しても問題が解決しないことがあります。
いくつかのチェックはオーバーフローを避けるために再配置することができます。
大きな値の場合、current + max は負の値にオーバーフローする可能性がありますが、これは常に max よりも小さい値になります。
```

```
パフォーマンスに問題がない場合は、任意のサイズの整数を使用することで冗長なアプローチが可能です。
```

```
2の補数による整数演算の特徴は、最小の負の値には、同じ大きさの正の値が一致しないことです。つまり、Integer.MIN_VALUE == -Integer.MIN_VALUE、Integer.MIN_VALUE == Math.abs(Integer.MIN_VALUE)となり、整数aの場合、a < 0では-a > 0を意味しません。
Java SE 8以降、java.lang.Mathクラスには、様々な演算（addExact、multiplyExact、decrementExactなど）のためのメソッドも含まれており、結果が与えられた型をオーバーフローした場合にはArithmeticExceptionがスローされます。
```

## Guideline 1-4 / DOS-4: Implement Robust Error/Exceptions handling for services

エラーをハンドリングせよ。
エラーが伝播して、プロセスごと死ぬことを危惧しているようだ。

通常のアプリ開発だとFWを使うからこのあたりはあまり意識しなくても良さそう。というか、OOMEって出た時点でサービス不能になるのは正しいのではないか？？
Errorsもcatchするのか。。？

```
サービスは、公開されたAPIにクライアントがアクセスするためのループとして設計されることが多く、例えば、公開されたServerSocketに通信することができます。
例外が発生した場合には、通常、文書化された例外がキャッチされ、サービスはそれに応じて応答することができます。
見落としがちなのは、公開されたAPIでは、Exceptionのサブタイプだけでなく、Errorタイプ（OutOfMemoryErrorやArithmeticErrorなど）もスローされることです。
サーバープロセスがこれらをスムーズに処理できないと、Errorが上に伝播してしまいます。
これにより、受信ループがサービスを終了してしまい、サービス不能状態に陥る可能性があります。そのため、catch節にはErrorsも含めることが推奨されています。
```

# 2 Confidential Information

```
機密データは、限られた文脈の中でのみ読めるようにすべきである。
信頼されるべきデータは、改ざんにさらされてはならない。
特権コードは、意図されたインターフェースを介して実行可能であってはならない。
```

## Guideline 2-1 / CONFIDENTIAL-1: Purge sensitive information from exceptions

例外情報で機密情報を漏らさないようにする。
スタックトレースの情報をそのままクライアントに返したり、サードパーティーライブラリの例外情報をそのままクライアントに返したりしないこと。

```
例外オブジェクトは、機密情報を伝える可能性があります。
例えば、メソッドが java.io.FileInputStream コンストラクタを呼び出して基礎となる構成ファイルを読み込もうとし、そのファイルが存在しない場合には、ファイルのパスを含む java.io.FileNotFoundException がスローされます。
この例外をメソッドの呼び出し元に伝えることで、ファイルシステムのレイアウトが公開されます。
多くの攻撃方法では、ファイルの位置を知ったり推測したりする必要があります。

カレントユーザーの名前やホームディレクトリを含むファイルパスが公開されると、問題が悪化します。
標準的なシステムプロパティ（user.homeなど）にこの情報が含まれている場合、SecurityManagerはこの情報の保護をチェックしますが、例外メッセージでこの情報を公開すると、これらのチェックを効果的に回避することができます。

内部例外は、上流の呼び出し元に伝える前にキャッチしてサニタイズすべきです。
例外の種類によっては，メッセージが削除されていても，機密情報が漏えいする可能性があります。
たとえば，FileNotFoundException は，指定されたファイルが存在するかどうかを明らかにする．

また，呼び出し元の入力から得られた情報を含む例外をサニタイズする必要がある場合もある。
例えば，ファイルアクセスに関連する例外は，ファイルが存在するかどうかを明らかにすることができる。
攻撃者は、さまざまなファイル名を入力し、発生した例外を分析することで、有用な情報を収集できる可能性があります。

例外の内容が将来的に変更される可能性があるため、セキュリティに依存する場合は注意が必要です。
例えば、あるライブラリの前のバージョンでは、機密性の高い情報が例外に含まれておらず、既存のクライアントがその例外に依存してセキュリティを確保していたとします。
例えば、ライブラリがメッセージを伴わない例外を投げることがあります。
アプリケーション・プログラマはこの動作を見て、例外を伝搬させても問題ないと判断するかもしれません。
しかし、ライブラリの後続バージョンでは、例外メッセージに追加のデバッグ情報が追加されているかもしれません。
アプリケーション・コード自体は変わっていなくても、アプリケーションはこの追加情報を公開してしまいます。
例外の一部の要素を除外するのではなく、例外から既知の許容できる情報のみを含めるようにしてください。

また、例外には、システムの構成や内部に関する機密情報が含まれていることがあります。
例外情報が何を含んでいるかを正確に知らない限り、エンドユーザーに例外情報を渡さないでください。
たとえば、HTML コメントの中に例外のスタック・トレースを含めてはいけません。 
```

## Guideline 2-2 / CONFIDENTIAL-2: Do not log highly sensitive information

機密情報をログに出すな。

```
社会保障番号（SSN）やパスワードなど、一部の情報は非常に機密性の高いものです。
これらの情報は、必要以上に長く保管したり、管理者であっても見られる可能性のある場所に置いてはいけません。
例えば、ログファイルに送信したり、検索してその存在を知ることができないようにすべきです。
一時的なデータの中には、char配列などの変更可能なデータ構造に保管し、使用後は直ちにクリアするものもあります。
一般的なJavaランタイム・システムでは、オブジェクトがプログラマには透過的にメモリ上を移動するため、データ構造のクリアは効果が減少します。

また、このガイドラインは、扱うデータの意味的な知識を持たない低レベルのライブラリの実装や使用にも影響します。
例えば、低レベルの文字列解析ライブラリは、処理するテキストを記録することがあります。アプリケーションは、このライブラリでSSNを解析することがあります。
これにより、ログファイルにアクセスできる管理者がSSNを入手できる状況になります。
```

## Guideline 2-3 / CONFIDENTIAL-3: Consider purging highly sensitive from memory after use

機密性の高い情報は、使ったらメモリからすぐ消すくらいしたほうがいい。

確かにそうだけど、本当にそんな実装しているところがあるのか？？
てかどうやってやるんだ。。？

このへんか。
https://wiki.sei.cmu.edu/confluence/display/java/MSC59-J.+Limit+the+lifetime+of+sensitive+data

```
機密性の高い情報がコアダンプ、デバッグ、機密性攻撃などに現れる可能性を狭めるためには、ガベージコレクション機構を待つのではなく、データを含むメモリを使用後すぐにゼロにすることが適切な場合があります。

しかし、そうすることには負の影響があります。余分な複雑さや変更可能なデータ構造により、コードの品質が損なわれます。
ライブラリがコピーを作成し、データをメモリに残してしまう可能性があります。仮想マシンやOSの動作によって、データのコピーがメモリやディスクに残ることもあります。
```

## 3 Injection and Inclusion

```
非常に一般的な攻撃方法は、特定のプログラムに細工されたデータを解釈させ、予期しない制御の変更を引き起こすことです。
一般的には、テキストフォーマットが対象となりますが、必ずしもそうとは限りません。
```

---
## 5 Input Validation

バリデーションチェック

```
Javaの文化の特徴として、堅牢性を高めるために厳格なメソッドのパラメータチェックが行われています。
より一般的には、外部からの入力を検証することは、セキュリティの重要な部分です。
```

### Guideline 5-1 / INPUT-1: Validate inputs

入力チェックをちゃんとしないとディレクトリトラバーサルとか起きちゃうよ。

```
信頼できないソースからの入力は、使用前に検証する必要があります。
悪意を持って作られた入力は、メソッドの引数や外部ストリームからの入力に関わらず、問題を引き起こす可能性があります。
例えば、整数値のオーバーフローや、ファイル名に"../"のシーケンスを含めることによるディレクトリトラバーサル攻撃などがあります。
使いやすさを追求した機能は、プログラム的なインターフェースとは別のものにすべきです。

信頼できない入力を処理することは、可能な限り避けるべきです。
例えば、信頼されていないソースからJARファイルを消費すると、攻撃者が悪意のあるコードやデータをシステムに注入し、動作不良やリソースの過剰消費などの問題を引き起こす可能性があります。

入力の検証は、その入力を防御的にコピーした後に行わなければならないことに注意してください（ガイドライン6-2参照）。
```

### Guideline 5-2 / INPUT-2: Validate output from untrusted objects as input

うーん難しい。TOCTOU？
とりあえず、信用できないオブジェクトからのアウトプットはバリデートかけろという感じ。
RESTAPIの戻り値とかならわかるけど、ライブラリのアウトプットとかでそんなことするかしら？
そもそもそんなライブラリ使うなて気がする。

```
一般的に、メソッドの引数は検証されるべきですが、戻り値は検証されません。
しかし、アップコール(上位のコードのメソッドを呼び出すこと)の場合には、 返り値を検証する必要があります。
同様に、アップコールの実装としてのみ到達可能なオブジェクトは、その入力を検証する必要はありません。

微妙な例として、ClassLoadersが返すClassオブジェクトがあります。
攻撃者は、引数として渡される ClassLoader インスタンスや、Thread コンテキストで設定される ClassLoader インスタンスを制御できる可能性があります。
そのため、ClassLoadersのメソッドを呼び出す際には、多くの仮定を立てることはできません。
ClassLoader.loadClass() の複数回の呼び出しは、同じ Class インスタンスまたは定義を返すことが保証されていないため、TOCTOU 問題を引き起こす可能性があります。
```

### Guideline 5-3 / INPUT-3: Define wrappers around native methods

nativeメソッドをpublicに公開してはいけない。
あまりに馴染みがないからよくわからないな。。
nativeメソッドを暑かったことがない。

```
Javaコードは、型、配列の境界、ライブラリの使用状況などをランタイムにチェックされます。
一方、ネイティブコードは、一般的にチェックされません。
純粋なJavaコードは、従来のバッファオーバーフロー攻撃に対して効果的に免疫がありますが、ネイティブメソッドはそうではありません。
ネイティブコードの呼び出し時にこれらの保護を提供するには、ネイティブメソッドをpublicに宣言してはいけません。
代わりにプライベートを宣言し、パブリックなJavaベースのラッパー・メソッドを通して機能を公開します。
ラッパーは、ネイティブ・メソッドを呼び出す前に、必要な入力検証を安全に行うことができます。
```

```java
public final class NativeMethodWrapper {

    // private native method
    private native void nativeOperation(byte[] data, int offset,
                                        int len);

    // wrapper method performs checks
    public void doOperation(byte[] data, int offset, int len) {
        // copy mutable input
        data = data.clone();

        // validate input
        // Note offset+len would be subject to integer overflow.
        // For instance if offset = 1 and len = Integer.MAX_VALUE,
        //   then offset+len == Integer.MIN_VALUE which is lower
        //   than data.length.
        // Further,
        //   loops of the form
        //       for (int i=offset; i<offset+len; ++i) { ... }
        //   would not throw an exception or cause native code to
        //   crash.

        if (offset < 0 || len < 0 || offset > data.length - len) {
              throw new IllegalArgumentException();
        }

        nativeOperation(data, offset, len);
    }
}
```

---

## 6 Mutability

mutability

```
変異可能性は、一見無害に見えますが、意外と様々なセキュリティ問題を引き起こす可能性があります。
このセクションの例では、java.util.Dateを多用していますが、これは変更可能なAPIクラスの一例です。
アプリケーションでは、不変的に設計された新しいJava Date and Time API (java.time.*)を使用するのが望ましいでしょう。
```

### Guideline 6-1 / MUTABLE-1: Prefer immutability for value types

immutableなクラスとするために、
- final class
- フィールドをfinalに

```
クラスを不変にすることで、後続のガイドラインに記載されている可変型オブジェクトに関連する問題がクライアントコードで発生するのを防ぐことができます。
不変クラスはサブクラス化できないようにします。
さらに、コンストラクタを隠すことで、インスタンスの生成やキャッシングをより柔軟に行うことができます。
これは、コンストラクタをプライベートにするか、デフォルトのアクセス（"package-private"）にするか、package.accessセキュリティプロパティによって制御されるパッケージに含まれることを意味します。
不変クラスは、ガイドライン6-2にあるように、フィールドをfinalと宣言し、変更可能な入出力から保護する必要があります。
ガイドライン6-2で述べたように、不変オブジェクトの構築は、ビルダー（Effective Java [6]を参照）を提供することで容易になります。
```

### Guideline 6-2 / MUTABLE-2: Create copies of mutable output values

mutableなオブジェクトを返す場合は、deep copyを返せということか。
これがどうセキュリティに関わるかはわからん。

```
メソッドが内部のミュータブルオブジェクトへの参照を返す場合、クライアントコードがインスタンスの内部状態を変更する可能性があります。
状態を共有する意図がない限り、ミュータブルオブジェクトをコピーし、そのコピーを返します。

信頼できる mutable オブジェクトのコピーを作成するには、コピーコンストラクタまたは clone メソッドを呼び出します。
```

```java
public class CopyOutput {
    private final java.util.Date date;
    ...
    public java.util.Date getDate() {
        return (java.util.Date)date.clone();
    }
}
```

### Guideline 6-3 / MUTABLE-3: Create safe copies of mutable and subclassable input values

ミュータブルな値のコピーを渡すときは気をつける。
また、finalではないクラスをインプットにするときは気をつける。

難しい。。

```
Mutable（変更可能）なオブジェクトは、メソッドやコンストラクタの呼び出し後、あるいは呼び出し中にも変更される可能性があります。
サブクラス化可能な型は、正しくない、矛盾した、または悪意のある動作をする可能性があります。
メソッドが変更可能な入力パラメータを直接操作するように指定されていない場合は、その入力のコピーを作成し、そのコピーに対してメソッドロジックを実行します。
実際、入力がフィールドに格納されている場合、呼び出し元は包含するクラスの競合状態を利用することができます。
たとえば、TOCTOU（time-of-check, time-of-use inconsistency）[7]は、変更可能な入力がSecurityManagerのチェック時には1つの値を含んでいるが、後でその入力が使用されるときには異なる値を含んでいる場合に悪用できます。

信頼できないミュータブルオブジェクトのコピーを作成するには、コピーコンストラクタまたは作成メソッドを呼び出します。
```

```java
public final class CopyMutableInput {
    private final Date date;

    // java.util.Date is mutable
    public CopyMutableInput(Date date) {
        // create copy
        this.date = new Date(date.getTime());
    }
}
```

```
まれに、インスタンス自体のコピー・メソッドを呼び出しても安全な場合があります。
例えば、java.net.HttpCookie は mutable ですが final であり、そのインスタンスのコピーを取得するためのパブリックな clone メソッドが用意されています。
```

```java
public final class CopyCookie {

    // java.net.HttpCookie is mutable
    public void copyMutableInput(HttpCookie cookie) {
        // create copy
        cookie = (HttpCookie)cookie.clone(); // HttpCookie is final

        // perform logic (including relevant security checks)
        // on copy
        doLogic(cookie);
    }
}
```

```
HttpCookie.cloneは悪意のある実装ではオーバーライドできないので、呼び出しても安全です。
Dateもパブリックなcloneメソッドを提供していますが、このメソッドはオーバーライド可能なので、Dateオブジェクトが信頼できるソースからのものである場合にのみ信頼できます。
java.io.Fileなどの一部のクラスは、不変であるように見えてもサブクラス化が可能です。

このガイドラインは、対象となるオブジェクトをラップするように設計されたクラスには適用されません。
例えば、java.util.Arrays.asListは、コピーせずに、与えられた配列を直接操作します。

コレクションなどでは、入力オブジェクトのコピーコンストラクタやクローンメソッドで返されるものよりも深いコピーをメソッドが必要とする場合があります。
たとえば、コレクションで ArrayList をインスタンス化すると、元のコレクション インスタンスの浅いコピーが生成されます。
コピーとオリジナルの両方が、同じ要素への参照を共有します。
要素が変更可能な場合は、その要素に対するディープコピーが必要です。
```

```java
// String is immutable.
public void shallowCopy(Collection<String> strs) {
    strs = new ArrayList<>(strs);
    doLogic(strs);
}
// Date is mutable.
public void deepCopy(Collection<Date> dates) {
    Collection<Date> datesCopy =
                           new ArrayList<>(dates.size());
    for (Date date : dates) {
        datesCopy.add(new java.util.Date(date.getTime()));
    }
    doLogic(datesCopy);
}
```

```
コンストラクタは、フィールドに値を割り当てる前に、ディープコピーを完了させる必要があります。
オブジェクトは、たとえ短時間であっても、信頼できないデータを参照している状態であってはなりません。
さらに、フィールドに割り当てられたオブジェクトは、安全でない公開の危険性があるため、信頼できないデータを参照してはいけません。
```

### Guideline 6-4 / MUTABLE-4: Support copy functionality for a mutable class

イミュータブルなクラスを設計するときは、安全にコピーを作成する手段を提供せよ。

```
変更可能な値のクラスを設計するときは、そのインスタンスの安全なコピーを作成する手段を提供してください。
これにより、そのクラスのインスタンスを他のクラスのメソッドに安全に渡したり返したりすることができます（ガイドライン6-2、ガイドライン6-3参照）。
この機能は、静的な生成メソッド、コピーコンストラクタ、またはパブリックなコピーメソッドの実装（finalクラスの場合）によって提供されます。

もしクラスがfinalで、コピーを取得するためのアクセス可能なメソッドが提供されていない場合、呼び出し側は手動でコピーを行うことができます。
この方法では、そのクラスのインスタンスから状態を取得し、取得した状態で新しいインスタンスを作成します。
このプロセスで取得された Mutable State も、必要に応じてコピーされなければなりません。
このような手動のコピーを行うと、壊れやすくなります。
クラスが進化して追加の状態を含むようになった場合、手動コピーにその状態が含まれない可能性があります。

java.lang.Cloneable のメカニズムは問題があるので、使用すべきではありません。
実装クラスは、すべての変更可能なフィールドを明示的にコピーしなければならず、非常にエラーが発生しやすくなります。
コピーされたフィールドは最終的なものではありません。
フィールドのコピーが完了する前に、クローンオブジェクトが利用可能になる可能性があります。
最終的でないクラスでは、Object.clone は悪意のあるサブクラスの新しいインスタンスを作成します。
Cloneableを実装することは、実装の詳細ですが、クラスのパブリック・インターフェースに表示されます。
```

### Guideline 6-5 / MUTABLE-5: Do not trust identity equality when overridable on input reference objects

finalではないクラスの等価性について、気をつける。
`IdentityHashMap`みたいなのを使えば、参照で比較するようになる。

```
オーバーライド可能なメソッドは、期待通りの動作をしない場合があります。

例えば、同一性保持の動作を期待してObject.equalsをオーバーライドした場合、異なるオブジェクトに対してtrueを返すことがあります。
特にMapのキーとして使用されている場合、あるオブジェクトが、アクセスできないはずの別のオブジェクトとして自分を偽ることができるかもしれません。

可能であれば、IdentityHashMapのような、同一性等価を強制するコレクション実装を使用してください。
```

```java
private final Map<Window,Extra> extras = new IdentityHashMap<>();

public void op(Window window) {
    // Window.equals may be overridden,
    // but safe as we are using IdentityHashMap
    Extra extra = extras.get(window);
}
```

```
そのようなコレクションがない場合は、敵がアクセスできないパッケージの秘密鍵を使用してください。
```

```java
public class Window {
    /* pp */ class PrivateKey {
        // Optionally, refer to real object.
        /* pp */ Window getWindow() {
            return Window.this;
        }
    }
    /* pp */ final PrivateKey privateKey = new PrivateKey();

    private final Map<Window.PrivateKey,Extra> extras =
                                     new WeakHashMap<>();
    ...
}

public class WindowOps {
    public void op(Window window) {
        // Window.equals may be overridden,
        // but safe as we don't use it.
        Extra extra = extras.get(window.privateKey);
        ...
    }
}
```

---

## 7 Object Construction

オブジェクト組み立て中の話？ここはライブラリとか、他から使われることを意図した内容になっている。

```
建設中の物体は、存在していてもすぐには使えない厄介な段階にあります。そのため、通常の方法に加えて、いくつかの困難があります。
```

### Guideline 7-1 / OBJECT-1: Avoid exposing constructors of sensitive classes

センシティブなクラスについては、コンストラクタを晒さないようにする。
(ライブラリ提供者側の話かな？)

```
コンストラクタを公開しなければ、クラスの構築をより慎重に制御することができます。
コンストラクタを公開する代わりに、静的なファクトリメソッドを定義します。継承ではなく委譲による拡張性をサポートします。
シリアライズやクローンによる暗黙のコンストラクタも避けるべきです。
```

### Guideline 7-2 / OBJECT-2: Prevent the unauthorized construction of sensitive classes

```
既存の API がセキュリティセンシティブなコンストラクタを公開している場合、インスタンスの作成を制限する。
セキュリティセンシティブなクラスは、呼び出し側がSecurityManagerのアクセスコントロールを変更または回避することを可能にします。
例えば、ClassLoaderのインスタンスは、任意のセキュリティパーミッションを持つクラスを定義する力を持っています。

信頼されていないコードがクラスをインスタンス化することを制限するために、そのクラスがインスタンス化できるすべてのポイントでSecurityManagerチェックを実施します。
特に、パブリックおよびプロテクトされたコンストラクタの先頭でチェックを行います。
コンストラクタの代わりにパブリック・スタティック・ファクトリ・メソッドを宣言しているクラスでは、各ファクトリ・メソッドの最初にチェックを行います。
また、コンストラクタを使用せずにクラスのインスタンスを作成できる箇所にもチェックを入れます。
具体的には、シリアル化可能なクラスの readObject または readObjectNoData メソッドや、クローン化可能なクラスの clone メソッドの内部でチェックを行います。
```

### Guideline 7-3 / OBJECT-3: Defend against partially initialized instances of non-final classes

ClassLoaderのコンストラクタは、途中でセキュリティチェックとか入っている。  
これでClassLoaderを継承したクラスで悪さをさせないようにしているのかな？

```
ノンファイナルクラスのコンストラクタが例外を投げると、攻撃者はそのクラスの部分的に初期化されたインスタンスへのアクセスを試みることができます。
ノンファイナルクラスは、コンストラクタが正常に完了するまで完全に使用できないようにします。

JDK 6 以降では、Object コンストラクタが完了する前に例外を発生させることで、サブクラス化可能なクラスの構築を防ぐことができます。
そのためには、this()またはsuper()の呼び出しで評価される式でチェックを行います。
```

```java
// non-final java.lang.ClassLoader
public abstract class ClassLoader {
    protected ClassLoader() {
        this(securityManagerCheck());
    }
    private ClassLoader(Void ignored) {
        // ... continue initialization ...
    }
    private static Void securityManagerCheck() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkCreateClassLoader();
        }
        return null;
    }
}
```

```
古いリリースとの互換性のために、初期化されたフラグを使用するという解決策があります。
コンストラクタの最後の処理としてフラグを設定してから正常に戻ります。
機密性の高い操作へのゲートウェイを提供するすべてのメソッドは、処理を進める前にこのフラグを参照する必要があります。
```

```java
public abstract class ClassLoader {

    private volatile boolean initialized;

    protected ClassLoader() {
        // permission needed to create ClassLoader
        securityManagerCheck();
        init();

        // Last action of constructor.
        this.initialized = true;
    }
    protected final Class defineClass(...) {
        checkInitialized();

        // regular logic follows
        ...
    }

    private void checkInitialized() {
        if (!initialized) {
            throw new SecurityException(
                "NonFinal not initialized"
            );
        }
    }
}
```

```
さらに、このようなクラスをセキュリティに配慮して使用する場合は、初期化フラグの状態をチェックする必要があります。
ClassLoaderを構築する場合は、その親クラスローダーが初期化されているかどうかをチェックする必要があります。

非最終的なクラスの部分的に初期化されたインスタンスは、ファイナライザ攻撃によってアクセスすることができます。
攻撃者は、サブクラスの保護された finalize メソッドをオーバーライドし、そのサブクラスの新しいインスタンスを作成しようとします。
この試みは失敗しますが（上記の例では、ClassLoader のコンストラクタにおける SecurityManager のチェックでセキュリティ例外が発生しています）、攻撃者は例外を無視して、仮想マシンが部分的に初期化されたオブジェクトのファイナライズを実行するのを待ちます。
その際、悪意のある finalize メソッドの実装が呼び出され、攻撃者は finalize されるオブジェクトへの参照である this にアクセスできます。
オブジェクトは部分的にしか初期化されていませんが、攻撃者はそのオブジェクトのメソッドを呼び出すことができるため、SecurityManagerのチェックを回避することができます。
初期化フラグは、部分的に初期化されたオブジェクトへのアクセスを妨げるものではありませんが、そのオブジェクトのメソッドが攻撃者にとって有益なことをするのを妨げます。

初期化フラグの使用は、安全ではありますが、面倒なものです。
パブリックな非最終クラスのすべてのフィールドが、オブジェクトの初期化が正常に完了するまで、安全な値（nullなど）を含むようにするだけで、セキュリティに敏感ではないクラスでは合理的な代替手段となります。

より強固な方法として、「実装へのポインタ」（または「pimpl」）を使用する方法があります。
クラスのコアは非公開のクラスに移され、インターフェースクラスがメソッドコールを転送します。
クラスが完全に初期化される前に使用しようとすると、NullPointerExceptionが発生します。
この方法は、クローン攻撃やデシリアライズ攻撃にも有効です。
```

```java
public abstract class ClassLoader {

    private final ClassLoaderImpl impl;

    protected ClassLoader() {
        this.impl = new ClassLoaderImpl();
    }
    protected final Class defineClass(...) {
        return impl.defineClass(...);
    }
}

/* pp */ class ClassLoaderImpl {
    /* pp */ ClassLoaderImpl() {
        // permission needed to create ClassLoader
        securityManagerCheck();
        init();
    }

    /* pp */ Class defineClass(...) {
        // regular logic follows
        ...
    }
}
```

### Guideline 7-4 / OBJECT-4: Prevent constructors from calling methods that can be overridden

オーバーライド可能なメソッドをコンストラクタの中で呼んではならない。

```
オーバーライド可能なメソッドを呼び出すコンストラクタは、オブジェクトが完全に初期化される前に、攻撃者にthis（構築中のオブジェクト）への参照を与えてしまいます。
同様に、オーバーライド可能なメソッドを呼び出す clone、readObject、または readObjectNoData メソッドも同様の可能性があります。
readObjectメソッドは通常、オーバーライド可能なメソッドであるjava.io.ObjectInputStream.defaultReadObjectを呼び出します。
```

### Guideline 7-5 / OBJECT-5: Defend against cloning of non-final classes

うーんむずい。

```
末端ではないクラスは、java.lang.Cloneableを実装したクラスによってサブクラス化されることがあります。
その結果、敵が作成したインスタンスに限りますが、基底クラスが不意にクローン化されることがあります。
クローンは浅いコピーになります。
双子は参照されるオブジェクトを共有しますが、異なるフィールドと別々の固有ロックを持っています。
ガイドライン7-3の "実装へのポインタ "のアプローチは良い防御策となります。
```

## 8 Serialization and Deserialization

信頼できないデータのデシリアライズはしないこと。

```
Java Serializationは、Java言語のフィールド・アクセス・コントロール・メカニズムを回避したクラスへのインターフェースを提供します。そのため、シリアライズとデシリアライズの実行には注意が必要です。
さらに、信頼できないデータのデシリアライズは可能な限り避けるべきであり、避けられない場合は慎重に実行する必要があります（詳細は8-6を参照）。

このセクションでは、Javaで実行されるシリアル化とデシリアル化について説明します。
これらのガイドラインの一部は、サードパーティのライブラリが提供する他のシリアライズ機能にも関連していますが、ドキュメントを参照し、サードパーティのコードに固有のベストプラクティスを利用することも重要です。
サードパーティ・コードのセキュリティに関する注意点については、ガイドライン0-8を参照してください。
```
