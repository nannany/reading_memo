# 概要

Oracleから[Secure Coding Guidelines for Java SE](https://www.oracle.com/java/technologies/javase/seccodeguide.html)なる資料が発行されている。

上記資料は、[ Effective Java ](https://www.amazon.co.jp/dp/4621303252)や[ Software Security: Building Security In ](https://www.amazon.co.jp/dp/0321356705)の出版物で扱われた指針にさらにトピックを加えたガイドになっている。

対象読者は全てのJava開発者。  

章構成は、0~3章ではあらゆる種類のソフトウェアに共通して適用できる事項を、4~9章で信頼できないアプリケーションとやりとりするソフトウェアに焦点を当てている。

```
Javaプラットフォームの主な設計上の考慮点の一つは、異なる許可レベルのコードを実行するための制限された環境を提供することです。Javaには、独自のセキュリティ上の課題があります。Javaのセキュリティ・アーキテクチャ[1]は、多くの場合、敵対的なコードや誤動作するコードからユーザやシステムを保護するのに役立ちますが、信頼されたコードで発生する実装バグを防ぐことはできません。このようなバグは、セキュリティ・アーキテクチャが封じ込めるように設計された穴を、意図せずに開けてしまう可能性があります。ひどい場合には、ローカルプログラムが実行されたり、Java セキュリティが無効になったりすることもあります。これらのバグは、マシンやイントラネットから機密データを盗んだり、システムリソースを悪用したり、マシンの有用な動作を妨げたり、さらなる攻撃を支援したり、その他多くの悪意ある活動に利用される可能性があります。
言語システムの選択は，あらゆるソフトウェアプログラムの堅牢性に影響を与える．Java言語[2]と仮想マシン[3]は，よくあるプログラミング上のミスを軽減するための多くの機能を備えています．Java言語は型安全であり，ランタイムは自動的にメモリを管理し，配列の境界チェックを行います．また，Javaプログラムやライブラリは，不正な状態を早期にチェックします．これらの機能により，Javaプログラムは，C言語やC++で可能なスタック・スマッシング[4]やバッファ・オーバーフロー攻撃に対する高い耐性を備えています．Javaの明示的な静的型付けは、コードの理解を容易にし（静的解析を容易にし）、動的なチェックは、予期しない状況が予測可能な動作をもたらすことを保証します。
プログラマーのミスに起因するセキュリティ脆弱性の可能性を最小限に抑えるために、Javaの開発者は推奨されるコーディング・ガイドラインを遵守する必要があります。Effective Java」[6]などの既存の出版物には、Java ソフトウェアの設計に関する優れたガイドラインが記載されています。また、『Software Security: Building Security In [7]など、ソフトウェア・セキュリティの指針となる原則を示しています。本文書は、このような出版物をまとめたものであり、追加のトピックも含まれています。この文書は、Javaプログラミング言語を対象とした、セキュリティに特化したコーディングガイドラインのより完全なセットを提供します。これらのガイドラインは、信頼できるエンドユーザ・アプリケーションを作成する人、セキュリティ・コンポーネントの内部を実装する人、一般的なプログラミング・タスクを実行する共有Javaクラス・ライブラリを開発する人など、すべてのJava開発者にとって興味深いものです。実装上のバグは、深刻なセキュリティ上の影響を及ぼす可能性があり、ソフトウェアスタックのどの層にも現れる可能性があります。
第0章から第3章まではさまざまな種類のソフトウエアに共通して適用できるが、第4章から第9章までのガイドラインのほとんどは、信頼できないコードとやりとりするアプリケーションに焦点を当てている（ただし、これらの章のガイドラインの中には、他の状況にも当てはまるものがある）。開発者は、アプリケーションの信頼境界を越えて発生する相互作用を分析し、関係するデータの種類を特定して、どのガイドラインが適切であるかを判断する必要があります。脅威のモデル化を行い、信頼境界を確立することは、この目的を達成するのに役立ちます（ガイドライン0-4を参照）。
本ガイドラインは、開発者が安全なソフトウェアを構築することを目的としていますが、セキュリティ機能を実装するソフトウェアに特化したものではありません。そのため、暗号技術などのトピックは本書では取り上げていません（Javaでの暗号技術の使用については[9]および[10]を参照してください）。ソフトウェアに機能を追加することで、セキュリティ関連の問題を解決できる場合もありますが、セキュリティ上の欠陥をなくすことを目的としたものではありません。
この文書は、Java SE の新しいバージョンで導入された機能をカバーするため、また、すべての Java SE バージョンに適用されるベストプラクティスをよりよく説明するために、定期的に更新されます。
```

# 0 Fundamentals

Javaでのセキュリティを考慮するにあたって遵守すべき原則について述べる章。

## Guideline 0-0 / FUNDAMENTALS-0: Prefer to have obviously no flaws rather than no obvious flaws

基本的にはこのガイドラインに従うべしということが記述されている。

```
安全なコードを作成することは必ずしも容易ではありません。Javaは非常に堅牢であるにもかかわらず、欠陥は驚くほど簡単にすり抜けてしまいます。安全であることを確認するために巧妙なロジックを必要としないようなコードを設計・記述してください。具体的には、よほどの理由がない限り、このドキュメントのガイドラインに従ってください。
```

## Guideline 0-1 / FUNDAMENTALS-1: Design APIs to avoid security concerns

APIの設計段階でセキュリティについて考慮しておけということが記述されている。
クラスをfinalにすることや、SecurityManagerの利用について述べられている。*がよく分からない*

```
セキュリティを考慮してAPIを設計する方がよい。既存のAPIにセキュリティを後付けしようとすると、より難しく、エラーが発生しやすくなります。例えば、クラスをfinalにすることで、悪意のあるサブクラスがfinalizerを追加したり、クローンを作ったり、ランダムなメソッドをオーバーライドしたりすることを防ぐことができます（ガイドライン4-5）。また、SecurityManagerを使用する際には、精査すべき点があります。
```

## Guideline 0-2 / FUNDAMENTALS-2: Avoid duplication

コード、データの重複を避けよ。

```
コードやデータの複製は多くの問題を引き起こす。コードもデータも、重複すると一貫して扱われない傾向があります。例えば、変更がすべてのコピーに適用されないことがあります。
```

## Guideline 0-3 / FUNDAMENTALS-3: Restrict privileges

コードに与える権限を最小限にしておけ。
SecurityManagerを利用して、コードに与える権限を制御することができる。

```
最善の努力をしても、十分にレビューされたコードであっても、すべてのコーディング上の欠陥が排除されるわけではありません。しかし、コードが軽減された権限で動作していれば、欠陥の悪用は阻止される可能性が高いのです。この最も極端な方法は、最小特権の原則として知られています。Javaのセキュリティメカニズムを使用すると、ポリシーファイルによる静的な権限制限や、java.security.AccessController.doPrivilegedメカニズムを使用した動的な権限制限を行うことができます（セクション9参照）。この方法をとる場合、セキュリティマネージャはできるだけ早く（理想的にはコマンドラインから）インストールする必要があることに注意してください。インストールが遅れると、セキュリティマネージャが導入される前に、セキュリティ上重要な操作が実行されてしまい、セキュリティチェックの効果が低下したり、過剰なパーミッションでオブジェクトが作成されたりする可能性があります。
リッチ・インターネット・アプリケーション（RIA）は、アプレットのパラメータやJNLP1で要求されるパーミッションを指定することができます。署名されたJARは、サンドボックスで実行しなければならないか、すべての権限で実行しなければならないかを指定するマニフェスト属性を含むこともできます（[11]参照）。サンドボックス化されたアプレットやアプリケーションがセキュリティ上問題のあるコードを実行しようとすると、JREはセキュリティ例外を発生させます。RIA は最小特権の原則に従うべきで、必要最小限のパーミッションで実行するように構成されるべきです。すべてのパーミッションでRIAを実行することは、可能な限り避けるべきです。
```

## Guideline 0-4 / FUNDAMENTALS-4: Establish trust boundaries

信頼の境界を確立せよ。
ブラウザとwebサーバーは互いにセキュリティ的に依存してはならない。

```
システムを確実に保護するためには、信頼の境界を確立する必要があります。この境界を越えたデータは、使用前にサニタイズし、検証する必要があります。また、セキュリティ監査を効率的に実施するためにも、信頼境界が必要です。信頼境界の完全性を保証するコードは、それ自体の完全性が保証されるようにロードされなければなりません。
例えば、WebブラウザはWebサーバのシステムの外にあります。同様に、WebサーバはWebブラウザのシステムの外にあります。したがって、Webブラウザとサーバソフトウェアは、セキュリティのために相手の動作に依存してはいけません。
信頼の境界を監査する際には、いくつかの質問を念頭に置いておく必要があります。使用されているコードやデータは十分に信頼できるものか？ライブラリが悪意のある実装に置き換えられていないか？信頼されていない設定データが使用されていないか？低い権限で呼び出されるコードは十分に保護されているか？
```

## Guideline 0-5 / FUNDAMENTALS-5: Minimise the number of permission checks

*どういうことだ。。9章を見たらわかる？*

```
Javaは主にオブジェクト機能を持つ言語です。SecurityManagerのチェックは、最後の手段と考えるべきです。いくつかの定義されたポイントでセキュリティチェックを行い、クライアントコードが保持するオブジェクト（ケイパビリティ）を返すことで、それ以上のパーミッションチェックは必要ありません。ただし、適切なパーミッションを持たないコードにケイパビリティが漏れないように、チェックを実行するコードと呼び出し元の両方が注意を払わなければならないことに注意してください。詳細はセクション9を参照してください。
```

## Guideline 0-6 / FUNDAMENTALS-6: Encapsulate

可視性の設計をちゃんとしよう。

```
ビヘイビアを割り当て、簡潔なインターフェイスを提供する。オブジェクトのフィールドはプライベートにし、アクセサは避けるべきである。メソッド、クラス、パッケージ、モジュールのインターフェイスは、一貫したビヘイビアのセットを形成すべきであり、それ以上のものであってはならない。
```

## Guideline 0-7 / FUNDAMENTALS-7: Document security-related information

セキュリティに関連するドキュメントをJavadocなどにちゃんと残せ。

```
APIドキュメントは、必要なパーミッション、セキュリティ関連の例外、呼び出し側の感度（このトピックに関する追加情報は、ガイドライン9-8から9-11を参照）、セキュリティに関連する前提条件や後条件などのセキュリティ関連情報をカバーする必要があります。これらの情報をJavadocのようなツールのコメントで文書化することは、最新の情報を確保するのにも役立ちます。
```

## Guideline 0-8 / FUNDAMENTALS-8: Secure third-party code

サードパーティーのソフトウェアの脆弱性に気をつけよ。
パッチアップデートをちゃんとしたり、そのソフトウェアのセキュリティに関するベストプラクティスに従うこと。

```
ライブラリ、フレームワーク、その他のサードパーティ製ソフトウェアは、特に最新の状態に保たれていない場合、
セキュリティ上の脆弱性や弱点をもたらす可能性があります。筆者が公開したセキュリティアップデートは、
バンドルされているアプリケーションや依存するライブラリ、OSのパッケージ管理の更新に到達するまでに時間がかかる場合があります。
したがって、使用しているサードパーティ製コードのセキュリティアップデートを把握し、
タイムリーにアップデートが適用されるようにすることが重要です。
これには、アプリケーションで使用されているフレームワークやライブラリ、およびそれらのライブラリやフレームワークの依存関係も含まれます。
依存性チェックツールは、これらのタスクを実行するために必要な労力を軽減するのに役立ち、
通常、開発とリリースのプロセスに組み込むことができます。

サードパーティ製ソフトウェアのセキュリティモデルとベストプラクティスを理解することも重要である。
安全な設定オプション、コードが実行するセキュリ ティ関連のタスク（暗号関数やシリアライズなど）、
使用する API のセキュリティに関する考慮事項などを確認する。
コードに対する過去のセキュリティ問題や攻撃パターンを理解することも、より安全な方法でコードを使用するのに役立ちます。
例えば、過去のセキュリティ問題が特定の機能や構成に適用されていた場合、それらを回避することで暴露を最小限に抑えることができます。

また、サードパーティ製コードのセキュリティ対策についても、定期的に見直す必要があります。
セキュリティアップデートがリリースされるたびに適用するだけでなく、
より安全なAPIや設定オプションを時間をかけて利用できるようにすることもできます。
```

# 1 Denial of Service

DoS攻撃への対応

## Guideline 1-1 / DOS-1: Beware of activities that may use disproportionate resources

DoS系攻撃の具体例。*こんなのがあるんだって感じでためになる。*

```
攻撃の例としては以下のようなものがあります。

- ベクターグラフィックスで大きな画像サイズを要求する。例えば、SVGやフォントファイルなどです。
- 整数オーバーフローのエラーにより、サイズのサニティチェックが失敗することがある。
- テキストやバイナリストリームを解析して構築されたオブジェクトグラフは、元のデータの何倍ものメモリを必要とする場合があります。
- 短いファイルを非常に高度に圧縮する "Zip bomb"。例えば、ZIPやGIF、gzipでエンコードされたHTTPコンテンツなどがこれにあたります。ファイルを解凍する際には、圧縮されたサイズやメタデータに頼るのではなく、解凍されるデータのサイズに制限を設けた方が良いでしょう。
- 「Billion laughs attack (10億笑い攻撃) XMLエンティティの拡張により、解析時にXML文書が急激に大きくなること。XMLConstants.FEATURE_SECURE_PROCESSING機能を設定して、合理的な制限をかけてください。
- ハッシュテーブルに同じハッシュコードで多数のキーを挿入すると、O(n)程度のアルゴリズムがO(n^2)になります。
- 正規表現が壊滅的なバックトラックを起こす可能性がある。
- XPath式は、任意のプロセッサ時間を消費する可能性があります。
- Java デシリアライゼーションと Java Beans 悪意のあるデータの XML デシリアライゼーションでは、メモリや CPU の使用量が制限されることがあります。
- 異常な動作を詳細に記録すると、ログファイルに過剰な出力が行われることがあります。
- コーナーケースのデータを解析すると、無限ループが発生することがあります。ループの各反復処理が確実に進行するようにしてください。
- 信頼できないソースからの JAR を処理すると、リソースの枯渇やランタイムの予期せぬ動作につながる可能性があります。
```

## Guideline 1-2 / DOS-2: Release resources in all cases

リソースの開放もれをするな。
防ぐためには[ Execute Around Method ](https://java-design-patterns.com/patterns/execute-around/)パターンを使ったりする。
このパターンは、ある関数の前後に必ず挟みたいロジックを入れる場合に利用するものと理解。

```
オープンファイルやロック、手動で割り当てられたメモリなど、一部のオブジェクトはリソースとして動作するため、
アクイジション操作のたびに明確なリリースが必要になります。例外が発生すると、実行経路に大きな可能性があることを見落としがちになります。
リソースは何があっても速やかに解放しなければなりません。

経験豊富なプログラマであっても、リソースの扱いを誤ることがあります。誤りを減らすためには、重複を最小限に抑え、
リソースの取り扱いに関する問題を分離する必要があります。Execute Around Methodパターンは、
アクイジションとリリースの操作をペアで抽出する優れた方法を提供します。
このパターンは、Java SE 8のラムダ機能を使って簡潔に使うことができます。
```

try-with-resourceとかも有用。

tryの中でリソースにアクセスしに行って、ロックする、みたいなことはできるので、そこは注意すること。


## Guideline 1-3 / DOS-3: Resource limit checks should not suffer from integer overflow

*よく理解できず。後でもうちょい見る。*

```
Java言語では、配列の境界チェックを行うことで、大部分の整数オーバーフロー攻撃を軽減することができます。
しかし，プリミティブな整数型に対する演算の中には，静かにオーバーフローするものがあります．
そのため、リソースの制限をチェックする際には注意が必要です。これはディスクスペースのような永続的なリソースでは特に重要で、
再起動しても問題が解決しないことがあります。
いくつかのチェックはオーバーフローを避けるために再配置することができます。
大きな値の場合、current + max は負の値にオーバーフローする可能性がありますが、これは常に max よりも小さい値になります。
```

```
パフォーマンスに問題がない場合は、任意のサイズの整数を使用することで冗長なアプローチが可能です。
```

```
2の補数による整数演算の特徴は、最小の負の値には、同じ大きさの正の値が一致しないことです。つまり、Integer.MIN_VALUE == -Integer.MIN_VALUE、Integer.MIN_VALUE == Math.abs(Integer.MIN_VALUE)となり、整数aの場合、a < 0では-a > 0を意味しません。
Java SE 8以降、java.lang.Mathクラスには、様々な演算（addExact、multiplyExact、decrementExactなど）のためのメソッドも含まれており、結果が与えられた型をオーバーフローした場合にはArithmeticExceptionがスローされます。
```

## Guideline 1-4 / DOS-4: Implement Robust Error/Exceptions handling for services

エラーをハンドリングせよ。
エラーが伝播して、プロセスごと死ぬことを危惧しているようだ。

通常のアプリ開発だとFWを使うからこのあたりはあまり意識しなくても良さそう。というか、OOMEって出た時点でサービス不能になるのは正しいのではないか？？
Errorsもcatchするのか。。？

```
サービスは、公開されたAPIにクライアントがアクセスするためのループとして設計されることが多く、例えば、公開されたServerSocketに通信することができます。
例外が発生した場合には、通常、文書化された例外がキャッチされ、サービスはそれに応じて応答することができます。
見落としがちなのは、公開されたAPIでは、Exceptionのサブタイプだけでなく、Errorタイプ（OutOfMemoryErrorやArithmeticErrorなど）もスローされることです。
サーバープロセスがこれらをスムーズに処理できないと、Errorが上に伝播してしまいます。
これにより、受信ループがサービスを終了してしまい、サービス不能状態に陥る可能性があります。そのため、catch節にはErrorsも含めることが推奨されています。
```

# 2 Confidential Information

```
機密データは、限られた文脈の中でのみ読めるようにすべきである。
信頼されるべきデータは、改ざんにさらされてはならない。
特権コードは、意図されたインターフェースを介して実行可能であってはならない。
```

## Guideline 2-1 / CONFIDENTIAL-1: Purge sensitive information from exceptions

例外情報で機密情報を漏らさないようにする。
スタックトレースの情報をそのままクライアントに返したり、サードパーティーライブラリの例外情報をそのままクライアントに返したりしないこと。

```
例外オブジェクトは、機密情報を伝える可能性があります。
例えば、メソッドが java.io.FileInputStream コンストラクタを呼び出して基礎となる構成ファイルを読み込もうとし、そのファイルが存在しない場合には、ファイルのパスを含む java.io.FileNotFoundException がスローされます。
この例外をメソッドの呼び出し元に伝えることで、ファイルシステムのレイアウトが公開されます。
多くの攻撃方法では、ファイルの位置を知ったり推測したりする必要があります。

カレントユーザーの名前やホームディレクトリを含むファイルパスが公開されると、問題が悪化します。
標準的なシステムプロパティ（user.homeなど）にこの情報が含まれている場合、SecurityManagerはこの情報の保護をチェックしますが、例外メッセージでこの情報を公開すると、これらのチェックを効果的に回避することができます。

内部例外は、上流の呼び出し元に伝える前にキャッチしてサニタイズすべきです。
例外の種類によっては，メッセージが削除されていても，機密情報が漏えいする可能性があります。
たとえば，FileNotFoundException は，指定されたファイルが存在するかどうかを明らかにする．

また，呼び出し元の入力から得られた情報を含む例外をサニタイズする必要がある場合もある。
例えば，ファイルアクセスに関連する例外は，ファイルが存在するかどうかを明らかにすることができる。
攻撃者は、さまざまなファイル名を入力し、発生した例外を分析することで、有用な情報を収集できる可能性があります。

例外の内容が将来的に変更される可能性があるため、セキュリティに依存する場合は注意が必要です。
例えば、あるライブラリの前のバージョンでは、機密性の高い情報が例外に含まれておらず、既存のクライアントがその例外に依存してセキュリティを確保していたとします。
例えば、ライブラリがメッセージを伴わない例外を投げることがあります。
アプリケーション・プログラマはこの動作を見て、例外を伝搬させても問題ないと判断するかもしれません。
しかし、ライブラリの後続バージョンでは、例外メッセージに追加のデバッグ情報が追加されているかもしれません。
アプリケーション・コード自体は変わっていなくても、アプリケーションはこの追加情報を公開してしまいます。
例外の一部の要素を除外するのではなく、例外から既知の許容できる情報のみを含めるようにしてください。

また、例外には、システムの構成や内部に関する機密情報が含まれていることがあります。
例外情報が何を含んでいるかを正確に知らない限り、エンドユーザーに例外情報を渡さないでください。
たとえば、HTML コメントの中に例外のスタック・トレースを含めてはいけません。 
```

## Guideline 2-2 / CONFIDENTIAL-2: Do not log highly sensitive information

機密情報をログに出すな。

```
社会保障番号（SSN）やパスワードなど、一部の情報は非常に機密性の高いものです。
これらの情報は、必要以上に長く保管したり、管理者であっても見られる可能性のある場所に置いてはいけません。
例えば、ログファイルに送信したり、検索してその存在を知ることができないようにすべきです。
一時的なデータの中には、char配列などの変更可能なデータ構造に保管し、使用後は直ちにクリアするものもあります。
一般的なJavaランタイム・システムでは、オブジェクトがプログラマには透過的にメモリ上を移動するため、データ構造のクリアは効果が減少します。

また、このガイドラインは、扱うデータの意味的な知識を持たない低レベルのライブラリの実装や使用にも影響します。
例えば、低レベルの文字列解析ライブラリは、処理するテキストを記録することがあります。アプリケーションは、このライブラリでSSNを解析することがあります。
これにより、ログファイルにアクセスできる管理者がSSNを入手できる状況になります。
```

## Guideline 2-3 / CONFIDENTIAL-3: Consider purging highly sensitive from memory after use

機密性の高い情報は、使ったらメモリからすぐ消すくらいしたほうがいい。

確かにそうだけど、本当にそんな実装しているところがあるのか？？
てかどうやってやるんだ。。？

このへんか。
https://wiki.sei.cmu.edu/confluence/display/java/MSC59-J.+Limit+the+lifetime+of+sensitive+data

```
機密性の高い情報がコアダンプ、デバッグ、機密性攻撃などに現れる可能性を狭めるためには、ガベージコレクション機構を待つのではなく、データを含むメモリを使用後すぐにゼロにすることが適切な場合があります。

しかし、そうすることには負の影響があります。余分な複雑さや変更可能なデータ構造により、コードの品質が損なわれます。
ライブラリがコピーを作成し、データをメモリに残してしまう可能性があります。仮想マシンやOSの動作によって、データのコピーがメモリやディスクに残ることもあります。
```

## 3 Injection and Inclusion

```
非常に一般的な攻撃方法は、特定のプログラムに細工されたデータを解釈させ、予期しない制御の変更を引き起こすことです。
一般的には、テキストフォーマットが対象となりますが、必ずしもそうとは限りません。
```

