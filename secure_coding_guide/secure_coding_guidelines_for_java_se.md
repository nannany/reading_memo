# 概要

Oracleから[Secure Coding Guidelines for Java SE](https://www.oracle.com/java/technologies/javase/seccodeguide.html)なる資料が発行されている。

上記資料は、[ Effective Java ](https://www.amazon.co.jp/dp/4621303252)や[ Software Security: Building Security In ](https://www.amazon.co.jp/dp/0321356705)の出版物で扱われた指針にさらにトピックを加えたガイドになっている。

対象読者は全てのJava開発者。  

章構成は、0~3章ではあらゆる種類のソフトウェアに共通して適用できる事項を、4~9章で信頼できないアプリケーションとやりとりするソフトウェアに焦点を当てている。

```
Javaプラットフォームの主な設計上の考慮点の一つは、異なる許可レベルのコードを実行するための制限された環境を提供することです。
Javaには、独自のセキュリティ上の課題があります。
Javaのセキュリティ・アーキテクチャ[1]は、多くの場合、敵対的なコードや誤動作するコードからユーザやシステムを保護するのに役立ちますが、信頼されたコードで発生する実装バグを防ぐことはできません。
このようなバグは、セキュリティ・アーキテクチャが封じ込めるように設計された穴を、意図せずに開けてしまう可能性があります。
ひどい場合には、ローカルプログラムが実行されたり、Java セキュリティが無効になったりすることもあります。
これらのバグは、マシンやイントラネットから機密データを盗んだり、システムリソースを悪用したり、マシンの有用な動作を妨げたり、さらなる攻撃を支援したり、その他多くの悪意ある活動に利用される可能性があります。

言語システムの選択は，あらゆるソフトウェアプログラムの堅牢性に影響を与える。
Java言語[2]と仮想マシン[3]は，よくあるプログラミング上のミスを軽減するための多くの機能を備えています．Java言語は型安全であり，ランタイムは自動的にメモリを管理し，配列の境界チェックを行います．また，Javaプログラムやライブラリは，不正な状態を早期にチェックします．これらの機能により，Javaプログラムは，C言語やC++で可能なスタック・スマッシング[4]やバッファ・オーバーフロー攻撃に対する高い耐性を備えています．Javaの明示的な静的型付けは、コードの理解を容易にし（静的解析を容易にし）、動的なチェックは、予期しない状況が予測可能な動作をもたらすことを保証します。

プログラマーのミスに起因するセキュリティ脆弱性の可能性を最小限に抑えるために、Javaの開発者は推奨されるコーディング・ガイドラインを遵守する必要があります。
Effective Java」[6]などの既存の出版物には、Java ソフトウェアの設計に関する優れたガイドラインが記載されています。
また、『Software Security: Building Security In [7]など、ソフトウェア・セキュリティの指針となる原則を示しています。
本文書は、このような出版物をまとめたものであり、追加のトピックも含まれています。
この文書は、Javaプログラミング言語を対象とした、セキュリティに特化したコーディングガイドラインのより完全なセットを提供します。
これらのガイドラインは、信頼できるエンドユーザ・アプリケーションを作成する人、セキュリティ・コンポーネントの内部を実装する人、一般的なプログラミング・タスクを実行する共有Javaクラス・ライブラリを開発する人など、すべてのJava開発者にとって興味深いものです。
実装上のバグは、深刻なセキュリティ上の影響を及ぼす可能性があり、ソフトウェアスタックのどの層にも現れる可能性があります。

第0章から第3章まではさまざまな種類のソフトウエアに共通して適用できるが、第4章から第9章までのガイドラインのほとんどは、信頼できないコードとやりとりするアプリケーションに焦点を当てている（ただし、これらの章のガイドラインの中には、他の状況にも当てはまるものがある）。
開発者は、アプリケーションの信頼境界を越えて発生する相互作用を分析し、関係するデータの種類を特定して、どのガイドラインが適切であるかを判断する必要があります。
脅威のモデル化を行い、信頼境界を確立することは、この目的を達成するのに役立ちます（ガイドライン0-4を参照）。

本ガイドラインは、開発者が安全なソフトウェアを構築することを目的としていますが、セキュリティ機能を実装するソフトウェアに特化したものではありません。
そのため、暗号技術などのトピックは本書では取り上げていません（Javaでの暗号技術の使用については[9]および[10]を参照してください）。
ソフトウェアに機能を追加することで、セキュリティ関連の問題を解決できる場合もありますが、セキュリティ上の欠陥をなくすことを目的としたものではありません。

この文書は、Java SE の新しいバージョンで導入された機能をカバーするため、また、すべての Java SE バージョンに適用されるベストプラクティスをよりよく説明するために、定期的に更新されます。
```

# 0 Fundamentals

Javaでのセキュリティを考慮するにあたって遵守すべき原則について述べる章。

## Guideline 0-0 / FUNDAMENTALS-0: Prefer to have obviously no flaws rather than no obvious flaws

基本的にはこのガイドラインに従うべしということが記述されている。

```
安全なコードを作成することは必ずしも容易ではありません。
Javaは非常に堅牢であるにもかかわらず、欠陥は驚くほど簡単にすり抜けてしまいます。
安全であることを確認するために巧妙なロジックを必要としないようなコードを設計・記述してください。
具体的には、よほどの理由がない限り、このドキュメントのガイドラインに従ってください。
```

## Guideline 0-1 / FUNDAMENTALS-1: Design APIs to avoid security concerns

APIの設計段階でセキュリティについて考慮しておけということが記述されている。
クラスをfinalにすることや、SecurityManagerの利用について述べられている。*がよく分からない*

```
セキュリティを考慮してAPIを設計する方がよい。
既存のAPIにセキュリティを後付けしようとすると、より難しく、エラーが発生しやすくなります。
例えば、クラスをfinalにすることで、悪意のあるサブクラスがfinalizerを追加したり、クローンを作ったり、ランダムなメソッドをオーバーライドしたりすることを防ぐことができます（ガイドライン4-5）。
また、SecurityManagerを使用する際には、精査すべき点があります。
```

## Guideline 0-2 / FUNDAMENTALS-2: Avoid duplication

コード、データの重複を避けよ。

```
コードやデータの複製は多くの問題を引き起こす。
コードもデータも、重複すると一貫して扱われない傾向があります。
例えば、変更がすべてのコピーに適用されないことがあります。
```

## Guideline 0-3 / FUNDAMENTALS-3: Restrict privileges

コードに与える権限を最小限にしておけ。
SecurityManagerを利用して、コードに与える権限を制御することができる。

```
最善の努力をしても、十分にレビューされたコードであっても、すべてのコーディング上の欠陥が排除されるわけではありません。
しかし、コードが軽減された権限で動作していれば、欠陥の悪用は阻止される可能性が高いのです。
この最も極端な方法は、最小特権の原則として知られています。
Javaのセキュリティメカニズムを使用すると、ポリシーファイルによる静的な権限制限や、java.security.AccessController.doPrivilegedメカニズムを使用した動的な権限制限を行うことができます（セクション9参照）。
この方法をとる場合、セキュリティマネージャはできるだけ早く（理想的にはコマンドラインから）インストールする必要があることに注意してください。
インストールが遅れると、セキュリティマネージャが導入される前に、セキュリティ上重要な操作が実行されてしまい、セキュリティチェックの効果が低下したり、過剰なパーミッションでオブジェクトが作成されたりする可能性があります。

リッチ・インターネット・アプリケーション（RIA）は、アプレットのパラメータやJNLP1で要求されるパーミッションを指定することができます。
署名されたJARは、サンドボックスで実行しなければならないか、すべての権限で実行しなければならないかを指定するマニフェスト属性を含むこともできます（[11]参照）。
サンドボックス化されたアプレットやアプリケーションがセキュリティ上問題のあるコードを実行しようとすると、JREはセキュリティ例外を発生させます。
RIA は最小特権の原則に従うべきで、必要最小限のパーミッションで実行するように構成されるべきです。
すべてのパーミッションでRIAを実行することは、可能な限り避けるべきです。
```

## Guideline 0-4 / FUNDAMENTALS-4: Establish trust boundaries

信頼の境界を確立せよ。
ブラウザとwebサーバーは互いにセキュリティ的に依存してはならない。

```
システムを確実に保護するためには、信頼の境界を確立する必要があります。
この境界を越えたデータは、使用前にサニタイズし、検証する必要があります。
また、セキュリティ監査を効率的に実施するためにも、信頼境界が必要です。
信頼境界の完全性を保証するコードは、それ自体の完全性が保証されるようにロードされなければなりません。

例えば、WebブラウザはWebサーバのシステムの外にあります。
同様に、WebサーバはWebブラウザのシステムの外にあります。
したがって、Webブラウザとサーバソフトウェアは、セキュリティのために相手の動作に依存してはいけません。

信頼の境界を監査する際には、いくつかの質問を念頭に置いておく必要があります。
使用されているコードやデータは十分に信頼できるものか？ライブラリが悪意のある実装に置き換えられていないか？信頼されていない設定データが使用されていないか？低い権限で呼び出されるコードは十分に保護されているか？
```

## Guideline 0-5 / FUNDAMENTALS-5: Minimise the number of permission checks

*どういうことだ。。9章を見たらわかる？*

```
Javaは主にオブジェクト機能を持つ言語です。
SecurityManagerのチェックは、最後の手段と考えるべきです。
いくつかの定義されたポイントでセキュリティチェックを行い、クライアントコードが保持するオブジェクト（ケイパビリティ）を返すことで、それ以上のパーミッションチェックは必要ありません。
ただし、適切なパーミッションを持たないコードにケイパビリティが漏れないように、チェックを実行するコードと呼び出し元の両方が注意を払わなければならないことに注意してください。
詳細はセクション9を参照してください。
```

## Guideline 0-6 / FUNDAMENTALS-6: Encapsulate

可視性の設計をちゃんとしよう。

```
ビヘイビアを割り当て、簡潔なインターフェイスを提供する。
オブジェクトのフィールドはプライベートにし、アクセサは避けるべきである。
メソッド、クラス、パッケージ、モジュールのインターフェイスは、一貫したビヘイビアのセットを形成すべきであり、それ以上のものであってはならない。
```

## Guideline 0-7 / FUNDAMENTALS-7: Document security-related information

セキュリティに関連するドキュメントをJavadocなどにちゃんと残せ。

```
APIドキュメントは、必要なパーミッション、セキュリティ関連の例外、呼び出し側の感度（このトピックに関する追加情報は、ガイドライン9-8から9-11を参照）、セキュリティに関連する前提条件や後条件などのセキュリティ関連情報をカバーする必要があります。
これらの情報をJavadocのようなツールのコメントで文書化することは、最新の情報を確保するのにも役立ちます。
```

## Guideline 0-8 / FUNDAMENTALS-8: Secure third-party code

サードパーティーのソフトウェアの脆弱性に気をつけよ。
パッチアップデートをちゃんとしたり、そのソフトウェアのセキュリティに関するベストプラクティスに従うこと。

```
ライブラリ、フレームワーク、その他のサードパーティ製ソフトウェアは、特に最新の状態に保たれていない場合、セキュリティ上の脆弱性や弱点をもたらす可能性があります。
筆者が公開したセキュリティアップデートは、バンドルされているアプリケーションや依存するライブラリ、OSのパッケージ管理の更新に到達するまでに時間がかかる場合があります。
したがって、使用しているサードパーティ製コードのセキュリティアップデートを把握し、タイムリーにアップデートが適用されるようにすることが重要です。
これには、アプリケーションで使用されているフレームワークやライブラリ、およびそれらのライブラリやフレームワークの依存関係も含まれます。
依存性チェックツールは、これらのタスクを実行するために必要な労力を軽減するのに役立ち、通常、開発とリリースのプロセスに組み込むことができます。

サードパーティ製ソフトウェアのセキュリティモデルとベストプラクティスを理解することも重要である。
安全な設定オプション、コードが実行するセキュリ ティ関連のタスク（暗号関数やシリアライズなど）、使用する API のセキュリティに関する考慮事項などを確認する。
コードに対する過去のセキュリティ問題や攻撃パターンを理解することも、より安全な方法でコードを使用するのに役立ちます。
例えば、過去のセキュリティ問題が特定の機能や構成に適用されていた場合、それらを回避することで暴露を最小限に抑えることができます。

また、サードパーティ製コードのセキュリティ対策についても、定期的に見直す必要があります。
セキュリティアップデートがリリースされるたびに適用するだけでなく、より安全なAPIや設定オプションを時間をかけて利用できるようにすることもできます。
```

# 1 Denial of Service

DoS攻撃への対応

## Guideline 1-1 / DOS-1: Beware of activities that may use disproportionate resources

DoS系攻撃の具体例。*こんなのがあるんだって感じでためになる。*

```
攻撃の例としては以下のようなものがあります。

- ベクターグラフィックスで大きな画像サイズを要求する。例えば、SVGやフォントファイルなどです。
- 整数オーバーフローのエラーにより、サイズのサニティチェックが失敗することがある。
- テキストやバイナリストリームを解析して構築されたオブジェクトグラフは、元のデータの何倍ものメモリを必要とする場合があります。
- 短いファイルを非常に高度に圧縮する "Zip bomb"。例えば、ZIPやGIF、gzipでエンコードされたHTTPコンテンツなどがこれにあたります。ファイルを解凍する際には、圧縮されたサイズやメタデータに頼るのではなく、解凍されるデータのサイズに制限を設けた方が良いでしょう。
- 「Billion laughs attack (10億笑い攻撃) XMLエンティティの拡張により、解析時にXML文書が急激に大きくなること。XMLConstants.FEATURE_SECURE_PROCESSING機能を設定して、合理的な制限をかけてください。
- ハッシュテーブルに同じハッシュコードで多数のキーを挿入すると、O(n)程度のアルゴリズムがO(n^2)になります。
- 正規表現が壊滅的なバックトラックを起こす可能性がある。
- XPath式は、任意のプロセッサ時間を消費する可能性があります。
- Java デシリアライゼーションと Java Beans 悪意のあるデータの XML デシリアライゼーションでは、メモリや CPU の使用量が制限されることがあります。
- 異常な動作を詳細に記録すると、ログファイルに過剰な出力が行われることがあります。
- コーナーケースのデータを解析すると、無限ループが発生することがあります。ループの各反復処理が確実に進行するようにしてください。
- 信頼できないソースからの JAR を処理すると、リソースの枯渇やランタイムの予期せぬ動作につながる可能性があります。
```

## Guideline 1-2 / DOS-2: Release resources in all cases

リソースの開放もれをするな。
防ぐためには[ Execute Around Method ](https://java-design-patterns.com/patterns/execute-around/)パターンを使ったりする。
このパターンは、ある関数の前後に必ず挟みたいロジックを入れる場合に利用するものと理解。

```
オープンファイルやロック、手動で割り当てられたメモリなど、一部のオブジェクトはリソースとして動作するため、
アクイジション操作のたびに明確なリリースが必要になります。例外が発生すると、実行経路に大きな可能性があることを見落としがちになります。
リソースは何があっても速やかに解放しなければなりません。

経験豊富なプログラマであっても、リソースの扱いを誤ることがあります。誤りを減らすためには、重複を最小限に抑え、
リソースの取り扱いに関する問題を分離する必要があります。Execute Around Methodパターンは、
アクイジションとリリースの操作をペアで抽出する優れた方法を提供します。
このパターンは、Java SE 8のラムダ機能を使って簡潔に使うことができます。
```

try-with-resourceとかも有用。

tryの中でリソースにアクセスしに行って、ロックする、みたいなことはできるので、そこは注意すること。


## Guideline 1-3 / DOS-3: Resource limit checks should not suffer from integer overflow

*よく理解できず。後でもうちょい見る。*

```
Java言語では、配列の境界チェックを行うことで、大部分の整数オーバーフロー攻撃を軽減することができます。
しかし，プリミティブな整数型に対する演算の中には，静かにオーバーフローするものがあります．
そのため、リソースの制限をチェックする際には注意が必要です。これはディスクスペースのような永続的なリソースでは特に重要で、
再起動しても問題が解決しないことがあります。
いくつかのチェックはオーバーフローを避けるために再配置することができます。
大きな値の場合、current + max は負の値にオーバーフローする可能性がありますが、これは常に max よりも小さい値になります。
```

```
パフォーマンスに問題がない場合は、任意のサイズの整数を使用することで冗長なアプローチが可能です。
```

```
2の補数による整数演算の特徴は、最小の負の値には、同じ大きさの正の値が一致しないことです。つまり、Integer.MIN_VALUE == -Integer.MIN_VALUE、Integer.MIN_VALUE == Math.abs(Integer.MIN_VALUE)となり、整数aの場合、a < 0では-a > 0を意味しません。
Java SE 8以降、java.lang.Mathクラスには、様々な演算（addExact、multiplyExact、decrementExactなど）のためのメソッドも含まれており、結果が与えられた型をオーバーフローした場合にはArithmeticExceptionがスローされます。
```

## Guideline 1-4 / DOS-4: Implement Robust Error/Exceptions handling for services

エラーをハンドリングせよ。
エラーが伝播して、プロセスごと死ぬことを危惧しているようだ。

通常のアプリ開発だとFWを使うからこのあたりはあまり意識しなくても良さそう。というか、OOMEって出た時点でサービス不能になるのは正しいのではないか？？
Errorsもcatchするのか。。？

```
サービスは、公開されたAPIにクライアントがアクセスするためのループとして設計されることが多く、例えば、公開されたServerSocketに通信することができます。
例外が発生した場合には、通常、文書化された例外がキャッチされ、サービスはそれに応じて応答することができます。
見落としがちなのは、公開されたAPIでは、Exceptionのサブタイプだけでなく、Errorタイプ（OutOfMemoryErrorやArithmeticErrorなど）もスローされることです。
サーバープロセスがこれらをスムーズに処理できないと、Errorが上に伝播してしまいます。
これにより、受信ループがサービスを終了してしまい、サービス不能状態に陥る可能性があります。そのため、catch節にはErrorsも含めることが推奨されています。
```

# 2 Confidential Information

```
機密データは、限られた文脈の中でのみ読めるようにすべきである。
信頼されるべきデータは、改ざんにさらされてはならない。
特権コードは、意図されたインターフェースを介して実行可能であってはならない。
```

## Guideline 2-1 / CONFIDENTIAL-1: Purge sensitive information from exceptions

例外情報で機密情報を漏らさないようにする。
スタックトレースの情報をそのままクライアントに返したり、サードパーティーライブラリの例外情報をそのままクライアントに返したりしないこと。

```
例外オブジェクトは、機密情報を伝える可能性があります。
例えば、メソッドが java.io.FileInputStream コンストラクタを呼び出して基礎となる構成ファイルを読み込もうとし、そのファイルが存在しない場合には、ファイルのパスを含む java.io.FileNotFoundException がスローされます。
この例外をメソッドの呼び出し元に伝えることで、ファイルシステムのレイアウトが公開されます。
多くの攻撃方法では、ファイルの位置を知ったり推測したりする必要があります。

カレントユーザーの名前やホームディレクトリを含むファイルパスが公開されると、問題が悪化します。
標準的なシステムプロパティ（user.homeなど）にこの情報が含まれている場合、SecurityManagerはこの情報の保護をチェックしますが、例外メッセージでこの情報を公開すると、これらのチェックを効果的に回避することができます。

内部例外は、上流の呼び出し元に伝える前にキャッチしてサニタイズすべきです。
例外の種類によっては，メッセージが削除されていても，機密情報が漏えいする可能性があります。
たとえば，FileNotFoundException は，指定されたファイルが存在するかどうかを明らかにする．

また，呼び出し元の入力から得られた情報を含む例外をサニタイズする必要がある場合もある。
例えば，ファイルアクセスに関連する例外は，ファイルが存在するかどうかを明らかにすることができる。
攻撃者は、さまざまなファイル名を入力し、発生した例外を分析することで、有用な情報を収集できる可能性があります。

例外の内容が将来的に変更される可能性があるため、セキュリティに依存する場合は注意が必要です。
例えば、あるライブラリの前のバージョンでは、機密性の高い情報が例外に含まれておらず、既存のクライアントがその例外に依存してセキュリティを確保していたとします。
例えば、ライブラリがメッセージを伴わない例外を投げることがあります。
アプリケーション・プログラマはこの動作を見て、例外を伝搬させても問題ないと判断するかもしれません。
しかし、ライブラリの後続バージョンでは、例外メッセージに追加のデバッグ情報が追加されているかもしれません。
アプリケーション・コード自体は変わっていなくても、アプリケーションはこの追加情報を公開してしまいます。
例外の一部の要素を除外するのではなく、例外から既知の許容できる情報のみを含めるようにしてください。

また、例外には、システムの構成や内部に関する機密情報が含まれていることがあります。
例外情報が何を含んでいるかを正確に知らない限り、エンドユーザーに例外情報を渡さないでください。
たとえば、HTML コメントの中に例外のスタック・トレースを含めてはいけません。 
```

## Guideline 2-2 / CONFIDENTIAL-2: Do not log highly sensitive information

機密情報をログに出すな。

```
社会保障番号（SSN）やパスワードなど、一部の情報は非常に機密性の高いものです。
これらの情報は、必要以上に長く保管したり、管理者であっても見られる可能性のある場所に置いてはいけません。
例えば、ログファイルに送信したり、検索してその存在を知ることができないようにすべきです。
一時的なデータの中には、char配列などの変更可能なデータ構造に保管し、使用後は直ちにクリアするものもあります。
一般的なJavaランタイム・システムでは、オブジェクトがプログラマには透過的にメモリ上を移動するため、データ構造のクリアは効果が減少します。

また、このガイドラインは、扱うデータの意味的な知識を持たない低レベルのライブラリの実装や使用にも影響します。
例えば、低レベルの文字列解析ライブラリは、処理するテキストを記録することがあります。アプリケーションは、このライブラリでSSNを解析することがあります。
これにより、ログファイルにアクセスできる管理者がSSNを入手できる状況になります。
```

## Guideline 2-3 / CONFIDENTIAL-3: Consider purging highly sensitive from memory after use

機密性の高い情報は、使ったらメモリからすぐ消すくらいしたほうがいい。

確かにそうだけど、本当にそんな実装しているところがあるのか？？
てかどうやってやるんだ。。？

このへんか。
https://wiki.sei.cmu.edu/confluence/display/java/MSC59-J.+Limit+the+lifetime+of+sensitive+data

```
機密性の高い情報がコアダンプ、デバッグ、機密性攻撃などに現れる可能性を狭めるためには、ガベージコレクション機構を待つのではなく、データを含むメモリを使用後すぐにゼロにすることが適切な場合があります。

しかし、そうすることには負の影響があります。余分な複雑さや変更可能なデータ構造により、コードの品質が損なわれます。
ライブラリがコピーを作成し、データをメモリに残してしまう可能性があります。仮想マシンやOSの動作によって、データのコピーがメモリやディスクに残ることもあります。
```

# 3 Injection and Inclusion

```
非常に一般的な攻撃方法は、特定のプログラムに細工されたデータを解釈させ、予期しない制御の変更を引き起こすことです。
一般的には、テキストフォーマットが対象となりますが、必ずしもそうとは限りません。
```

## Guideline 3-1 / INJECT-1: Generate valid formatting

- 誤ったデータに対して、訂正するよりは発覚し次第弾いてやるべき。
- 構文解析と正規化を検証の前に行うべき？
    - これは何でだ？

```
悪意を持って作られた入力を使用して、出力の不正なフォーマットを引き起こす攻撃は、よく知られています[7]。
このような攻撃は、一般的に、入力文字列の特殊文字を利用したり、不正なエスケープを行ったり、特殊文字を部分的に削除したりします。

入力文字列が特定のフォーマットである場合、修正と検証を組み合わせると、非常にエラーが発生しやすくなります。
構文解析と正規化は、検証の前に行う必要があります。
可能であれば、修正を行わずに、無効なデータとそれ以降のデータを拒否する。
例えば、多くのネットワークプロトコルは、HTTPヘッダがエラーを引き起こすにもかかわらず、HTTPボディを解釈することで、クロスサイトPOST攻撃に対して脆弱性を持っています。

その場しのぎのコードではなく、十分にテストされたライブラリを使用してください。
XMLを作成するためのライブラリは数多くあります。
生のテキストを使ってXML文書を作成すると、エラーが発生しやすくなります。
設定ファイルのように適切なライブラリが存在しない特殊なフォーマットの場合は、すべてのフォーマットをきれいに処理するクラスを作成し、フォーマットコードのみを作成してください。
```

## Guideline 3-2 / INJECT-2: Avoid dynamic SQL

これはSQLインジェクション対策の話。
プレースホルダーを利用して、すでに構文解析済みのSQLに、変数部分だけ当て込めるようにする。
つまり、SQLの構文解析部分に、外部からの変数を関わらせない。

```
信頼できない入力を含む動的に作成されたSQL文は、コマンドインジェクションの対象となることはよく知られています。
これは多くの場合、引用符(')に続いてSQLを含む入力を供給するという形をとります。
動的なSQLは避けてください。

Java Database Connectivity（JDBC）を使用したパラメータ化されたSQL文では、java.sql.Statementの代わりにjava.sql.PreparedStatementまたはjava.sql.CallableStatementを使用してください。
一般的に、アプリケーション・コードをSQLから隔離するためには、よく書かれた上位レベルのライブラリを使用する方がよいでしょう。
このようなライブラリを使用する場合，引用符(')などの文字を制限する必要はありません。
XML/HTMLの出力時に正しく処理されるのであれば（ガイドライン3-3）、SQLへの入力時にless than (<)などの文字を禁止する必要はありません。

PreparedStatementの正しい使い方の例です。
```

```java
String sql = "SELECT * FROM User WHERE userId = ?"; 
PreparedStatement stmt = con.prepareStatement(sql); 
stmt.setString(1, userId); 
ResultSet rs = prepStmt.executeQuery();
```

## Guideline 3-3 / INJECT-3: XML and HTML generation requires care

HTML,XML出力について。
正しくデータサニタイズするのは難しいので、信頼できるライブラリを使え。

```
信頼できないデータは、HTMLやXMLの出力に含める前に適切にサニタイズする必要があります。
データを適切にサニタイズしないと、クロスサイトスクリプティング（XSS）やXMLインジェクションの脆弱性など、さまざまなセキュリティ上の問題が発生します。
特に、Java Server Pages（JSP）を使用する際には注意が必要です。

データを出力に含める前にサニタイズするには、さまざまな方法があります。
特定の種類の出力で問題となる文字は、フィルタリング、エスケープ、またはエンコードすることができます。
また、安全であることがわかっている文字は許可し、それ以外の文字はフィルタリング、エスケープ、エンコードすることもできます。
後者の方法は、問題を引き起こす可能性のあるすべての文字を特定して列挙する必要がないため、好ましい方法です。

正しいデータサニタイズとエンコーディングの実装は難しく、エラーが発生しやすいものです。
そのため、HTMLやXMLを作成する際には、ライブラリを使ってこれらの作業を行うのがよいでしょう。
```

## Guideline 3-4 / INJECT-4: Avoid any untrusted data on the command line

新しいプロセスに渡すデータは一時ファイルや継承されたチャネル？を通じて渡す。
普通にWebプログラミングをするにあたってはプロセスを作ることはなさそう。

[xxe攻撃](https://www.mbsd.jp/blog/20171130.html) 

```
新しいプロセスを作成するときは、信頼できないデータをコマンドラインに置かないでください。
挙動はプラットフォームに依存し、文書化されておらず、驚くことも多いです。
例えば、悪意のあるデータは、1つの引数をオプション（通常、Unixでは先頭の-、Windowsでは/）として解釈させたり、2つの別々の引数として解釈させたりします。
新しいプロセスに渡す必要のあるデータは、エンコードされた引数（Base64など）、一時ファイル、または継承されたチャネルを介して渡す必要があります。
```

## Guideline 3-5 / INJECT-5: Restrict XML inclusion

XMLを取得して、それを元に何か組み立てたりする処理は気をつける。
そのような処理がある場合はXMLパーサーの権限を制限したりする。

```
XML Document Type Definitions（DTD）では、ローカルファイルやローカルイントラネット内のHTTP URL、localhostなどのシステムエンティティとしてURLを定義することができます。
XML External Entity（XXE）攻撃では、ローカルファイルをXMLデータに挿入し、クライアントからアクセスできるようにすることができます。
同様の攻撃は、XInclude、XSLT のドキュメント機能、XSLT の import および include 要素を用いて行われる可能性があります。
XML の能力を維持しながらこれらの問題を回避する最も安全な方法は、（ガイドライン 9-2 で説明したように）権限を減らし、XML パーサーに可能な限り制限的な設定を使用することです。
権限を下げても、必要に応じて同一オリジンのWebサイトのページを含めるなど、ある程度のアクセスを許可することができます。
XML パーサーは、外部エンティティを禁止したり、DTD を完全に無効にしたりするなど、必要に応じて機能を制限するように設定することもできます。

なお、この問題は、一般に、XMLを使用するAPIを使用する場合に適用されるが、特にXML APIではない。
```

## Guideline 3-6 / INJECT-6: Care with BMP files

色の情報に関するファイルICCがBMP画像ファイル経由で読み取られる可能性があるらしい。

```
BMP画像ファイルには、ローカルのICC（International Color Consortium）ファイルが参照されている場合があります。
ICCファイルの内容はあまり重要ではありませんが、ファイルを読もうとする行為は問題となります。
BMPファイルを使わないようにするか、ガイドライン9-2のように権限を減らすようにしてください。
```

## Guideline 3-7 / INJECT-7: Disable HTML display in Swing components

Swingにおいて、htmlをそのまま解釈する機能があるので、そのレンダリング機能はオフにする。

```
多くのSwingプラグインのルック・アンド・フィールズは、<html>で始まる特定のコンポーネント内のテキストをHTMLとして解釈します。
そのテキストが信頼できないソースからのものである場合、攻撃者は他のコンポーネントが存在するように見えるようにHTMLを加工したり、包含攻撃を行うことができます。

HTMLレンダリング機能を無効にするには、各コンポーネントの "html.disable "クライアントプロパティをBoolean.TRUEに設定してください（他のBoolean trueインスタンスではダメです）。

label.putClientProperty("html.disable", true)とします。
```

## Guideline 3-8 / INJECT-8: Take care interpreting untrusted code

信頼できないコードを実行させる仕組みがある。
それらを使うときは気をつける。

```
コードはさまざまな場所に隠すことができます。コードを供給するソースが信頼できない場合は、コードを実行するための安全なサンドボックスを構築する必要があります。
信頼されていないコードを実行する可能性のあるコンポーネントやAPIの例としては、以下のようなものがあります。

- javax.script スクリプト API または類似の API を介して実行されるスクリプト。
- LiveConnect のインターフェースは、ブラウザで実行される JavaScript と共に行われます1。Web ページ上で実行される JavaScript は、通常、オブジェクト コード署名証明書で検証されていません。
- デフォルトでは、XSLT インタープリタの Oracle 実装では、拡張機能による Java コードの呼び出しが可能です。これを無効にするには javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING 機能を設定してください。
- JavaBeansコンポーネントのLong Term Persistenceは、Javaステートメントの実行をサポートします。
- Java Soundは、javax.sound.midi.MidiSystem.getSoundbankメソッドを通じてコードをロードします。
- RMIでは、リモート接続で指定されたリモートコードのロードが可能な場合があります。Oracle JDK では、この機能はデフォルトでは無効になっていますが、java.rmi.server.useCodebaseOnly システムプロパティによって有効または無効にすることができます。
- LDAP (RFC 2713) では、サーバーの応答にリモートコードを読み込むことができます。Oracle JDK では、この機能はデフォルトでは無効になっていますが、com.sun.jndi.ldap.object.trustURLCodebase システムプロパティによって有効または無効にすることができます。
- 多くのSQL実装では、データベース自体の外側で効果を持つコードの実行が可能です。
- 信頼されていないデータを使ってJNDI検索を行うことは、悪意のあるCORBA、LDAP、RMIサーバーとのやり取りにつながる可能性があるため、避けるべきです。どうしても避けられない場合は、本ガイドラインで説明するシステム・プロパティに安全な値を設定したり、セクション8のデシリアライズのガイダンス（特にガイドライン8-6）に従うなど、適切な安全対策を講じる必要があります。また、ルックアップ処理中に攻撃者に悪用される可能性のあるクラス（javax.naming.spi.ObjectFactoryの実装など）がクラスパス上に存在しないことを確認する必要があります。
```

## Guideline 3-9 / INJECT-9: Prevent injection of exceptional floating point values

doubleを扱う際には気をつける。

`Double#isNan`,`Double#isInfinite`を利用して、サニタイズすることを考える。


```
浮動小数点数を扱う際には、信頼できない入力データを経由して、NaN（not a number）や無限大の値がアプリケーションに注入される可能性があるため、信頼できる境界の外から浮動小数点数をインポートする際には注意が必要です。
残念ながら、例外的な値の処理は、サニタイズコードを導入しなければ、通常はすぐに気づくことができません。
さらに、例外的な値を操作に渡すと、例外的な数値の状態が操作結果に伝搬されます。

正と負の無限大の値は、浮動小数点演算の結果として考えられます[2]。
これは、結果が高すぎたり低すぎたりして、プリミティブな浮動小数点値をバックアップするメモリ領域で表現できない場合です。
また，0.0を0.0で割ったり，無限大から無限大を引いたりすると，例外的な値であるNaNが生じます．

伝播された例外的な浮動小数点数を短・整数・長の各プリミティブ値にキャストした結果にも、特別な注意が必要です。
これは、NaN値を整数に変換すると0になり、正の無限大の値はInteger.MAX_VALUE（負の無限大の場合はInteger.MIN_VALUE）に変換されるためで、特定の使用例では正しくない場合があります。

このような例外的な値が期待されるアプリケーション・シナリオもあります。
たとえば、数値処理に依存する科学的データ分析などです。
しかし、結果の値は、その目的のためにローカル・コンポーネントに含まれることをお勧めします。
これは、浮動小数点の結果をアプリケーションの一般的な部分に戻す前にサニタイズすることで実現できます。

前述したように、プログラマは、浮動小数点数を扱う際、特に認可や認証の判断に関連する場合や、浮動小数点数の値をJNIに転送する場合には、これらの例外的な値に対するサニタイズコードを含めることを望むかもしれません。
DoubleクラスとFloatクラスは、isNanメソッドとisInfiniteメソッドを提供することで、サニタイズの手助けをしています。
また、等号演算子でDouble.NaNのインスタンスを比較すると、常にfalseになることに注意してください。
これは、クラス定義のequalsメソッド内でラップされたdoubleフィールドに等号演算子を使用する場合、マップやコレクションでの検索問題を引き起こす可能性があります。

予期せぬ浮動小数点数の処理を妨げる典型的なコードパターンを以下の例で示します。
```

```java
if (Double.isNaN(untrusted_double_value)) {
    // specific action for non-number case
}

if (Double.isInfinite(untrusted_double_value)){
    // specific action for infinite case
}

// normal processing starts here
```

---
# 4 Accessibility and Extensibility

```
システムの安全性を確保する作業は、コードの「攻撃面」を減らすことで容易になります。
```

## Guideline 4-1 / EXTEND-1: Limit the accessibility of classes, interfaces, methods, and fields

公開したくないものはprivateなり、パッケージプライベートなりにする。

interfaceは暗黙のうちにpublicになる。

異なるローダーによってロードされたクラスは同じパッケージ名でもパッケージプライベートアクセスできない。

```
Javaパッケージは、関連するJavaクラスやインターフェースをまとめたものです。
公開されたAPIの一部として指定されている場合は、クラスやインターフェースをpublicと宣言し、そうでない場合はpackage-privateと宣言します。
同様に、クラスのメンバーやコンストラクタ（入れ子になったクラス、メソッド、フィールド）も、APIの一部として指定されている場合は、必要に応じてpublicまたはprotectedと宣言します。
そうでない場合は、実装の公開を避けるために、privateまたはpackage-privateと宣言してください。
インターフェイスのメンバーは暗黙のうちに公開されることに注意してください。

異なるローダーによってロードされたクラスは、たとえパッケージ名が同じであっても、お互いにパッケージ・プライベート・アクセスを持ちません。
同じパッケージ内のクラスが同じクラスローダによってロードされる場合、同じコード署名証明書を共有するか、または証明書を全く持たないかのいずれかでなければなりません。
Java仮想マシンでは、クラスローダがパッケージを定義する役割を担っています。
当然のことですが、パッケージはJARファイルのマニフェストでsealedとマークされることが推奨されます。
```

## Guideline 4-2 / EXTEND-2: Limit the accessibility of packages

`package.access`プロパティなるものを設定すると、実装コードがリフレクションで使用されることを防げるらしい。
ライブラリとして使用される目線かな？


```
コンテナは、package.access セキュリティプロパティに追加することで、実装コードを隠すことができます。
このプロパティは、他のクラスローダからの信頼されていないクラスが、指定されたパッケージ階層をリンクしたり、リフレクションを使用したりするのを防ぎます。
このプロパティが設定される前に、信頼されていないコンテクストからパッケージにアクセスできないようにするための注意が必要です。

このサンプルコードは、package.access security プロパティに追加する方法を示しています。
なお、このコードはスレッドセーフではありません。
このコードは、通常、1つのシステムに1回しか登場しません。
```

```java
private static final String PACKAGE_ACCESS_KEY = "package.access";
static {
    String packageAccess = java.security.Security.getProperty(
        PACKAGE_ACCESS_KEY
    );
    java.security.Security.setProperty(
        PACKAGE_ACCESS_KEY,
        (
            (packageAccess == null ||
             packageAccess.trim().isEmpty()) ?
            "" :
            (packageAccess + ",")
        ) +
        "xx.example.product.implementation."
    );
}
```

## Guideline 4-3 / EXTEND-3: Isolate unrelated code

ここで言うコンテナって何のことだ？？信頼度の低いコードを管理するコードとは？

うーんむずかしい。

```
コンテナ、つまり信頼度の低いコードを管理するコードは、関係のないアプリケーションコードを隔離する必要があります。
信頼されていないコードであっても、通常はそのオリジンにアクセスする許可が与えられているため、異なるオリジンからの信頼されていないコードは隔離する必要があります。
例えば、Javaプラグインは、関連性のないアプレットを別々のクラスローダインスタンスにロードし、別々のスレッドグループで実行します1。

直接的なアクセスにはセキュリティ・チェックが行われるかもしれませんが、システム・クラス・ローダやスレッド・コンテキスト・クラス・ローダを間接的に利用する方法もあります。
プログラムは、システム・クラス・ローダはどこからでもアクセス可能であり、スレッド・コンテキスト・クラス・ローダは、関連するスレッド上で実行可能なすべてのコードからアクセス可能であることを想定して書かれるべきです。

一見グローバルなオブジェクトでも、実際にはアプレット1やアプリケーションコンテキストにローカルなものもあります。
異なる Web サイトから読み込まれたアプレットは、例えば java.awt.Frame.getFrames から返される値が異なります。
このようなスタティック・メソッド（およびトゥルー・グローバルのメソッド）は、現在のスレッドやスタック上のコードのクラス・ローダーからの情報を使用して、現在のコンテキストを判断します。
これにより、悪意のあるアプレットが他のサイトのアプレットに干渉することを防ぎます。

隔離が不意に破られてしまう一般的な方法として、 Mutable statics (Guideline 6-11参照) と例外があります。
ミュータブル・スタティックは、どのようなコードでも、それを直接、あるいは間接的に使用するコードに干渉することができます。

ライブラリ・コードは、信頼度の低いコードが安全に使用できるように注意深く書くことができます。
ライブラリは、クライアントコードの完全性を侵害しないために、少なくとも使用されるコードと同等の信頼度を必要とします。
コンテナーは、信頼度の低いコードが信頼度の高いライブラリーコードを置き換えることができないようにし、パッケージ・プライベート・アクセスができないようにする必要があります。
両方の制限は通常、アプリケーションクラスローダーの親であるライブラリクラスローダーという別のクラスローダーインスタンスを使用することで実施されます。
```

## Guideline 4-4 / EXTEND-4: Limit exposure of ClassLoader instances

クラスローダーインスタンスへのアクセス権限はちゃんと設定する。
なんかクラスローダーを自由に触らせるとよくないらしい。

ライブラリとして提供する側の防御について言及しているのかな？

```
ClassLoaderインスタンスへのアクセスは、望ましくない可能性のある特定の操作を可能にします。

- クライアントコードが通常はアクセスできないクラスへのアクセス。
- リソースの URL の情報を取得すること（実際に URL を開くことは通常の制限で制限されています）。
- アサーション・ステータスをオン・オフすることができる。
- インスタンスをサブクラスにキャストすることができる。ClassLoaderのサブクラスは望ましくないメソッドを持つことが多い。

ガイドライン9-8では、様々なJavaライブラリのメソッドを使ってClassLoaderインスタンスを取得する際のアクセスチェックについて説明しています。スレッド・コンテキスト・クラス・ローダを通してクラス・ローダを公開する際には注意が必要です。
```

## Guideline 4-5 / EXTEND-5: Limit the extensibility of classes and methods

セキュアなクラスは継承させない。

```
クラスやメソッドを継承するように設計するか、final（最終）と宣言する [6]。
ファイナルでないままだと、攻撃者が悪意を持ってクラスやメソッドをオーバーライドできてしまいます。
サブクラス化を許可しないクラスは、実装が容易であり、安全であることを検証することができます。
継承よりも合成を優先する。
```

```java
// Unsubclassable class with composed behavior.
public final class SensitiveClass {

    private final Behavior behavior;

    // Hide constructor.
    private SensitiveClass(Behavior behavior) {
       this.behavior = behavior;
    }

    // Guarded construction.
    public static SensitiveClass newSensitiveClass(
        Behavior behavior
    ) {
        // ... validate any arguments ...

        // ... perform security checks ...

        return new SensitiveClass(behavior);
    }
}
```

```
Object.finalize2 メソッドをオーバーライドした悪意のあるサブクラスは、コンストラクタから例外がスローされた場合でも、オブジェクトを復活させることができます。
コンストラクタが明示的に java.security.SecurityException をスローする低レベルのクラスは、セキュリティ上の問題を抱えている可能性があります。
JDK6以降では、java.lang.Objectコンストラクタが終了する前に例外がスローされ、ファイナライザが呼び出されないようになっています。
したがって、サブクラス化が許可されていて、オブジェクトを構築するためにセキュリティマネージャの許可が必要な場合は、スーパーコンストラクタを呼び出す前にチェックを行います。
これは、代替（this）コンストラクタの呼び出しの引数としてメソッド呼び出しを挿入することで行うことができます。
```

```java
public class NonFinal {

    // sole accessible constructor
    public NonFinal() {
        this(securityManagerCheck());
    }

    private NonFinal(Void ignored) {
        // ...
    }


    private static Void securityManagerCheck() {
       SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(...);
        }
        return null;
    }

}
```

```
JDK 6以前のバージョンのJavaとの互換性のために、機密性の高い操作を行うたびに、またクラスの他のインスタンスを信頼する前に、クラスが初期化されていることを確認してください。
部分的に初期化されたインスタンスを見ることができるかもしれないので、どんな変数でもデフォルト値を安全に解釈する必要があります。
ミュータブルなクラスの場合は、"initialized "フラグを揮発性にして、適切なhappens-before関係を作ることをお勧めします。
```

```java
public class NonFinal {

    private volatile boolean initialized;

    // sole constructor
    public NonFinal() {
        securityManagerCheck();

        // ... initialize class ...

        // Last action of constructor.
        this.initialized = true;
    }

    public void doSomething() {
        checkInitialized();
    }

    private void checkInitialized() {
        if (!initialized) {
            throw new SecurityException(
                "NonFinal not initialized"
            );
        }
    }
}
```

```
オブジェクトに属する java.lang.Class インスタンスを調べてオブジェクトのクラス・タイプを確認する場合、Class.getName で取得したクラス名だけで Class インスタンスを比較してはいけません。

Java SE 15では、コードによって特定のクラスのサブクラスの存在を制限できるsealedクラスが導入されました。
これにより、クラス契約に従わない不正な実装を防ぐことができます。
```

## Guideline 4-6 / EXTEND-6: Understand how a superclass can affect subclass behavior

スーパークラスの変更がサブクラスのセキュリティに影響を与えることがあるので注意。

```
サブクラスは、自身の動作を絶対的に制御する能力を持っていません。
スーパークラスは、オーバーライドされていない継承されたメソッドの実装を変更することで、サブクラスの動作に影響を与えることができます。
サブクラスがすべての継承されたメソッドをオーバーライドする場合でも、スーパークラスは新しいメソッドを導入することでサブクラスの動作に影響を与えることができます。
スーパークラスへのそのような変更は、サブクラスで作られた仮定を意図せずに壊し、微妙なセキュリティの脆弱性につながる可能性があります。
JDK 1.2で発生した次のような例を考えてみましょう。
```

```
Class Hierarchy                  Inherited Methods
-----------------------          --------------------------
java.util.Hashtable              put(key, val)
          ^                      remove(key)
          | extends
          |
java.util.Properties
          ^
          | extends
          |
java.security.Provider           put(key, val) // SecurityManager
                                 remove(key)   // checks for these
                                               // methods
```

```
java.security.Providerクラスは、java.util.Propertiesを継承し、Propertiesはjava.util.Hashtableを継承しています。
この階層では、Providerクラスは、Hashtableからputやremoveなどの特定のメソッドを継承しています。
Provider.putは，RSAなどの暗号アルゴリズム名を，そのアルゴリズムを実装したクラスにマッピングします。
悪意のあるコードが内部のマッピングに影響を与えないように、プロバイダは put と remove をオーバーライドして、必要な SecurityManager のチェックを実施します。

Hashtable クラスは JDK 1.2 で拡張され、Hashtable からのエントリの削除をサポートする新しいメソッド entrySet が追加されました。
Providerクラスは、この新しいメソッドをオーバーライドするように更新されていませんでした。
このため、攻撃者は Provider.remove で強制されている SecurityManager のチェックを回避し、Hashtable.entrySet メソッドを呼び出すだけで Provider のマッピングを削除することができました。

主な欠陥は、Providerに属するデータ（マッピング）がHashtableクラスに格納されているのに対し、データを保護するチェックはProviderクラスで実施されていることです。
このようにデータとそれに対応するSecurityManagerのチェックが分離されているのは、ProviderがHashtableを継承しているからに他なりません。
Providerは本質的にHashtableではないので、Hashtableから拡張すべきではありません。
代わりに、ProviderクラスはHashtableインスタンスをカプセル化して、データとそのデータを保護するチェックが同じクラスに存在するようにします。
Hashtableをサブクラス化するという当初の決定は、コードの再利用を達成しようとした結果だと思われますが、残念ながらスーパークラスとそのサブクラスの間に不都合な関係が生じ、最終的にはセキュリティの脆弱性につながってしまいました。

悪意のあるサブクラスは、java.lang.Cloneableを実装している可能性があります。
このインターフェースを実装すると、サブクラスの動作に影響を与えます。
犠牲者のオブジェクトのクローンが作られるかもしれません。
クローンは、浅いコピーになります。
2つのオブジェクトの本質的なロックとフィールドは異なりますが、参照されるオブジェクトは同じになります。
これにより、攻撃者は攻撃を受けたクラスのインスタンスの状態を混乱させることができます。

JDK 8では、インターフェースにデフォルト・メソッドが導入されました。
これらのデフォルト・メソッドは、クラスの中に予期せぬ新しいメソッドが現れるもう一つの経路です。
クラスがデフォルト・メソッドを持つインターフェイスを実装すると、それらはクラスの一部となり、内部データへの予期せぬアクセスを許す可能性があります。
セキュリティに敏感なクラスでは、そのクラス（およびすべてのスーパークラス）が実装するすべてのインターフェースを、前述のように監視する必要があります。
```

---

# 5 Input Validation

バリデーションチェック

```
Javaの文化の特徴として、堅牢性を高めるために厳格なメソッドのパラメータチェックが行われています。
より一般的には、外部からの入力を検証することは、セキュリティの重要な部分です。
```

## Guideline 5-1 / INPUT-1: Validate inputs

入力チェックをちゃんとしないとディレクトリトラバーサルとか起きちゃうよ。

```
信頼できないソースからの入力は、使用前に検証する必要があります。
悪意を持って作られた入力は、メソッドの引数や外部ストリームからの入力に関わらず、問題を引き起こす可能性があります。
例えば、整数値のオーバーフローや、ファイル名に"../"のシーケンスを含めることによるディレクトリトラバーサル攻撃などがあります。
使いやすさを追求した機能は、プログラム的なインターフェースとは別のものにすべきです。

信頼できない入力を処理することは、可能な限り避けるべきです。
例えば、信頼されていないソースからJARファイルを消費すると、攻撃者が悪意のあるコードやデータをシステムに注入し、動作不良やリソースの過剰消費などの問題を引き起こす可能性があります。

入力の検証は、その入力を防御的にコピーした後に行わなければならないことに注意してください（ガイドライン6-2参照）。
```

## Guideline 5-2 / INPUT-2: Validate output from untrusted objects as input

うーん難しい。TOCTOU？
とりあえず、信用できないオブジェクトからのアウトプットはバリデートかけろという感じ。
RESTAPIの戻り値とかならわかるけど、ライブラリのアウトプットとかでそんなことするかしら？
そもそもそんなライブラリ使うなて気がする。

```
一般的に、メソッドの引数は検証されるべきですが、戻り値は検証されません。
しかし、アップコール(上位のコードのメソッドを呼び出すこと)の場合には、 返り値を検証する必要があります。
同様に、アップコールの実装としてのみ到達可能なオブジェクトは、その入力を検証する必要はありません。

微妙な例として、ClassLoadersが返すClassオブジェクトがあります。
攻撃者は、引数として渡される ClassLoader インスタンスや、Thread コンテキストで設定される ClassLoader インスタンスを制御できる可能性があります。
そのため、ClassLoadersのメソッドを呼び出す際には、多くの仮定を立てることはできません。
ClassLoader.loadClass() の複数回の呼び出しは、同じ Class インスタンスまたは定義を返すことが保証されていないため、TOCTOU 問題を引き起こす可能性があります。
```

## Guideline 5-3 / INPUT-3: Define wrappers around native methods

nativeメソッドをpublicに公開してはいけない。
あまりに馴染みがないからよくわからないな。。
nativeメソッドを暑かったことがない。

```
Javaコードは、型、配列の境界、ライブラリの使用状況などをランタイムにチェックされます。
一方、ネイティブコードは、一般的にチェックされません。
純粋なJavaコードは、従来のバッファオーバーフロー攻撃に対して効果的に免疫がありますが、ネイティブメソッドはそうではありません。
ネイティブコードの呼び出し時にこれらの保護を提供するには、ネイティブメソッドをpublicに宣言してはいけません。
代わりにプライベートを宣言し、パブリックなJavaベースのラッパー・メソッドを通して機能を公開します。
ラッパーは、ネイティブ・メソッドを呼び出す前に、必要な入力検証を安全に行うことができます。
```

```java
public final class NativeMethodWrapper {

    // private native method
    private native void nativeOperation(byte[] data, int offset,
                                        int len);

    // wrapper method performs checks
    public void doOperation(byte[] data, int offset, int len) {
        // copy mutable input
        data = data.clone();

        // validate input
        // Note offset+len would be subject to integer overflow.
        // For instance if offset = 1 and len = Integer.MAX_VALUE,
        //   then offset+len == Integer.MIN_VALUE which is lower
        //   than data.length.
        // Further,
        //   loops of the form
        //       for (int i=offset; i<offset+len; ++i) { ... }
        //   would not throw an exception or cause native code to
        //   crash.

        if (offset < 0 || len < 0 || offset > data.length - len) {
              throw new IllegalArgumentException();
        }

        nativeOperation(data, offset, len);
    }
}
```

---

# 6 Mutability

mutability

```
変異可能性は、一見無害に見えますが、意外と様々なセキュリティ問題を引き起こす可能性があります。
このセクションの例では、java.util.Dateを多用していますが、これは変更可能なAPIクラスの一例です。
アプリケーションでは、不変的に設計された新しいJava Date and Time API (java.time.*)を使用するのが望ましいでしょう。
```

## Guideline 6-1 / MUTABLE-1: Prefer immutability for value types

immutableなクラスとするために、
- final class
- フィールドをfinalに

```
クラスを不変にすることで、後続のガイドラインに記載されている可変型オブジェクトに関連する問題がクライアントコードで発生するのを防ぐことができます。
不変クラスはサブクラス化できないようにします。
さらに、コンストラクタを隠すことで、インスタンスの生成やキャッシングをより柔軟に行うことができます。
これは、コンストラクタをプライベートにするか、デフォルトのアクセス（"package-private"）にするか、package.accessセキュリティプロパティによって制御されるパッケージに含まれることを意味します。
不変クラスは、ガイドライン6-2にあるように、フィールドをfinalと宣言し、変更可能な入出力から保護する必要があります。
ガイドライン6-2で述べたように、不変オブジェクトの構築は、ビルダー（Effective Java [6]を参照）を提供することで容易になります。
```

## Guideline 6-2 / MUTABLE-2: Create copies of mutable output values

mutableなオブジェクトを返す場合は、deep copyを返せということか。
これがどうセキュリティに関わるかはわからん。

```
メソッドが内部のミュータブルオブジェクトへの参照を返す場合、クライアントコードがインスタンスの内部状態を変更する可能性があります。
状態を共有する意図がない限り、ミュータブルオブジェクトをコピーし、そのコピーを返します。

信頼できる mutable オブジェクトのコピーを作成するには、コピーコンストラクタまたは clone メソッドを呼び出します。
```

```java
public class CopyOutput {
    private final java.util.Date date;
    ...
    public java.util.Date getDate() {
        return (java.util.Date)date.clone();
    }
}
```

## Guideline 6-3 / MUTABLE-3: Create safe copies of mutable and subclassable input values

ミュータブルな値のコピーを渡すときは気をつける。
また、finalではないクラスをインプットにするときは気をつける。

難しい。。

```
Mutable（変更可能）なオブジェクトは、メソッドやコンストラクタの呼び出し後、あるいは呼び出し中にも変更される可能性があります。
サブクラス化可能な型は、正しくない、矛盾した、または悪意のある動作をする可能性があります。
メソッドが変更可能な入力パラメータを直接操作するように指定されていない場合は、その入力のコピーを作成し、そのコピーに対してメソッドロジックを実行します。
実際、入力がフィールドに格納されている場合、呼び出し元は包含するクラスの競合状態を利用することができます。
たとえば、TOCTOU（time-of-check, time-of-use inconsistency）[7]は、変更可能な入力がSecurityManagerのチェック時には1つの値を含んでいるが、後でその入力が使用されるときには異なる値を含んでいる場合に悪用できます。

信頼できないミュータブルオブジェクトのコピーを作成するには、コピーコンストラクタまたは作成メソッドを呼び出します。
```

```java
public final class CopyMutableInput {
    private final Date date;

    // java.util.Date is mutable
    public CopyMutableInput(Date date) {
        // create copy
        this.date = new Date(date.getTime());
    }
}
```

```
まれに、インスタンス自体のコピー・メソッドを呼び出しても安全な場合があります。
例えば、java.net.HttpCookie は mutable ですが final であり、そのインスタンスのコピーを取得するためのパブリックな clone メソッドが用意されています。
```

```java
public final class CopyCookie {

    // java.net.HttpCookie is mutable
    public void copyMutableInput(HttpCookie cookie) {
        // create copy
        cookie = (HttpCookie)cookie.clone(); // HttpCookie is final

        // perform logic (including relevant security checks)
        // on copy
        doLogic(cookie);
    }
}
```

```
HttpCookie.cloneは悪意のある実装ではオーバーライドできないので、呼び出しても安全です。
Dateもパブリックなcloneメソッドを提供していますが、このメソッドはオーバーライド可能なので、Dateオブジェクトが信頼できるソースからのものである場合にのみ信頼できます。
java.io.Fileなどの一部のクラスは、不変であるように見えてもサブクラス化が可能です。

このガイドラインは、対象となるオブジェクトをラップするように設計されたクラスには適用されません。
例えば、java.util.Arrays.asListは、コピーせずに、与えられた配列を直接操作します。

コレクションなどでは、入力オブジェクトのコピーコンストラクタやクローンメソッドで返されるものよりも深いコピーをメソッドが必要とする場合があります。
たとえば、コレクションで ArrayList をインスタンス化すると、元のコレクション インスタンスの浅いコピーが生成されます。
コピーとオリジナルの両方が、同じ要素への参照を共有します。
要素が変更可能な場合は、その要素に対するディープコピーが必要です。
```

```java
// String is immutable.
public void shallowCopy(Collection<String> strs) {
    strs = new ArrayList<>(strs);
    doLogic(strs);
}
// Date is mutable.
public void deepCopy(Collection<Date> dates) {
    Collection<Date> datesCopy =
                           new ArrayList<>(dates.size());
    for (Date date : dates) {
        datesCopy.add(new java.util.Date(date.getTime()));
    }
    doLogic(datesCopy);
}
```

```
コンストラクタは、フィールドに値を割り当てる前に、ディープコピーを完了させる必要があります。
オブジェクトは、たとえ短時間であっても、信頼できないデータを参照している状態であってはなりません。
さらに、フィールドに割り当てられたオブジェクトは、安全でない公開の危険性があるため、信頼できないデータを参照してはいけません。
```

## Guideline 6-4 / MUTABLE-4: Support copy functionality for a mutable class

イミュータブルなクラスを設計するときは、安全にコピーを作成する手段を提供せよ。

```
変更可能な値のクラスを設計するときは、そのインスタンスの安全なコピーを作成する手段を提供してください。
これにより、そのクラスのインスタンスを他のクラスのメソッドに安全に渡したり返したりすることができます（ガイドライン6-2、ガイドライン6-3参照）。
この機能は、静的な生成メソッド、コピーコンストラクタ、またはパブリックなコピーメソッドの実装（finalクラスの場合）によって提供されます。

もしクラスがfinalで、コピーを取得するためのアクセス可能なメソッドが提供されていない場合、呼び出し側は手動でコピーを行うことができます。
この方法では、そのクラスのインスタンスから状態を取得し、取得した状態で新しいインスタンスを作成します。
このプロセスで取得された Mutable State も、必要に応じてコピーされなければなりません。
このような手動のコピーを行うと、壊れやすくなります。
クラスが進化して追加の状態を含むようになった場合、手動コピーにその状態が含まれない可能性があります。

java.lang.Cloneable のメカニズムは問題があるので、使用すべきではありません。
実装クラスは、すべての変更可能なフィールドを明示的にコピーしなければならず、非常にエラーが発生しやすくなります。
コピーされたフィールドは最終的なものではありません。
フィールドのコピーが完了する前に、クローンオブジェクトが利用可能になる可能性があります。
最終的でないクラスでは、Object.clone は悪意のあるサブクラスの新しいインスタンスを作成します。
Cloneableを実装することは、実装の詳細ですが、クラスのパブリック・インターフェースに表示されます。
```

## Guideline 6-5 / MUTABLE-5: Do not trust identity equality when overridable on input reference objects

finalではないクラスの等価性について、気をつける。
`IdentityHashMap`みたいなのを使えば、参照で比較するようになる。

```
オーバーライド可能なメソッドは、期待通りの動作をしない場合があります。

例えば、同一性保持の動作を期待してObject.equalsをオーバーライドした場合、異なるオブジェクトに対してtrueを返すことがあります。
特にMapのキーとして使用されている場合、あるオブジェクトが、アクセスできないはずの別のオブジェクトとして自分を偽ることができるかもしれません。

可能であれば、IdentityHashMapのような、同一性等価を強制するコレクション実装を使用してください。
```

```java
private final Map<Window,Extra> extras = new IdentityHashMap<>();

public void op(Window window) {
    // Window.equals may be overridden,
    // but safe as we are using IdentityHashMap
    Extra extra = extras.get(window);
}
```

```
そのようなコレクションがない場合は、敵がアクセスできないパッケージの秘密鍵を使用してください。
```

```java
public class Window {
    /* pp */ class PrivateKey {
        // Optionally, refer to real object.
        /* pp */ Window getWindow() {
            return Window.this;
        }
    }
    /* pp */ final PrivateKey privateKey = new PrivateKey();

    private final Map<Window.PrivateKey,Extra> extras =
                                     new WeakHashMap<>();
    ...
}

public class WindowOps {
    public void op(Window window) {
        // Window.equals may be overridden,
        // but safe as we don't use it.
        Extra extra = extras.get(window.privateKey);
        ...
    }
}
```

## Guideline 6-6 / MUTABLE-6: Treat passing input to untrusted object as output

信頼できないオブジェクトにオブジェクトを渡す場合も、適切なコピー作成をすべし。

```
出力オブジェクトに関する上記のガイドラインは、信頼されていないオブジェクトに渡される場合にも適用されます。
適切なコピーを適用する必要があります。
```

```java
private final byte[] data;

public void writeTo(OutputStream out) throws IOException {
    // Copy (clone) private mutable data before sending.
    out.write(data.clone());
}
```

```
よくあるケースですが、発見が難しいのが、入力オブジェクトがキーとして使用されている場合です。
コレクションで等式を使用すると、挿入時または挿入後に他の要素が悪意のある入力オブジェクトにさらされる可能性があります。
```

## Guideline 6-7 / MUTABLE-7: Treat output from untrusted object as input

```
入力オブジェクトに関する上記のガイドラインは、信頼されていないオブジェクトから返された場合にも適用されます。
適切なコピーと検証を適用する必要があります。
```

```java
private final Date start;
private Date end;

public void endWith(Event event) throws IOException {
    Date end = new Date(event.getDate().getTime());
    if (end.before(start)) {
        throw new IllegalArgumentException("...");
    }
    this.end = end;
}
```

## Guideline 6-8 / MUTABLE-8: Define wrapper methods around modifiable internal state

ラップしたセッターを使っている。

```
クラスの内部にある状態がパブリックにアクセスでき、変更可能でなければならない場合、プライベート・フィールドを宣言し、パブリック・ラッパー・メソッドを介してアクセスできるようにします。
サブクラスからしかアクセスできない状態であれば、プライベート・フィールドを宣言し、保護されたラッパー・メソッドを介してアクセスできるようにします。
ラッパー・メソッドを使用すると、新しい値を設定する前に入力の検証を行うことができます。
```

```java
public final class WrappedState {
    // private immutable object
    private String state;

    // wrapper method
    public String getState() {
        return state;
    }

    // wrapper method
    public void setState(final String newState) {
        this.state = requireValidation(newState);
    }

    private static String requireValidation(final String state) {
        if (...) {
            throw new IllegalArgumentException("...");
        }
        return state;
    }
}
```

```
ガイドライン6-2にあるように、内部状態が可変型であれば、getStateとsetStateに追加の防御的コピーを作成する。

可能であれば、単に内部の実装を公開するのではなく、クラスのインターフェイスの文脈で意味のある操作のためのメソッドを作る。
```

## Guideline 6-9 / MUTABLE-9: Make public static fields final

public な static field は常にfinalせよ。

```
呼び出し側は、ファイナルではないパブリックなスタティック・フィールドに自明にアクセスしたり変更したりすることができます。
アクセスや変更を防ぐことはできませんし、新しく設定された値を検証することもできません。
サブクラス化可能な型を持つフィールドは、悪意のある実装を持つオブジェクトに設定される可能性があります。
パブリックなスタティック・フィールドは常にfinalとして宣言してください。
```

```java
public class Files {
    public static final String separator = "/";
    public static final String pathSeparator = ":";
}
```

## Guideline 6-10 / MUTABLE-10: Ensure public static final field values are constants

public static finalなフィールドには変更不可能なものしか入れない。

変更不可能なリストを作るメソッドとして、ListならList.ofを使って作ったものはImmutable

```
パブリック・スタティック・フィールドには、不変または変更不可能な値のみを格納すべきです。
多くの型は変更可能であり、特に配列やコレクションは見落とされがちです。
mutatorメソッドを持たない型のフィールドに格納された mutableオブジェクトは、ランタイムの型にキャストバックすることができます。
Enumの値は絶対に変更できません。

次の例では、names はリストが変更されるのを防ぐために、リストの変更不可能なビューを公開しています。
```

```java
import static java.util.Arrays.asList;
import static java.util.Collections.unmodifiableList;
...
public static final List<String> names = unmodifiableList(asList(
    "Fred", "Jim", "Sheila"
));
```

```
Java 9で追加されたAPIメソッドのof()とofEntries()も、変更不可能なコレクションの作成に使用できます。
```

```java
public static final List <String> names = 
                                        List.of("Fred", "Jim", "Sheila");
```

```
of/ofEntries APIメソッドは変更不可能なコレクションを返すのに対し、Collections.unmodifiable... API メソッド (unmodifiableCollection(), unmodifiableList(), unmodifiableMap() など) は、コレクションに対する変更不可能なビューを返します。
変更不可能なビューを使ってコレクションを変更することはできませんが、基礎となるコレクションを直接参照して変更することはできます。
ただし、of/ofEntries APIメソッドが返すコレクションは、実際には変更できません。
コレクションに対して変更不可能なビューを返すメソッドの完全なリストについては、java.util.Collections API ドキュメントを参照してください。

Java 10 で追加された copyOf メソッドは、既存のコレクションの変更不可能なコピーを作成するために使用できます。
変更不可能なビューとは異なり、元のコレクションが変更されても、その変更は変更不可能なコピーには影響しません。
同様に、Java 10以降のtoUnmodifiableList()、toUnmodifiableSet()、toUnmodifiableMap()の各コレクターは、ストリームの要素から変更不可能なコレクションを作成するために使用できます。

ガイドライン6-9にあるように、protected static fieldにはpublicなものと同じ問題があります。
```

## Guideline 6-11 / MUTABLE-11: Do not expose mutable statics

mutable なstaticな値は晒してはいけない。

```
プライベートなスタティックは、限られた方法ではあるが、パブリックなインターフェイスを通じて容易に公開される（ガイドライン6-2、6-6参照）。
ミュータブルなスタティックは、関係のないコード間でも動作を変えることがある。
安全なコードを保証するために、プライベート・スタティックはパブリックであるかのように扱われるべきである。
スタティックをシングルトンとして公開するためのボイラープレートを追加しても、これらの問題は解決しない。

Mutable staticsは、不変のフライウェイト値のキャッシュとして使用することができる。
Mutableオブジェクトは決してスタティックにキャッシュされるべきではない。
ミュータブル・オブジェクトのインスタンス・プーリングであっても、細心の注意を払って扱うべきである。

一部の可変型スタティックは、状態を更新するためにセキュリティ権限を必要とする。
更新された値はグローバルに表示されます。
そのため、突然変異は細心の注意を払って行う必要があります。
グローバルな状態を更新するメソッドや、セキュリティチェックを行った上で更新する機能を提供するメソッドには、以下のようなものがあります。
```

```java
java.lang.ClassLoader.getSystemClassLoader 
java.lang.System.clearProperty
java.lang.System.getProperties 
java.lang.System.setErr 
java.lang.System.setIn 
java.lang.System.setOut 
java.lang.System.setProperties 
java.lang.System.setProperty 
java.lang.System.setSecurityManager 
java.net.Authenticator.setDefault 
java.net.CookieHandler.getDefault 
java.net.CookieHandler.setDefault 
java.net.Datagram.setDatagramSocketImplFactory 
java.net.HttpURLConnection.setFollowRedirects 
java.net.ProxySelector.setDefault
java.net.ResponseCache.getDefault 
java.net.ResponseCache.setDefault 
java.net.ServerSocket.setSocketFactory 
java.net.Socket.setSocketImplFactory
java.net.URL.setURLStreamHandlerFactory 
java.net.URLConnection.setContentHandlerFactory 
java.net.URLConnection.setFileNameMap 
java.rmi.server.RMISocketFactory.setFailureHandler 
java.rmi.server.RMISocketFactory.setSocketFactory 
java.rmi.activation.ActivationGroup.createGroup  (deprecated)
java.rmi.activation.ActivationGroup.setSystem (deprecated) 
java.rmi.server.RMIClassLoader.getDefaultProviderInstance 
java.security.Policy.setPolicy 
java.sql.DriverManager.setLogStream (deprecated) 
java.sql.DriverManager.setLogWriter 
java.util.Locale.setDefault 
java.util.TimeZone.setDefault 
javax.naming.spi.NamingManager.setInitialContextFactoryBuilder 
javax.naming.spi.NamingManager.setObjectFactoryBuilder 
javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier 
javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory 
javax.net.ssl.SSLContext.setDefault 
javax.security.auth.login.Configuration.setConfiguration 
javax.security.auth.login.Policy.setPolicy
```

```
Java PlugIn と Java WebStart は、特定のグローバル状態を AppContext1 内に隔離します。
多くの場合、この状態にアクセスするためのセキュリティ権限は必要ありませんので、（PlugIn と WebStart 内の Same Origin Policy を除いて）信頼することはできません。
セキュリティチェックがあるとはいえ、この状態はコンテキスト内に留まることが意図されています。
したがって、AppContext から直接または間接的に取得したオブジェクトは、共有クラス・ローダ内のクラスのプレーンなスタティックなど、他のバリエーションのグローバルには保存しないでください。
アプリケーションに代わって AppContext を直接または間接的に使用するライブラリ コードは、明確に文書化する必要があります。
AppContext のユーザーは以下の通りです。
```

```java
Extensively within AWT
Extensively within Swing
Extensively within JavaBeans Long Term Persistence
java.beans.Beans.setDesignTime
java.beans.Beans.setGuiAvailable 
java.beans.Introspector.getBeanInfo 
java.beans.PropertyEditorFinder.registerEditor
java.beans.PropertyEditorFinder.setEdiorSearchPath 
javax.imageio.ImageIO.createImageInputStream 
javax.imageio.ImageIO.createImageOutputStream 
javax.imageio.ImageIO.getUseCache
javax.imageio.ImageIO.setCacheDirectory
javax.imageio.ImageIO.setUseCache 
javax.print.StreamPrintServiceFactory.lookupStreamPrintServices
javax.print.PrintServiceLookup.lookupDefaultPrintService 
javax.print.PrintServiceLookup.lookupMultiDocPrintServices
javax.print.PrintServiceLookup.lookupPrintServices
javax.print.PrintServiceLookup.registerService 
javax.print.PrintServiceLookup.registerServiceProvider
```

## Guideline 6-12 / MUTABLE-12: Do not expose modifiable collections

collectionに関してはimmutableなものがJava9以降とかだとあるのでそれ使う。

コレクション内部にmutableなオブジェクトがある場合は、deep copyを生成する必要がある。

```
パブリック変数やgetメソッドでコレクションを公開しているクラスは、呼び出したクラスがコレクションの内容を変更できるという副作用が発生する可能性があります。
開発者は、セキュリティ認証や内部状態に関連するコレクションの読み取り専用のコピーを公開することを検討する必要があります。

コレクションオブジェクトを参照しているフィールドの変更は、finalを宣言することで防ぐことができますが（ガイドライン6-9参照）、コレクション自体は個別に変更できないようにしなければなりません。
変更不可能なコレクションは、of/ofEntries APIメソッド（Java 9以降で利用可能）、またはcopyOf APIメソッド（Java 10以降で利用可能）を使って作成できます。
コレクションの変更不可能なビューは、Collections.unmodifiable...APIを使って取得できます。
APIを使用して取得できます。

以下の例では、変更不可能なコレクションをSIMPLEで公開し、変更可能なコレクションに対する変更不可能なビューをITEMSとsomethingStatefulで公開しています。
```

```java
public class Example {
    public static final List<String> SIMPLE = 
        List.of("first", "second", "...");
    public static final Map<String, String> ITEMS;

    static {
        //For complex items requiring construction
        Map<String, String> temp = new HashMap<>(2);
        temp.put("first", "The first object");
        temp.put("second", "Another object");
        ITEMS = Collections.unmodifiableMap(temp);
    }
    
    private List<String> somethingStateful =
                            new ArrayList<>();
    public List<String> getSomethingStateful() {
            return  Collections.unmodifiableList(
                                somethingStateful);
    }
}
```

```
パブリック変数や get メソッドで公開されている配列にも同様の問題があります。
java.util.Arrays.asList()は、内部の配列を公開する際には使用しないでください。

前述の例では、すべてのコレクションに不変のオブジェクトが含まれていることに注意してください。
コレクションや配列に変更可能なオブジェクトが含まれている場合は、代わりにそのディープコピーを公開する必要があります。
セーフコピーの作成については、ガイドライン6-2および6-3を参照してください。
```

---

# 7 Object Construction

オブジェクト組み立て中の話？ここはライブラリとか、他から使われることを意図した内容になっている。

```
建設中の物体は、存在していてもすぐには使えない厄介な段階にあります。そのため、通常の方法に加えて、いくつかの困難があります。
```

## Guideline 7-1 / OBJECT-1: Avoid exposing constructors of sensitive classes

センシティブなクラスについては、コンストラクタを晒さないようにする。
(ライブラリ提供者側の話かな？)

```
コンストラクタを公開しなければ、クラスの構築をより慎重に制御することができます。
コンストラクタを公開する代わりに、静的なファクトリメソッドを定義します。継承ではなく委譲による拡張性をサポートします。
シリアライズやクローンによる暗黙のコンストラクタも避けるべきです。
```

## Guideline 7-2 / OBJECT-2: Prevent the unauthorized construction of sensitive classes

```
既存の API がセキュリティセンシティブなコンストラクタを公開している場合、インスタンスの作成を制限する。
セキュリティセンシティブなクラスは、呼び出し側がSecurityManagerのアクセスコントロールを変更または回避することを可能にします。
例えば、ClassLoaderのインスタンスは、任意のセキュリティパーミッションを持つクラスを定義する力を持っています。

信頼されていないコードがクラスをインスタンス化することを制限するために、そのクラスがインスタンス化できるすべてのポイントでSecurityManagerチェックを実施します。
特に、パブリックおよびプロテクトされたコンストラクタの先頭でチェックを行います。
コンストラクタの代わりにパブリック・スタティック・ファクトリ・メソッドを宣言しているクラスでは、各ファクトリ・メソッドの最初にチェックを行います。
また、コンストラクタを使用せずにクラスのインスタンスを作成できる箇所にもチェックを入れます。
具体的には、シリアル化可能なクラスの readObject または readObjectNoData メソッドや、クローン化可能なクラスの clone メソッドの内部でチェックを行います。
```

## Guideline 7-3 / OBJECT-3: Defend against partially initialized instances of non-final classes

ClassLoaderのコンストラクタは、途中でセキュリティチェックとか入っている。  
これでClassLoaderを継承したクラスで悪さをさせないようにしているのかな？

```
ノンファイナルクラスのコンストラクタが例外を投げると、攻撃者はそのクラスの部分的に初期化されたインスタンスへのアクセスを試みることができます。
ノンファイナルクラスは、コンストラクタが正常に完了するまで完全に使用できないようにします。

JDK 6 以降では、Object コンストラクタが完了する前に例外を発生させることで、サブクラス化可能なクラスの構築を防ぐことができます。
そのためには、this()またはsuper()の呼び出しで評価される式でチェックを行います。
```

```java
// non-final java.lang.ClassLoader
public abstract class ClassLoader {
    protected ClassLoader() {
        this(securityManagerCheck());
    }
    private ClassLoader(Void ignored) {
        // ... continue initialization ...
    }
    private static Void securityManagerCheck() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkCreateClassLoader();
        }
        return null;
    }
}
```

```
古いリリースとの互換性のために、初期化されたフラグを使用するという解決策があります。
コンストラクタの最後の処理としてフラグを設定してから正常に戻ります。
機密性の高い操作へのゲートウェイを提供するすべてのメソッドは、処理を進める前にこのフラグを参照する必要があります。
```

```java
public abstract class ClassLoader {

    private volatile boolean initialized;

    protected ClassLoader() {
        // permission needed to create ClassLoader
        securityManagerCheck();
        init();

        // Last action of constructor.
        this.initialized = true;
    }
    protected final Class defineClass(...) {
        checkInitialized();

        // regular logic follows
        ...
    }

    private void checkInitialized() {
        if (!initialized) {
            throw new SecurityException(
                "NonFinal not initialized"
            );
        }
    }
}
```

```
さらに、このようなクラスをセキュリティに配慮して使用する場合は、初期化フラグの状態をチェックする必要があります。
ClassLoaderを構築する場合は、その親クラスローダーが初期化されているかどうかをチェックする必要があります。

非最終的なクラスの部分的に初期化されたインスタンスは、ファイナライザ攻撃によってアクセスすることができます。
攻撃者は、サブクラスの保護された finalize メソッドをオーバーライドし、そのサブクラスの新しいインスタンスを作成しようとします。
この試みは失敗しますが（上記の例では、ClassLoader のコンストラクタにおける SecurityManager のチェックでセキュリティ例外が発生しています）、攻撃者は例外を無視して、仮想マシンが部分的に初期化されたオブジェクトのファイナライズを実行するのを待ちます。
その際、悪意のある finalize メソッドの実装が呼び出され、攻撃者は finalize されるオブジェクトへの参照である this にアクセスできます。
オブジェクトは部分的にしか初期化されていませんが、攻撃者はそのオブジェクトのメソッドを呼び出すことができるため、SecurityManagerのチェックを回避することができます。
初期化フラグは、部分的に初期化されたオブジェクトへのアクセスを妨げるものではありませんが、そのオブジェクトのメソッドが攻撃者にとって有益なことをするのを妨げます。

初期化フラグの使用は、安全ではありますが、面倒なものです。
パブリックな非最終クラスのすべてのフィールドが、オブジェクトの初期化が正常に完了するまで、安全な値（nullなど）を含むようにするだけで、セキュリティに敏感ではないクラスでは合理的な代替手段となります。

より強固な方法として、「実装へのポインタ」（または「pimpl」）を使用する方法があります。
クラスのコアは非公開のクラスに移され、インターフェースクラスがメソッドコールを転送します。
クラスが完全に初期化される前に使用しようとすると、NullPointerExceptionが発生します。
この方法は、クローン攻撃やデシリアライズ攻撃にも有効です。
```

```java
public abstract class ClassLoader {

    private final ClassLoaderImpl impl;

    protected ClassLoader() {
        this.impl = new ClassLoaderImpl();
    }
    protected final Class defineClass(...) {
        return impl.defineClass(...);
    }
}

/* pp */ class ClassLoaderImpl {
    /* pp */ ClassLoaderImpl() {
        // permission needed to create ClassLoader
        securityManagerCheck();
        init();
    }

    /* pp */ Class defineClass(...) {
        // regular logic follows
        ...
    }
}
```

## Guideline 7-4 / OBJECT-4: Prevent constructors from calling methods that can be overridden

オーバーライド可能なメソッドをコンストラクタの中で呼んではならない。

```
オーバーライド可能なメソッドを呼び出すコンストラクタは、オブジェクトが完全に初期化される前に、攻撃者にthis（構築中のオブジェクト）への参照を与えてしまいます。
同様に、オーバーライド可能なメソッドを呼び出す clone、readObject、または readObjectNoData メソッドも同様の可能性があります。
readObjectメソッドは通常、オーバーライド可能なメソッドであるjava.io.ObjectInputStream.defaultReadObjectを呼び出します。
```

## Guideline 7-5 / OBJECT-5: Defend against cloning of non-final classes

うーんむずい。

```
末端ではないクラスは、java.lang.Cloneableを実装したクラスによってサブクラス化されることがあります。
その結果、敵が作成したインスタンスに限りますが、基底クラスが不意にクローン化されることがあります。
クローンは浅いコピーになります。
双子は参照されるオブジェクトを共有しますが、異なるフィールドと別々の固有ロックを持っています。
ガイドライン7-3の "実装へのポインタ "のアプローチは良い防御策となります。
```

# 8 Serialization and Deserialization

信頼できないデータのデシリアライズはしないこと。

シリアライズにしても、デシリアライズにしても、ちゃんとしたライブラリを使うのがいいだなと思いました。

Jacksonでもやらかしたりはするらしい。
https://github.com/SecureSkyTechnology/study-struts2-s2-054_055-jackson-cve-2017-7525_cve-2017-15095

```
Java Serializationは、Java言語のフィールド・アクセス・コントロール・メカニズムを回避したクラスへのインターフェースを提供します。そのため、シリアライズとデシリアライズの実行には注意が必要です。
さらに、信頼できないデータのデシリアライズは可能な限り避けるべきであり、避けられない場合は慎重に実行する必要があります（詳細は8-6を参照）。

このセクションでは、Javaで実行されるシリアル化とデシリアル化について説明します。
これらのガイドラインの一部は、サードパーティのライブラリが提供する他のシリアライズ機能にも関連していますが、ドキュメントを参照し、サードパーティのコードに固有のベストプラクティスを利用することも重要です。
サードパーティ・コードのセキュリティに関する注意点については、ガイドライン0-8を参照してください。
```

## Guideline 8-1 / SERIAL-1: Avoid serialization for security-sensitive classes


```
シリアル化できないセキュリティセンシティブなクラスには、このセクションで説明するような問題はありません。
クラスをシリアライズ可能にすると、そのクラスのすべてのフィールドに対するパブリック・インターフェースが効果的に作成されます。
また、シリアル化することで、クラスに隠れたパブリックコンストラクタが追加され、オブジェクトの構築を制限しようとする際に考慮する必要があります。

同様に、ラムダもシリアライズ可能にする前に精査する必要があります。
機能的なインターフェイスは、何が公開されるかを十分に考慮せずにシリアライズ可能にすべきではありません。

また、シリアル化可能なクラスをサブクラス化したり、シリアル化可能なインターフェイスを実装したりして、意図せずにセキュリティセンシティブなクラスをシリアル化しないようにすることも重要です。
```

## Guideline 8-2 / SERIAL-2: Guard sensitive data during serialization

シリアル化したものはJava言語のアクセス制御は効かない。  

これのシリアライズの章で書いてあることを守っていく感じかしら。
https://www.jpcert.or.jp/java-rules/ser00-j.html

```
オブジェクトがシリアル化されると、Java言語のアクセス制御が効かなくなるため、攻撃者はシリアル化されたバイトストリームを解析することで、オブジェクトのプライベートフィールドにアクセスできてしまいます。そのため、シリアル化可能なクラスで機密データをシリアル化しないでください。

シリアライザブルクラスでセンシティブなフィールドを扱うためのアプローチは以下の通りです。

- センシティブなフィールドを transient として宣言する
- serialPersistentFields 配列フィールドを適切に定義する。
- writeObjectを実装し、ObjectOutputStream.putFieldを選択的に使用する。
- writeReplaceを実装して、インスタンスをシリアルプロキシで置き換える
- Externalizableインターフェースの実装
```

## Guideline 8-3 / SERIAL-3: View deserialization the same as object construction

```
デシリアライズは、クラスのコンストラクタを呼び出さずに、そのクラスの新しいインスタンスを作成します。
そのため、デシリアライズは通常のコンストラクタのように動作するように設計する必要があります。

デフォルトのデシリアライゼーションとObjectInputStream.defaultReadObjectは、non-transient なフィールドに任意のオブジェクトを割り当てることができ、必ずしも戻りません。
代わりにObjectInputStream.readFieldsを使用して、フィールドへの割り当ての前にコピーを挿入します。
また、可能であれば、機密性の高いクラスをシリアル化しないようにしてください。
```

```java
public final class ByteString implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    private byte[] data;
    public ByteString(byte[] data) {
        this.data = data.clone(); // Make copy before assignment.
    }
    private void readObject(
        java.io.ObjectInputStream in
    ) throws java.io.IOException, ClassNotFoundException {
        java.io.ObjectInputStreadm.GetField fields =
            in.readFields();
        this.data = ((byte[])fields.get("data")).clone();
    }
    ...
}
```

```
readObject メソッドの実装では、コンストラクタで行うのと同じ入力検証チェックを行います。
同様に、デシリアライズ時に明示的に設定されないトランジェント フィールドを含むすべてのフィールドに、コンストラクタで割り当てられたものと同じデフォルト値を割り当てます。

さらに、デシリアライズされたミュータブル オブジェクトのコピーを作成してから、readObject 実装の内部フィールドに割り当てます。
これにより、敵対的なコードがバイトストリームをデシリアライズする際に、デシリアライズされたコンテナオブジェクト内のミュータブルオブジェクトへの参照を攻撃者に与えるように特別に細工されていることを防御します。
```

```java
public final class Nonnegative implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    private int value;
    public Nonnegative(int value) {
        // Make check before assignment.
        this.data = nonnegative(value);
    }
    private static int nonnegative(int value) {
        if (value < 0) {
            throw new IllegalArgumentException(value +
                                               " is negative");
        }
        return value;
    }
    private void readObject(
        java.io.ObjectInputStream in
    ) throws java.io.IOException, ClassNotFoundException {
        java.io.ObjectInputStreadm.GetField fields =
            in.readFields();
        this.value = nonnegative(field.get(value, 0));
    }
    ...
}
```

```
攻撃者は、部分的に初期化された（デシリアライズされた）オブジェクトを悪用するために、敵対的なストリームを作ることもできます。
シリアライズ可能なクラスは、デシリアライズが正常に完了するまで完全に使用できないようにします。
例えば、初期化されたフラグを使用します。
このフラグをプライベートな一時的フィールドとして宣言し、正常に復帰する直前に readObject または readObjectNoData メソッド（およびコンストラクタ）でのみ設定します。
クラス内のすべてのパブリックおよびプロテクトメソッドは、通常のロジックを実行する前に、初期化フラグを参照する必要があります。
前述のとおり、初期化フラグの使用は面倒です。
デシリアライズが正常に完了するまで、すべてのフィールドに安全な値 (null など) が含まれていることを確認するだけでも、合理的な代替手段となります。

セキュリティが重視されるシリアライザブルクラスは、オブジェクトのフィールドタイプがfinalクラスであることを保証するか、デシリアライズ時に正確なタイプを保証するために特別な検証を行う必要があります。
そうしないと、攻撃者のコードは、予想外の動作をする悪意のあるサブクラスをフィールドに投入する可能性があります。
例えば、クラスが java.util.List 型のフィールドを持っている場合、攻撃者は矛盾したデータを返す実装でフィールドを生成する可能性があります。
```

## Guideline 8-4 / SERIAL-4: Duplicate the SecurityManager checks enforced in a class during serialization and deserialization

```
攻撃者がシリアライズまたはデシリアライズを使用して、クラスで実施されているSecurityManagerチェックを回避することを防ぎます。
具体的には、シリアル化可能なクラスがコンストラクタでSecurityManagerのチェックを実施する場合、readObjectまたはreadObjectNoDataメソッドの実装でも同じチェックを実施します。
そうしないと、デシリアライズによってチェックなしでクラスのインスタンスが作成されてしまいます。
```

```java
public final class SensitiveClass implements java.io.Serializable {
    public SensitiveClass() {
        // permission needed to instantiate SensitiveClass
        securityManagerCheck();

        // regular logic follows
    }

    // implement readObject to enforce checks
    //   during deserialization
    private void readObject(java.io.ObjectInputStream in) {
        // duplicate check from constructor
        securityManagerCheck();

        // regular logic follows
    }
}
```

```
シリアル化可能なクラスが、呼び出し元による内部状態の変更を可能にし（例えば、パブリック・メソッドを介して）、その変更がSecurityManagerのチェックでガードされている場合、readObjectメソッドの実装で同じチェックを実施してください。
そうしないと、攻撃者はデシリアライズを利用して、チェックを通過せずに、変更された状態のオブジェクトの別のインスタンスを作成することができます。
```

```java
public final class SecureName implements java.io.Serializable {

    // private internal state
    private String name;

    private static final String DEFAULT = "DEFAULT";

    public SecureName() {
        // initialize name to default value
        name = DEFAULT;
    }

    // allow callers to modify private internal state
    public void setName(String name) {
        if (name!=null ? name.equals(this.name)
                       : (this.name == null)) {
            // no change - do nothing
            return;
        } else {
            // permission needed to modify name
            securityManagerCheck();

            inputValidation(name);

            this.name = name;
        }
    }

    // implement readObject to enforce checks
    //   during deserialization
    private void readObject(java.io.ObjectInputStream in) {
        java.io.ObjectInputStream.GetField fields =
            in.readFields();
        String name = (String) fields.get("name", DEFAULT);

        // if the deserialized name does not match the default
        //   value normally created at construction time,
        //   duplicate checks


        if (!DEFAULT.equals(name)) {
            securityManagerCheck();
            inputValidation(name);
        }
        this.name = name;
    }

}
```

```
シリアル化可能なクラスが、呼び出し元から内部状態を取得できるようにし、その取得が機密データの漏洩を防ぐためにSecurityManagerのチェックでガードされている場合は、writeObjectメソッドの実装でも同じチェックを実施してください。
そうしないと、攻撃者はオブジェクトをシリアル化してチェックを回避し、シリアル化されたバイトストリームを読むだけで内部状態にアクセスできてしまいます。
```

```java
public final class SecureValue implements java.io.Serializable {
    // sensitive internal state
    private String value;

    // public method to allow callers to retrieve internal state

    public String getValue() {
        // permission needed to get value
        securityManagerCheck();

        return value;
    }


    // implement writeObject to enforce checks 
    //  during serialization
    private void writeObject(java.io.ObjectOutputStream out) {
        // duplicate check from getValue()
        securityManagerCheck();
        out.writeObject(value);
    }
}
```

## Guideline 8-5 / SERIAL-5: Understand the security permissions given to serialization and deserialization

```
デシリアライズに適したパーミッションを注意深くチェックする必要があります。
また、信頼されていないデータのデシリアライズは、可能な限り避けるべきです。

フルパーミッションでシリアライズすると、writeObjectメソッドのパーミッションチェックを回避することができます。
たとえば、java.security.GuardedObject は、対象となるオブジェクトをシリアル化する前にガードをチェックします。
フルパーミッションの場合、このガードが回避され、オブジェクトからのデータが（オブジェクト自体ではなく）攻撃者に利用可能になります。

デシリアライズはより重要です。
readObjectの実装の中には、セキュリティチェックを行おうとするものが多数ありますが、これはフルパーミッションが与えられればパスします。
さらに、シリアル化できないセキュリティセンシティブなサブクラス化可能なクラスの中には、例えばClassLoaderのように引数なしのコンストラクタを持つものがあります。
ClassLoaderをサブクラス化した悪意のあるシリアル化可能なクラスを考えてみましょう。
シリアル化解除の際、シリアル化メソッドはコンストラクタ自体を呼び出し、サブクラスの任意の readObject を実行します。
ClassLoader のコンストラクタが呼び出されるとき、スタック上に権限のないコードは存在しないため、セキュリティチェックはパスします。
したがって、データに適さないパーミッションでデシリアライズしてはいけません。
代わりに、データは必要最小限の権限でデシリアライズされるべきです。
```

## Guideline 8-6 / SERIAL-6: Filter untrusted serial data

```
シリアライゼーション・フィルタリングは、JDK 9で導入された新機能で、オブジェクト・シリアライゼーションを使用する際のセキュリティと堅牢性の両方を向上させます。
セキュリティ・ガイドラインでは、外部ソースからの入力を使用前に検証することが一貫して求められています。
シリアル化フィルタリングは、デシリアライズされる前にクラスを検証するメカニズムを提供します。
フィルタは、アプリケーションを変更することなく、オブジェクトのシリアル化のほとんどの用途に適用するように構成することができます。
フィルタは、システム・プロパティで設定するか、セキュリティ・プロパティのオーバーライド・メカニズムを使って設定します。
典型的な使用例は、Javaランタイムを危険にさらす可能性があると認識されているクラスのブロックリストを作成することです。
既知の安全なクラスの許可リストを使用することも簡単です（より強力なセキュリティのためには、ブロックリストのアプローチよりも好ましい）。
特定のクラスをブロックするアプローチをとる場合、ブロックされたクラスのサブクラスがまだデシリアライズ可能であることを考慮することが重要です。
フィルタメカニズムにより、オブジェクトをシリアル化するクライアントは、より簡単に入力を検証することができます。
より細かいアプローチとして、ObjectInputFilter APIを使用すると、アプリケーションはObjectInputStreamの各用途に特化したより細かい制御を統合することができます。

RMIは、エクスポートされたオブジェクトのリモート呼び出しを保護するためのシリアル化フィルタの設定をサポートしています。
RMIレジストリとRMI分散型ガベージコレクタは、このフィルタリングメカニズムを防御的に使用します。

設定可能なフィルターのサポートは、JDK 8u121、JDK 7u131、JDK 6u141のCPUリリースに含まれています。

詳細については、[17]および[20]を参照してください。
```

# 9 Access Control

```
Javaは主にオブジェクト・キャパシティ言語ですが、スタック・ベースのアクセス・コントロール・メカニズムを使用して、より一般的なAPIを安全に提供しています。

このセクションのガイドラインの多くは、SecurityManagerを使用してセキュリティチェックを行い、コードの権限を昇格または制限する方法について説明しています。
 なお、SecurityManagerは、サイドチャネル攻撃やRow hammerのような低レベルの問題に対する保護を提供するものではなく、また、プロセス内の完全な分離を保証するものでもありません。
別のプロセス（JVM）を使用して、信頼できないコードと機密情報を持つ信頼できるコードを分離する必要があります。
 オペレーティング・システムやコンテナから得られる低レベルの分離メカニズムを利用することも推奨されます。
```

## Guideline 9-1 / ACCESS-1: Understand how permissions are checked

```
標準的なセキュリティチェックでは、コールスタックの各フレームが必要なパーミッションを持っていることを確認します。
つまり、現在有効なパーミッションは、現在のアクセスコントロールコンテキスト内の各フレームのパーミッションの交点となります。
いずれかのフレームが許可を持っていない場合、それがスタックのどこにあるかに関わらず、現在のコンテキストはその許可を持っていません。

ライブラリを介して間接的に安全な操作を行うアプリケーションを考えてみましょう。
```

```java
package xx.lib;

public class LibClass {
    private static final String OPTIONS = "xx.lib.options";

    public static String getOptions() {
        // checked by SecurityManager
        return System.getProperty(OPTIONS);
    }
}

package yy.app;

class AppClass {
    public static void main(String[] args) {
        System.out.println(
            xx.lib.LibClass.getOptions()
        );
    }
}
```

```
許可チェックが行われると、コールスタックは以下のようになります。

        +--------------------------------+
        | java.security.AccessController |
        |   .checkPermission(Permission) |
        +--------------------------------+
        | java.lang.SecurityManager      |
        |   .checkPermission(Permission) |
        +--------------------------------+
        | java.lang.SecurityManager      |
        |   .checkPropertyAccess(String) |
        +--------------------------------+
        | java.lang.System               |
        |   .getProperty(String)         |
        +--------------------------------+
        | xx.lib.LibClass                |
        |   .getOptions()                |
        +--------------------------------+
        | yy.app.AppClass                |
        |   .main(String[])              |
        +--------------------------------+
        
上記の例では、AppClass フレームがファイルを読む権限を持っていなくても、LibClass フレームがファイルを読む権限を持っていれば、セキュリティ例外が発生します。
特権的な操作の直接の呼び出し元が完全に特権的であることは問題ではなく、どこかのスタック上に非特権的なコードがあることが問題なのです。

ライブラリ・コードが特権に関してアプリケーションから透過的に見えるようにするためには、ライブラリは少なくとも一緒に使用されるアプリケーション・コードと同じくらい寛大な権限を与えられるべきです。
このような理由から、JDKや拡張機能で出荷されるほとんどすべてのコードは完全に特権化されています。
したがって、ライブラリがアプリケーションコードに代わってセキュリティチェックされた操作を実行する際には、アプリケーションの権限を持つフレームが少なくとも1つスタック上に存在することが重要です。
```

## Guideline 9-2 / ACCESS-2: Beware of callback methods

```
コールバックメソッドは、一般的にフルパーミッションでシステムから呼び出されます。
悪意のあるコードが操作を実行するためにはスタック上にいる必要があると考えるのが妥当だと思われますが、実際にはそうではありません。
悪意のあるコードは、コールバックをセキュリティチェック済みの操作に橋渡しするオブジェクトを設定することがあります。
例えば、ユーザーの操作によってファイルシステムを操作できるファイルチューザーのダイアログボックスに、悪意のあるコードからイベントが投稿されることがあります。
また、悪意のあるコードは、ファイルチューザーを良心的なものとして偽装し、ユーザーのイベントをリダイレクトすることもできます。

コールバックは、オブジェクト指向のシステムに広く普及しています。
例えば、以下のようなものがあります。
- 静的な初期化は完全な権限で行われることが多い
- アプリケーションのメインメソッド 
- Applet/Midlet/Servletのライフサイクルイベント1 
- Runnable.run 

このように、コールバックとセキュリティに配慮した操作の橋渡しは、バグを発見したり、どこにバグがあるのかを調べたりすることが容易ではないため、特に厄介です。

コールバック型を実装する際には、ガイドライン9-6に記載されているテクニックを使ってコンテキストを転送する。
```

## Guideline 9-3 / ACCESS-3: Safely invoke java.security.AccessController.doPrivileged

```
AccessController.doPrivilegedは、SecurityManagerでチェックされた操作を行う際に、コードが独自のパーミッションを行使できるようにします。
セキュリティチェックのために、コールスタックはdoPrivilegedの呼び出し元よりも事実上切り捨てられます。
直接の呼び出し元はセキュリティチェックに含まれます。

        +--------------------------------+
        | action                         |
        |   .run                         |
        +--------------------------------+
        | java.security.AccessController |
        |   .doPrivileged                |
        +--------------------------------+
        | SomeClass                      |
        |   .someMethod                  |
        +--------------------------------+
        | OtherClass                     |
        |  .otherMethod                  |
        +--------------------------------+
        |                                |
        
上記の例では、セキュリティチェックのためにOtherClassフレームの特権が無視されています。

許可されていない呼び出し元に代わってこのような操作を不用意に行わないように、呼び出し元が提供した入力（汚染された入力）を使用してdoPrivilegedを呼び出す際には十分注意してください。
```

```java
package xx.lib;

import java.security.*;

public class LibClass {
    // System property used by library, 
    //  does not contain sensitive information
    private static final String OPTIONS = "xx.lib.options";

    public static String getOptions() {
        return AccessController.doPrivileged(
            new PrivilegedAction<String>() {
                public String run() {
                    // this is checked by SecurityManager
                    return System.getProperty(OPTIONS);
                }
            }
        );
    }
}
```

```
getOptions の実装では、ハードコードされた値を使ってシステム・プロパティを適切に取得しています。
具体的には、呼び出し側が提供した（汚染された）入力を doPrivileged に渡すことで、呼び出し側がプロパティの名前に影響を与えることはできません。

また、特権的な操作によって機密情報が漏洩しないようにすることも重要です。
doPrivilegedの戻り値が信頼されていないコードからアクセスできるようになっている場合は常に、返されたオブジェクトが機密情報を露呈していないことを確認してください。
上記の例では、getOptions がシステムプロパティの値を返していますが、そのプロパティには機密データは含まれていません。

検証された呼び出し元の入力は、doPrivilegedで安全に使用できる場合があります。
通常、入力は限られた許容範囲の値（通常はハードコードされた値）に制限する必要があります。

特権コードのセクションは、セキュリティ上の影響を理解しやすくするために、できるだけ小さくする必要があります。

慣習上、PrivilegedActionとPrivilegedExceptionActionのインスタンスは、信頼されていないコードで利用可能ですが、doPrivilegedは、呼び出し元が提供するアクションで呼び出されてはなりません。

doPrivilegedの2引数のオーバーロードでは、以前に取得したコンテキストの特権を変更することができます。
nullのコンテキストは、それ以上の制限を加えないと解釈されます。
そのため、保存されているコンテキストを使用する前に、そのコンテキストがnullでないことを確認してください（AccessController.getContextはnullを返しません）。
```

```java
if (acc == null) {
    throw new SecurityException("Missing AccessControlContext");
}
AccessController.doPrivileged(new PrivilegedAction<Void>() {
        public Void run() {
            ...
        }
    }, acc);
```

## Guideline 9-4 / ACCESS-4: Know how to restrict privileges through doPrivileged

```
パーミッションはフレームの交点に制限されるため、フレームがない（ゼロ）ことを表す人工的なAccessControlContextは、すべてのパーミッションを意味します。
次の3つのdoPrivilegedの呼び出しは等価です。
```

```java
private static final AccessControlContext allPermissionsAcc =
    new AccessControlContext(
        new java.security.ProtectionDomain[0]
    );
void someMethod(PrivilegedAction<Void> action) {
    AccessController.doPrivileged(action, allPermissionsAcc);
    AccessController.doPrivileged(action, null);
    AccessController.doPrivileged(action);
}
```

```
すべてのパーミッションは、パーミッションのない ProtectionDomain のフレームを含む人工的な AccessControlContext コンテキストを使って削除できます。
```

```java
private static final java.security.PermissionCollection
    noPermissions = new java.security.Permissions();
private static final AccessControlContext noPermissionsAcc =
    new AccessControlContext(
        new ProtectionDomain[] {
            new ProtectionDomain(null, noPermissions)
        }
    );

void someMethod(PrivilegedAction<Void> action) {
    AccessController.doPrivileged(new PrivilegedAction<Void>() {
        public Void run() {
            ... context has no permissions ...
            return null;
        }
    }, noPermissionsAcc);
}
```

```

        +--------------------------------+
        | ActionImpl                     |
        |   .run                         |
        +--------------------------------+
        |                                |
        | noPermissionsAcc               |
        + - - - - - - - - - - - - - - - -+
        | java.security.AccessController |
        |   .doPrivileged                |
        +--------------------------------+
        | SomeClass                      |
        |   .someMethod                  |
        +--------------------------------+
        |  OtherClass                    |
        |    .otherMethod                |
        +--------------------------------+
        |                                |
        
中間的な状況としては、限られたパーミッションのセットのみが付与される場合が考えられます。
doPrivilegedに提供される前に、現在のコンテキストでパーミッションがチェックされていれば、権限昇格のリスクなしにパーミッションを減らすことができます。
これにより、最小特権の原則の使用が可能になります。
```

```java
private static void doWithFile(final Runnable task,
                               String knownPath) {
    Permission perm = new java.io.FilePermission(knownPath,
                                                 "read,write");

    // Ensure context already has permission,
    //   so privileges are not elevate.
    AccessController.checkPermission(perm);

    // Execute task with the single permission only.
    PermissionCollection perms = perm.newPermissionCollection();
    perms.add(perm);
    AccessController.doPrivileged(new PrivilegedAction<Void>() {
        public Void run() {
            task.run();
            return null;
        }},
        new AccessControlContext(
            new ProtectionDomain[] {
                new ProtectionDomain(null, perms)
            }
        )
    );
}
```

```
ディレクトリにパーミッションを与える際には、そのアクセスが意図しない結果をもたらさないように細心の注意を払わなければなりません。
ファイルやサブディレクトリに安全でないパーミッションが設定されていたり、ファイルシステムオブジェクトがディレクトリ外への追加アクセスを提供したりする可能性があります（シンボリックリンク、ループデバイス、ネットワークマウント/シェア、など）。
セキュリティポリシーやAccessController.doPrivilegedブロックでファイルのパーミッションを付与する際には、この点を考慮することが重要です。
また、あまり目立たないケース（例えば、クラスがロードされたディレクトリの読み取りパーミッションを付与することができます）についても考慮する必要があります。

アプリケーションは、コードやその他のファイルシステムに専用のディレクトリを使用し、安全なパーミッションが適用されるようにする必要があります。
共有/共通ディレクトリからコードを実行したり、共有/共通ディレクトリへのアクセス（シンボリックリンクによるアクセスを含む）を許可することは、可能な限り避けるべきです。
また、ファイルのパーミッションチェックを可能な限り厳密かつ安全に行うように設定することを推奨します[21]。

Java 8では、限定的なdoPrivilegedアプローチも追加されました。
このアプローチでは、コードが特権のサブセットを主張することができる一方で、他の許可をチェックするための完全なアクセス制御スタックウォークが可能です。
アサートされた権限の1つがチェックされた場合、スタックチェックはdoPrivilegedの呼び出しで停止します。
他の許可のチェックについては、スタック・チェックはdoPrivileged invocationを越えて継続されます。
これは、常に doPrivileged invocation で停止する、前述のアプローチとは異なります。

次の例を考えてみましょう。
```

```java
private static void doWithURL(final Runnable task,
                                          String knownURL) {
    URLPermission urlPerm = new URLPermission(knownURL);
    AccessController.doPrivileged(
                            new PrivilegedAction<Void>() {                 
        public Void run() {                     
            task.run();                     
            return null;                 
        }},
        someContext,              
        urlPerm             
    );  
}
```

```
タスクの実行中に URLPermission に一致する許可チェックが行われた場合、スタックチェックは doWithURL で停止します。
しかし、URLPermission にマッチしない許可チェックが実行された場合、スタックチェックはスタックを歩き続けます。

doPrivilegedの他のバージョンと同様に、限定されたdoPrivilegedメソッドでは、context引数をnullにすることができ、その結果、追加の制限は適用されません。
```

## Guideline 9-5 / ACCESS-5: Be careful caching results of potentially privileged operations

```
キャッシュされた結果は、それを生成するための適切なパーミッションを持っていないコンテキストに渡されてはなりません。
そのため、結果が返されるどのコンテキストよりも多くの権限を持たないコンテキストで結果が生成されるようにします。
権限の計算にはエラーが含まれる可能性があるため、AccessController APIを使用して制約を強化してください。
```

```java
private static final Map cache;

public static Thing getThing(String key) {
    // Try cache.
    CacheEntry entry = cache.get(key);
    if (entry != null) {
        // Ensure we have required permissions before returning
        //   cached result.
        AccessController.checkPermission(entry.getPermission());
        return entry.getValue();
    }

    // Ensure we do not elevate privileges (per <a href="#9-2">Guideline 9-2</a>).
    Permission perm = getPermission(key);
    AccessController.checkPermission(perm);

    // Create new value with exact privileges.
    PermissionCollection perms = perm.newPermissionCollection();
    perms.add(perm);
    Thing value = AccessController.doPrivileged(
        new PrivilegedAction<Thing>() { public Thing run() {
            return createThing(key);
        }},
        new AccessControlContext(
            new ProtectionDomain[] {
                new ProtectionDomain(null, perms)
            }
        )
    );
    cache.put(key, new CacheEntry(value, perm));

    return value;
}
```

## Guideline 9-6 / ACCESS-6: Understand how to transfer context

```
アクセスコントロールのコンテキストを保存しておくと、後々便利なことがあります。
例えば、特権的な操作を行うコールバックインスタンスへのアクセスを提供することが適切であると判断した場合、コールバックオブジェクトが登録されたコンテキストでコールバックメソッドを呼び出すことができます。
このコンテキストは、後から同じスレッドまたは別のスレッドで復元することができます。
元のスレッドが終了した後でも、特定のコンテキストを何度も復元することができます。

AccessController.getContextは、現在のコンテキストを返します。
AccessController.doPrivilegedの2引数のフォームは、アクションの間、現在のコンテキストを保存されたコンテキストに置き換えることができます。
```

```java
package xx.lib;

public class Reactor {
    public void addHandler(Handler handler) {
        handlers.add(new HandlerEntry(
                handler, AccessController.getContext()
        ));
    }
    private void fire(final Handler handler,
                      AccessControlContext acc) {
        if (acc == null) {
            throw new SecurityException(
                          "Missing AccessControlContext");
        }
        AccessController.doPrivileged(
            new PrivilegedAction<Void>() {
                public Void run() {
                    handler.handle();
                    return null;
                }
            }, acc);
     }
     ...
}
```

```

                                         +--------------------------------+
                                         | xx.lib.FileHandler             |
                                         |   handle()                     |
                                         +--------------------------------+
                                         | xx.lib.Reactor.(anonymous)     |
                                         |   run()                        |
+--------------------------------+ \     +--------------------------------+
| java.security.AccessController |  `    |                                |
|   .getContext()                |  +--> | acc                            |
+--------------------------------+  |    + - - - - - - - - - - - - - - - -+
| xx.lib.Reactor                 |  |    | java.security.AccessController |
|   .addHandler(Handler)         |  |    |   .doPrivileged(handler, acc)  |
+--------------------------------+  |    +--------------------------------+
| yy.app.App                     |  |    | xx.lib.Reactor                 |
|   .main(String[] args)         |  ,    |   .fire                        |
+--------------------------------+ /     +--------------------------------+
                                         | xx.lib.Reactor                 |
                                         | .run                           |
                                         +--------------------------------+
                                         |                                |
```

## Guideline 9-7 / ACCESS-7: Understand how thread construction transfers context

```
新たに構築されたスレッドは、Thread オブジェクトが構築されたときに存在したアクセス制御コンテキストで実行されます。
このコンテキストを迂回することを防ぐために、信頼されていないオブジェクトの void run() を不適切な権限で実行してはいけません。
```


