# 2章 適応度関数

適応度関数は遺伝的アルゴリズム設計の成功の定義で用いられる概念。
ソフトウェアにおいて適応度関数がチェックするのは、開発者がアーキテクチャ上の重要な特性を維持できているか否か。
システムの～性を保護するための仕組みといえる。

システム全体の適応度関数を評価することはできない。
システム全体の適応度関数は、将来のアーキテクチャについて優先度付けを行うための手引きを提供する。

## 2.1 適応度関数とは

適応度関数は自動算出できないこともある。

適応度関数によって、非機能要件テストについて統一的に考えられるようになる。

## 2.2 分類

### 2.2.1 アトミックvsホリスティック

アトミックな適応度関数は1つの次元の適応度を測る。
ホリスティックな適応度関数は、共有したコンテキストを持った複数次元の組み合わせの適応度を測る。

### 2.2.2 トリガー式vs継続的

トリガー式は、開発者がユニットテストを実行するみたいな感じで特定のイベントで発火される。
継続的というのは、本番稼働システムに本物のトランザクション同等のものを定期的に流し続けるみたいなこと。

### 2.2.3 静的vs動的

静的な適応度関数とは、ユニットテストの成功、失敗などのことを表している。
動的なのは、追加のコンテキストに基づいて基準が推移するようなやつ。

### 2.2.4 自動vs手動

法的、技術的な問題で、なかには手動でやらねばならないものもある

### 2.2.5 一時的なもの

使用ライブラリの重要な更新が行われたかどうか見るためのリマインダーとしてのテストとか。
アップグレード中断テスト？？

### 2.2.6 創発よりも意図的

開発最中に必要と分かった適応度関数。

# 3章 漸進的な変更を支える技術

## 3.1 構成要素

### 3.1.1 テスト可能

* アーキテクチャの違反を検出するには、厳密なガイドラインを用いるよりも自動テストを用いたほうがいい。
  * パッケージインポートの向きを検証するテストを具体例にあげている
  * JDepend

### 3.1.2 デプロイメントパイプライン

* 継続的インテグレーションとデプロイメントパイプラインの違いがいまいち不明??
* 機能トグル？(https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88%E3%82%B0%E3%83%AB)

### 3.1.3 適応度関数の分類を組み合わせる

* アトミック＋トリガー式
  * ユニットテスト、機能テスト
* ホリスティック＋トリガー式
  * よくわからん？ 
* アトミック＋継続的
  * liveness、readiness probeのイメージ
* ホリスティック＋継続的
  * Chaos Monkey

### 3.1.4 ケーススタディ：60回/日のデプロイのアーキテクチャ再構築

* rubyのScientistなるライブラリを使用して、新規のコードがどのような振る舞いをするのかを確認する。

### 3.1.5 目標の衝突

* 開発者は機能の変更ペースをあげたいが、データベース管理者はスキーマを安定させたい、みたいな対立が生じうる。
* それらを定量的に評価できるようになると、優先順位付けができ、明確な意思決定を行うことができるようになる。
  * そんなにうまくいくのか？？
  * 安定性ってどうやってはかる？同一条件でそれらを本当に比較できるのか？？同一条件とは
  
### 3.1.6 ケーススタディ：PenultimateWidgets の請求書発行サービスに適応度関数を追加する

### 3.2 仮設駆動開発とデータ駆動開発

* githubのやつのどのへんがデータ駆動開発なのか？
* ビジネスアナリストが決定を下した案を実装するのではなく、仮説検証に実際のユーザーを巻き込んで、ユーザーにその仮説を判断してもらうというやり方。

### 3.3 ケーススタディ：移植するのは何か


# 4章 アーキテクチャ上の結合

## 4.1 モジュール性

* モジュールは論理的なグループ化を意味し、コンポーネントは物理的な分割方法を意味する。

## 4.2 アーキテクチャ量子と粒度

* 量子、コンポーネント、モジュールという用語でアーキテクチャを考える。
  * 量子がコンポーネントを含み、コンポーネントがモジュールを含む？
  
### 4.3 アーキテクチャスタイルの進化可能性

* この節では、いくつかの代表的なアーキテクチャパターンを見ていく。
* 漸進的な変更、適応度関数、適切な結合という観点で見ていく。

### 4.3.1 巨大な泥団子

* 識別可能なアーキテクチャを持たない場合、どの観点から見ても進化に適していない。

### 4.3.2 モノリス（一枚岩）

#### 非構造モノリス

* レイヤでわけられていないパターン
* どの視点から見ても良くない。

#### レイヤ化アーキテクチャ

* プレゼン層、ビジネスロジック層..みたいにレイヤでわけられているパターン。
* 漸進的な変更
  * レイヤをまたぐ場合は難しいかも
* 適応度関数による誘導的な変更
  * やりやすい
* 適切な結合
  * 分割部分を容易に進化させられる
  
#### モジュール式モノリス

* あまりみたことがない気がする。Javaだとどんな感じ？

#### マイクロカーネル

* ブラウザ、IDEでよく使われるパターン
* ブラウザ、IDEがどのように実装されているかわからないのでピンとこない
* https://developers.google.com/web/updates/2018/09/inside-browser-part1#saving_more_memory_-_servicification_in_chrome
  * コアとプラグイン間はどのように通信しているのか？
  * 制御の方法は？
* 漸進的な変更
  * プラグイン同士が独立しているのであれば、漸進的な変更は容易
* 適応度関数による誘導的な変更
  * 
* 適切な結合
  * 

### 4.3.3 イベント駆動アーキテクチャ

#### Broker（ブローカー）

* このアーキテクチャはトランザクションの実現等が難しい
* 漸進的な変更
  * 本質的に非同期処理であり、非同期処理はテストが困難であるため、デプロイメントパイプラインの構築は難しい
* 適応度関数による誘導的な変更
  * 相互IDS？
  * 合成トランザクション?
* 適切な結合
  * コンシューマ駆動契約?
    * https://www.slideshare.net/RyoMitoma/ss-120901867
    * サービス間IF情報を契約情報としてDBに保存し、テスト時にそれらを使う感じ

#### Mediator (メディエーター)

* トランザクションを扱うのが容易になる
* 漸進的な変更
* 適応度関数による誘導的な変更
* 適切な結合
  * 結合は増える

Brokerのほうが結合が減り、進化可能性、非同期性、スケール等の面で優れるが、トランザクション調整などが難しい

### 4.3.4 サービス指向アーキテクチャ

#### ESB駆動アーキテクチャ

* 進化可能性に関して言うと、悪い

#### マイクロサービス

基本、レイヤ化されたアーキテクチャをであるとき、あるドメインの内容は複数レイヤにまたがって存在することになる。
つまり、ドメインに変更が入った場合、複数レイヤに変更が加わる。

ドメインの次元でサービスが区切られる場合どうなるか？

マイクロサービスアーキテクチャは一般に、以下の原則にしたがう。
* ビジネスドメインに沿ったモデル化
  * 量子は境界付けられたコンテキストを反映する
* 実装詳細の隠蔽
* 自動化の文化
* 高度な分散化
  * 無共有アーキテクチャを目指す。結合よりも重複が望ましい。
* 独立したデプロイ
* 障害の分離
  * [リアクティブ宣言]( https://www.reactivemanifesto.org/ja )
* 高度な観察可能性

進化可能性は高い。

* 漸進的な変更
* 適応度関数による誘導的な変更
* 適切な結合
  * 統合とサービステンプレート
    

#### サービスベースアーキテクチャ

マイクロサービスとは、サービス粒度・データベースのスコープ・ミドルウェアの統合、という点で違いがある。

マイクロサービスの哲学的純粋性と、実践的現実の良い妥協点らしい。

### 4.3.5 「サーバーレス」アーキテクチャ

解決しなければならない実際の問題と照らし合わせて、評価する必要がある。

## 4.4 量子の大きさをコントロールする

量子が小さいほど、アーキテクチャは進化しやすい

## 4.5 ケーススタディ：コンポーネント循環を防ぐ

# 5章 進化的データ

## 5.1 進化的なデータベース設計

### 5.1.1 スキーマを進化させる

* flyway使えという話？

### 5.1.2 共有データベース統合

* expand/contractパターン
  * スキーマを変更させなければならないときに実施するパターン。トリガーなど使って、新旧両方に対応できるようなスキーマにしとく


## 5.2 不適切なデータ結合

* DBAが使用するツールは、 開発者のそれに比べて旧式であることが多い
  * DBAとデータベースベンダーの関わりが深すぎるため
  
### 5.2.1 2層コミットトランザクション

* トランザクションは結合の一形態
* データベーストランザクションは強力な核力として振る舞い、量子を結びつける

### 5.2.2 データの年齢と質

* スキーマ定義拡張の際に、DBAは関連テーブルを作成することでお茶を濁しがち
* 本当に価値あるデータが何であるかを見定め、それを保持する
* 古いデータは参照用に利用可能にしつつも、進化的な開発の主流からは外すようにする

## 5.3 ケーススタディ：PenultimateWidgetsのルーティングを進化させる

# 6章 進化可能なアーキテクチャの構築

## 6.1 仕組み

### 6.1.1 ①進化の影響を受ける次元を特定する

* どの次元をアーキテクチャの進化とともに保護していきたいのか特定する

### 6.1.2 ②それぞれの次元に対して適応度関数を定義する

* 適応度関数は自動化されていても、手動でも良い

### 6.1.3 ③デプロイメントパイプラインを使って適応度関数を自動化する

## 6.2 グリーンフィールドプロジェクト

* 新規プロジェクトにて進化可能性を測れるようにするのは容易

## 6.3 既存のアーキテクチャを改良する

* 進化可能性を加えられるかは、コンポーネント結合、開発プラクティスの成熟度、適応度関数の作りやすさに依存する

### 6.3.1 適切な結合と凝集

* アーキテクチャを選択する前に、ビジネス上の問題を理解しよう

### 6.3.2 開発プラクティス

### 6.3.3 適応度関数

### 6.3.4 COTSとの関わり合い

## 6.4 アーキテクチャの移行

楽しいメタ作業であるという理由だけでアーキテクチャを構築してはならない

### 6.4.1 移行手順

モノリシックアプリケーションを分解するときには、正しいサービスの粒度を見つけることが重要

様々な分割方法を介して、モノリスをサービスに分割することができる
* ビジネス機能グループ
* トランザクション境界
* デプロイメント目標

### 6.4.2 モジュール相互作用を進化させる

## 6.5 進化的アーキテクチャ構築のための手引き

### 6.5.1 不要な変数を取り除く

イミュータブルインフラを目指す

### 6.5.2 決定を可逆にする

ブルーグリーンデプロイなどで、変更が間違ったものであったらすぐに戻せるようにしとく

### 6.5.3 予測可能ではなく進化可能を選ぶ

未知の未知を設計することはできない。
そのため、イテレーティブでアジャイルな開発がいる

### 6.5.4 腐敗防止層を構築する

拙速な判断をするよりも、判断を先延ばしにすべき、という概念を「最終責任時点」という？

JITでうんぬんのところ意味がわからない

### 6.5.5 ケーススタディ：サービステンプレート

サービステンプレートで一貫性を保証する

### 6.5.6 犠牲的アーキテクチャの構築

素早く市場にリリースするために後で捨てるようのアーキテクチャで作成するもよし。
ただし、それが堅牢な性質を求めるように進化するようになったのであれば、すぱっと捨てたほうがよい

###  6.5.7 外部の変更を軽減する

結局何をしているのか？？

### 6.5.8 ライブラリのアップデートとフレームワークのアップデート

フレームワークの依存関係は積極的に更新し、ライブラリの依存関係は受動的に更新する

### 6.5.9 スナップショットよりも継続的デリバリーを選ぶ

スナップショットは包括的なテストが一般的でなく、ストレージが高価で、検証が難しかった時代の産物

本書では、開発者は外部依存関係の2つの新しい指定を導入すべきと考える
* 不安定な依存関係
* 保護された依存関係

最新のバージョンを追いかけて、それでテストするけど、失敗したら安定稼働しているやつに戻すみたいな考え方かな？
むずかしくないか？？
package-lock.jsonみたいなので保護された依存関係を定義しとくのかな


### 6.5.10 内部的にサービスをバージョン付けする

* ナンバリングによるバージョン付け
  * APIに関して、エンドポイントにverふるみたいな
* 内部解決
  * エンドポイントは変えずに、内部のロジックで何とかする感じ
  
2つ以上のバージョンは保持しないようにする

## 6.6 ケーススタディ：PenultimateWidgetsの評価サービスの進化

# 7章 進化的アーキテクチャの落とし穴とアンチパターン

単なる「悪い」と異なり、アンチパターンには２つの要素がある。
* 当初は良い考えに見えるものの、結果的には誤りであると判明するもの
* ほとんどのアンチパターンにはよりよい選択肢が存在する

## 7.1 技術アーキテクチャ

### 7.1.1 アンチパターン：ベンダーキング

ベンダーを、将来の決定を命令するアーキテクチャの王様にしてしまう誤り。

必要なアプリケーションが、競争優位性を担うものでなければ別に良い。
そうでない場合、90%くらいまではパッケージとか、FWで楽勝で作ることができるが、残り10%にめちゃくちゃ苦労する、またはできない。

このアンチパターンの被害者とならないように、ベンダー製品を単なる統合点として扱う。
統合点の間に腐敗防止層を設けることによって、ベンダーツールの変更がアーキテクチャに影響を与えるのを防げる。


### 7.1.2 落とし穴：抽象化の欠如

不変量ってなんだ？
https://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E9%87%8F 
 
ここは結局どんな方法をとればいいのかいまいちわからない。
統合点の不変量を適応度関数として定義する？？

### 7.1.3 アンチパターン：ラスト10%の罠

無限後退問題
https://ja.wikipedia.org/wiki/%E7%84%A1%E9%99%90%E5%BE%8C%E9%80%80

### 7.1.4 アンチパターン：コード再利用の乱用

再利用可能であればあるほど、コードは使いずらいものとなる。

コード内に導入された結合点がアーキテクチャのほかの目標と衝突していないことを確認する。

### 7.1.5 ケーススタディ：PenultimateWidgetsにおける再利用

### 7.1.6 落とし穴：レジュメ駆動開発

## 7.2 漸進的な変更

### 7.2.1 アンチパターン：不適切なガバナンス


