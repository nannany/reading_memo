# 2章 適応度関数

適応度関数は遺伝的アルゴリズム設計の成功の定義で用いられる概念。
ソフトウェアにおいて適応度関数がチェックするのは、開発者がアーキテクチャ上の重要な特性を維持できているか否か。
システムの～性を保護するための仕組みといえる。

システム全体の適応度関数を評価することはできない。
システム全体の適応度関数は、将来のアーキテクチャについて優先度付けを行うための手引きを提供する。

## 2.1 適応度関数とは

適応度関数は自動算出できないこともある。

適応度関数によって、非機能要件テストについて統一的に考えられるようになる。

## 2.2 分類

### 2.2.1 アトミックvsホリスティック

アトミックな適応度関数は1つの次元の適応度を測る。
ホリスティックな適応度関数は、共有したコンテキストを持った複数次元の組み合わせの適応度を測る。

### 2.2.2 トリガー式vs継続的

トリガー式は、開発者がユニットテストを実行するみたいな感じで特定のイベントで発火される。
継続的というのは、本番稼働システムに本物のトランザクション同等のものを定期的に流し続けるみたいなこと。

### 2.2.3 静的vs動的

静的な適応度関数とは、ユニットテストの成功、失敗などのことを表している。
動的なのは、追加のコンテキストに基づいて基準が推移するようなやつ。

### 2.2.4 自動vs手動

法的、技術的な問題で、なかには手動でやらねばならないものもある

### 2.2.5 一時的なもの

使用ライブラリの重要な更新が行われたかどうか見るためのリマインダーとしてのテストとか。
アップグレード中断テスト？？

### 2.2.6 創発よりも意図的

開発最中に必要と分かった適応度関数。

# 3章 漸進的な変更を支える技術

## 3.1 構成要素

### 3.1.1 テスト可能

* アーキテクチャの違反を検出するには、厳密なガイドラインを用いるよりも自動テストを用いたほうがいい。
  * パッケージインポートの向きを検証するテストを具体例にあげている
  * JDepend

### 3.1.2 デプロイメントパイプライン

* 継続的インテグレーションとデプロイメントパイプラインの違いがいまいち不明??
* 機能トグル？(https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88%E3%82%B0%E3%83%AB)

### 3.1.3 適応度関数の分類を組み合わせる

* アトミック＋トリガー式
  * ユニットテスト、機能テスト
* ホリスティック＋トリガー式
  * よくわからん？ 
* アトミック＋継続的
  * liveness、readiness probeのイメージ
* ホリスティック＋継続的
  * Chaos Monkey

### 3.1.4 ケーススタディ：60回/日のデプロイのアーキテクチャ再構築

* rubyのScientistなるライブラリを使用して、新規のコードがどのような振る舞いをするのかを確認する。

### 3.1.5 目標の衝突

* 開発者は機能の変更ペースをあげたいが、データベース管理者はスキーマを安定させたい、みたいな対立が生じうる。
* それらを定量的に評価できるようになると、優先順位付けができ、明確な意思決定を行うことができるようになる。
  * そんなにうまくいくのか？？
  * 安定性ってどうやってはかる？同一条件でそれらを本当に比較できるのか？？同一条件とは
  
### 3.1.6 ケーススタディ：PenultimateWidgets の請求書発行サービスに適応度関数を追加する

### 3.2 仮設駆動開発とデータ駆動開発

* githubのやつのどのへんがデータ駆動開発なのか？
* ビジネスアナリストが決定を下した案を実装するのではなく、仮説検証に実際のユーザーを巻き込んで、ユーザーにその仮説を判断してもらうというやり方。

### 3.3 ケーススタディ：移植するのは何か


# 4章 アーキテクチャ上の結合

## 4.1 モジュール性

* モジュールは論理的なグループ化を意味し、コンポーネントは物理的な分割方法を意味する。

## 4.2 アーキテクチャ量子と粒度

* 量子、コンポーネント、モジュールという用語でアーキテクチャを考える。
  * 量子がコンポーネントを含み、コンポーネントがモジュールを含む？
  
### 4.3 アーキテクチャスタイルの進化可能性

* この節では、いくつかの代表的なアーキテクチャパターンを見ていく。
* 漸進的な変更、適応度関数、適切な結合という観点で見ていく。

### 4.3.1 巨大な泥団子

* 識別可能なアーキテクチャを持たない場合、どの観点から見ても進化に適していない。

### 4.3.2 モノリス（一枚岩）

#### 非構造モノリス

* レイヤでわけられていないパターン
* どの視点から見ても良くない。

#### レイヤ化アーキテクチャ

* プレゼン層、ビジネスロジック層..みたいにレイヤでわけられているパターン。
* 漸進的な変更
  * レイヤをまたぐ場合は難しいかも
* 適応度関数による誘導的な変更
  * やりやすい
* 適切な結合
  * 分割部分を容易に進化させられる
  
#### モジュール式モノリス

* あまりみたことがない気がする。Javaだとどんな感じ？

#### マイクロカーネル

* ブラウザ、IDEでよく使われるパターン
* ブラウザ、IDEがどのように実装されているかわからないのでピンとこない
* https://developers.google.com/web/updates/2018/09/inside-browser-part1#saving_more_memory_-_servicification_in_chrome
  * コアとプラグイン間はどのように通信しているのか？
  * 制御の方法は？
* 漸進的な変更
  * プラグイン同士が独立しているのであれば、漸進的な変更は容易
* 適応度関数による誘導的な変更
  * 
* 適切な結合
  * 

### 4.3.3 イベント駆動アーキテクチャ

#### Broker（ブローカー）

* このアーキテクチャはトランザクションの実現等が難しい
* 漸進的な変更
  * 本質的に非同期処理であり、非同期処理はテストが困難であるため、デプロイメントパイプラインの構築は難しい
* 適応度関数による誘導的な変更
  * 相互IDS？
  * 合成トランザクション?
* 適切な結合
  * コンシューマ駆動契約?
    * https://www.slideshare.net/RyoMitoma/ss-120901867
    * サービス間IF情報を契約情報としてDBに保存し、テスト時にそれらを使う感じ

#### Mediator (メディエーター)

* トランザクションを扱うのが容易になる
* 漸進的な変更
* 適応度関数による誘導的な変更
* 適切な結合
  * 結合は増える

Brokerのほうが結合が減り、進化可能性、非同期性、スケール等の面で優れるが、トランザクション調整などが難しい

### 4.3.4 サービス指向アーキテクチャ

#### ESB駆動アーキテクチャ

* 進化可能性に関して言うと、悪い

#### マイクロサービス

基本、レイヤ化されたアーキテクチャをであるとき、あるドメインの内容は複数レイヤにまたがって存在することになる。
つまり、ドメインに変更が入った場合、複数レイヤに変更が加わる。

ドメインの次元でサービスが区切られる場合どうなるか？

マイクロサービスアーキテクチャは一般に、以下の原則にしたがう。
* ビジネスドメインに沿ったモデル化
  * 量子は境界付けられたコンテキストを反映する
* 実装詳細の隠蔽
* 自動化の文化
* 高度な分散化
  * 無共有アーキテクチャを目指す。結合よりも重複が望ましい。
* 独立したデプロイ
* 障害の分離
  * [リアクティブ宣言]( https://www.reactivemanifesto.org/ja )
* 高度な観察可能性

進化可能性は高い。

* 漸進的な変更
* 適応度関数による誘導的な変更
* 適切な結合
  * 統合とサービステンプレート
    

#### サービスベースアーキテクチャ

マイクロサービスとは、サービス粒度・データベースのスコープ・ミドルウェアの統合、という点で違いがある。

マイクロサービスの哲学的純粋性と、実践的現実の良い妥協点らしい。

### 4.3.5 「サーバーレス」アーキテクチャ

解決しなければならない実際の問題と照らし合わせて、評価する必要がある。

## 4.4 量子の大きさをコントロールする

量子が小さいほど、アーキテクチャは進化しやすい

## 4.5 ケーススタディ：コンポーネント循環を防ぐ

# 5章 進化的データ


