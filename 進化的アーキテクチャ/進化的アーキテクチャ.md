# 2章 適応度関数

適応度関数は遺伝的アルゴリズム設計の成功の定義で用いられる概念。
ソフトウェアにおいて適応度関数がチェックするのは、開発者がアーキテクチャ上の重要な特性を維持できているか否か。
システムの～性を保護するための仕組みといえる。

システム全体の適応度関数を評価することはできない。
システム全体の適応度関数は、将来のアーキテクチャについて優先度付けを行うための手引きを提供する。

## 2.1 適応度関数とは

適応度関数は自動算出できないこともある。

適応度関数によって、非機能要件テストについて統一的に考えられるようになる。

## 2.2 分類

### 2.2.1 アトミックvsホリスティック

アトミックな適応度関数は1つの次元の適応度を測る。
ホリスティックな適応度関数は、共有したコンテキストを持った複数次元の組み合わせの適応度を測る。

### 2.2.2 トリガー式vs継続的

トリガー式は、開発者がユニットテストを実行するみたいな感じで特定のイベントで発火される。
継続的というのは、本番稼働システムに本物のトランザクション同等のものを定期的に流し続けるみたいなこと。

### 2.2.3 静的vs動的

静的な適応度関数とは、ユニットテストの成功、失敗などのことを表している。
動的なのは、追加のコンテキストに基づいて基準が推移するようなやつ。

### 2.2.4 自動vs手動

法的、技術的な問題で、なかには手動でやらねばならないものもある

### 2.2.5 一時的なもの

使用ライブラリの重要な更新が行われたかどうか見るためのリマインダーとしてのテストとか。
アップグレード中断テスト？？

### 2.2.6 創発よりも意図的

開発最中に必要と分かった適応度関数。

# 3章 漸進的な変更を支える技術

## 3.1 構成要素

### 3.1.1 テスト可能

* アーキテクチャの違反を検出するには、厳密なガイドラインを用いるよりも自動テストを用いたほうがいい。
  * パッケージインポートの向きを検証するテストを具体例にあげている
  * JDepend

### 3.1.2 デプロイメントパイプライン

* 継続的インテグレーションとデプロイメントパイプラインの違いがいまいち不明
* 機能トグル？(https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88%E3%82%B0%E3%83%AB)

### 3.1.3 適応度関数の分類を組み合わせる

* アトミック＋トリガー式
  * ユニットテスト、機能テスト
* ホリスティック＋トリガー式
  * よくわからん？ 
* アトミック＋継続的
  * liveness、readiness probeのイメージ
* ホリスティック＋継続的
  * Chaos Monkey

### 3.1.4 ケーススタディ：60回/日のデプロイのアーキテクチャ再構築

* 
