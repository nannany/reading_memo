プログラミングというよりはエンジニアリングについての本。

持続可能なソフトウェアエコシステムについて、Googleの知見を述べていく本。

トピックとしては大きく、
- 文化
- プロセス
- ツール

について扱っていく。


# 第1部 主題

## 1章 ソフトウェアエンジニアリングとは何か

プログラミングとソフトウェアエンジニアリングの違いは3つ。

- 時間
- スケール
- トレードオフ

```
本書が目指すのは、Googleで、何万人ものエンジニアと世界中に広がるコンピュートリソースとを用いて、何十年も存続する見込みのソフトウェアの構築と保守を行う際に、効果があると突き止められたものを公開することだ。
```

### 1.1 時間と変化

google検索、linuxカーネル、apache httpサーバーなどは宿題やスタートアップのコードとは違い長期間動作することが求められる。

アップグレードを最初から計画していなかったpjでは下記の理由から移行に苦痛が伴う。

- プロジェクトでまだ行われたことのないタスクを実行することになるため、より多くの隠れた前提条件が組み込まれている。
- アップグレードを試みるエンジニアは、この種のタスクの経験がある可能性が低い。
- どちらかといえばインクリメンタル(incremental:段階的に増える)なアップグレードでは なく複数年分のアップグレードをやっているので、アップグレードのサイズが通常より大きい場合が多い。

#### 1.1.1 Hyrumの法則

Hyrumの法則
```
あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様として何を約束しているかは重要ではない。
作られたシステムが持つあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである。
```

これでピンとくるか？？複雑度はAPIが使われるに従って上がる、という理解をした。
APIを公開して、暗黙の依存関係ができて、それが複雑度につながる。

#### 1.1.2 例: ハッシュの順序付け

ハッシュの順序付けを例にとって、Hyrumの法則について説明している。

ハッシュテーブルは内部的には順序を持っているが、ハッシュ実装者が意図してそうなっているというよりは勝手にそうなったもの。
このような意図せずに発生した仕様に依存して何者かが作成されると厄介。
これがHyrumの法則の一例。`作られたシステムが持つあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである。`

#### 1.1.3 「何も変化しない」状態をとにかく目指すのはどうか

持続可能性に投資していない長期プロジェクトは大きなリスクがある。

### 1.2 スケールと効率

#### 1.2.1 スケールしないポリシー

```
少し練習すれば、スケーリングについて難のある属性を持つポリシーを容易に見つけられるようになる。
通常、そうしたポリシーを特定するには、エンジニア1人に課される作業を考えた上で、組織が10倍か100倍スケールアップ(scaleup)†42する場合を想像してみればよい。
組織が10倍大きくなったら、標本(sample)とした1人のエンジニアが保持する作業量を10倍に増やすだろうか。
エンジニアがこなさなければならない作業量は、組織のサイズに応じて変動する、関数の値として増大するか。
その作業はコードベースのサイズに伴ってスケールアップするか。
これらのいずれかが真であるならば、その作業を自動化するか最適化するための何らかのメカニズム(mechanism:仕組み、機構)は設置されているか。
そのメカニズムがないならば、スケーリング上の問題がある状態だ。
```

#### 1.2.2 よくスケールするポリシー

組織が発展するのに伴ってコスト改善につながるのは、どんな種類のポリシーだろうか。

```
製品が、インフラストラ クチャーの変更の結果として障害や他の問題に陥った場合、問題が継続的インテグレーション
(Continuous Integration/CI)†51システムでのテストで表面化していなかったならば、インフラス トラクチャーの変更に落ち度はない
```
というポリシーが例に挙げられていた。

知識共有については3章でのべる。

#### 1.2.3 例：コンパイラーのアップグレード

https://ja.wikipedia.org/wiki/%E6%8A%95%E6%A9%9F%E7%9A%84%E5%AE%9F%E8%A1%8C#:~:text=%E6%8A%95%E6%A9%9F%E7%9A%84%E5%AE%9F%E8%A1%8C%EF%BC%88%E3%81%A8%E3%81%86%E3%81%8D%E3%81%A6%E3%81%8D,%E3%81%A7%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82

ビヨンセルールは導入できたら楽だなと思った。
インフラ改善を行った際に、特定のCIを回すことができれば、それはインフラ改善の影響ではないとするポリシー。

#### 1.2.4 左への移動

---


# 第2部 文化

## 2章 チームでうまく仕事をするには

```
本章において決定的に重要な考え方は、ソフトウェア開発とはチームによる取り組みであるということだ。
そして、エンジニアリングのチームで(あるいは他のどんな創造的共同作業でも)成功するためには、「謙虚、尊敬、信頼」という中心的原則をめぐる自身の行動を改革する必要がある。
```

### 2.1 自分のコードを隠すのを手伝ってはくれないか

準備途中のものを見られたくはないという心理。
不安はさらに大きな問題の兆候である。

### 2.2 天才神話

チームの成功を個人にきせずにはいられないという性向を天才神話と呼んでいる。

自分のキャリアを生かすか殺すかは他者との共同作業をいかにうまくやるかにかかっている。

仕事の隠蔽が問題である。

### 2.3 隠蔽は有害とみなされる

単独作業には不要な失敗をしたり成長の可能性を逃すリスクがある。

#### 2.3.1 早期発見

```
「早期に失敗し、高速に失敗し、頻繁に失敗せよ」という、有効性が実証済みの標語を覚えておくとよい。
```

#### 2.3.2 バス係数

```
バス係数【bus factor】(名詞):プロジェクトを完全に破綻させるのに必要な、バスに轢かれる人の数
```

#### 2.3.3 進捗ペース

10,000行を描き終えてからコンパイルする人はいない。早期にフィードバックせよ。

```
誤解しないでほしいことがある。
エンジニアはコードを書くのに集中するために邪魔が入らない時間を必要としていると我々は相変わらず考えてはいる。
しかし、所属するチームとの広帯域で抵抗の少ない接点もエンジニアは全く同じくらい必要としているとも我々は考えているのだ。
チームにいる比較的知識の浅い者が、質問をするのに障壁があると感じるとしたら、それは問題だ。
適正なバランスを見出すには技が要る。
```

#### 2.3.4 要するに、隠れるな

### 2.4 チームが全て

ソフトウェアエンジニアリングとはチームによる取り組みである。

#### 2.4.1 社会交流の三本柱

どのようにして優れたチームを構築できるだろうか？

社交スキルの三本柱を受容する。

- 謙虚
  - 自分は(自分のコードも!)宇宙の中心的存在ではない。自分は全知全能でも、常に誤りのない存在でもない。自己研鑽に対して開かれた存在が自分である。
- 尊敬
  - ともに仕事をする他者を心から思いやる。他者を親切に遇し、他者の能力と成果の価値を認める。
- 信頼
  - 他者が有能で正義を為すであろうと信じ、適切な場合には他者に舵取りを任せることに異存がない。

#### 2.4.2 何故三本柱に意味があるのか

```
物事をやり遂げるために人間関係を構築するという話だ。
人間関係は、プロジェクトより常に長く存続する。同僚とより豊かな人間関係を結べば、同僚の助けが必要なときに同僚が手間を惜しまないようになるだろう。
```

#### 2.4.3 謙虚、尊敬、信頼の実践

##### 2.4.3.1 エゴを捨てろ

##### 2.4.3.2 批判のやり方を学べ、批判の受け方も学べ

##### 2.4.3.3 高速に失敗し、反復せよ

```
失敗は、次回の試み に向けての学習と改善のための、値千金の機会とみなされている
```

#### 2.4.4 非難なきポストモーテム文化

適切なポストモーテムは以下を含む。

```
● 分析対象イベント(event:事象)の簡潔な要約
● 発見から調査を経て解決に至るまでの分析対象イベントのタイムライン
● 分析対象イベントの主要原因
● 影響(impact)と損害の評価
● 問題を直ちに修正するための一連のアクションアイテム(action item:要処理事項)(とそのオーナー)
● 分析対象イベントが再度発生するのを防ぐための一連のアクションアイテム
● 学んだ教訓
```


##### 2.4.4.1 忍耐を学べ

具体例で説明している。

##### 2.4.4.2 影響に対して寛容であれ

```
不変の環境と完璧な知識がない限り、全てに関して常に正しくあることは不可能なので、新しいエビデンスが提示されれば当然考えを変えるべきなのだ。
自分が勝てる戦いのみを慎重に選んでほしい。
つまり、他者にまともに話を聞いてもらうには、まず他者の話に耳を傾けなければならないのである。
大事を始めたり、決定を確固たる形で発表したりする前に、そうやって耳を傾けた方がよい。
```

#### 2.4.5 Google的であること

謙虚、尊敬、信頼を体現する評価基準

- 曖昧さの中にあっても成功する 
  - 環境が絶えず変動している最中であっても、互いに競合する複数のメッセージや複数の方針 に対処でき、合意を形成でき、問題に対して進捗を遂げることができる。
- フィードバックを尊重する
  - フィードバックを率直に受け、かつ与えるという両方を行える謙虚さを持ち、フィードバックが個人の(ならびにチームの)成長にとってどれだけ有益か理解している。
- 現状に立ち向かう 
  - 他者からの抵抗や惰性があろうとも、野心的なゴールを設定し追求することができる。
- ユーザーを第一に置く
  - Google 製品のユーザーへの共感と尊敬とを持ち、ユーザーの利益を第一に考えた行動を追 求する。
- チームを思いやる
  - 同僚に共感と尊敬とを抱き、頼まれなくても積極的に手伝うように動くことで、チームの団結を強める。 
- 正義を為す
  - 行うこと全てについて強い倫理的感覚を持つ。チームと製品の誠実さ(integrity)を守るためなら、困難で不都合な決断を行うこともいとわない。

### 2.5 結論

リスクをとって、時には失敗することも必須となる。

### 2.6 要約

```
● 孤独に仕事をする場合のトレードオフを認識せよ。 
● 自分と自分のチームが、コミュニケーションと個人間の対立とに費やした時間の量を認めよ。 個性ならびに働き方のスタイルを、自分自身と他者のそれぞれについて理解することに少し投資するだけで、生産性の改善に大いに効果がある可能性がある。
● チームや大規模組織の一員として効果的に仕事をしたいなら、自分の好む働き方のスタイルと、他者の好む働き方のスタイルとについて認識せよ。
```

## 3章 知識共有

学びの文化が必要。そのためには知識が欠けていることを認める心理的安全性を作り出すことが肝心。

### 3.9 結論

知識共有を簡単にするための投資はかなり有用。

### 3.10 要約

```
● 心理的安全性は、知識共有の環境を育む際の基盤である。
● 小さなことから始めよ。つまり、質問をすること、物事を書き留めることだ。
● 人間の専門家とドキュメント化されたリファレンスの双方から、必要な助けを簡単に得られるようにすべきである。
● 自身のみならず所属チームや所属組織を越えて専門知識を教え広めていくのに時間を割く者は、制度的なレベルで奨励し報奨を与えよ。
● 銀の弾丸はない。知識共有の文化を振興するには複数の戦略の組み合わせが必要であり、どのような特定の配合が組織にとって最もうまく機能するかは、おそらく時間の経過に伴って変化するだろう。
```


## 10章 ドキュメンテーション

```
エンジニアが質の高いドキュメンテーションをより楽に書けるようにするための鍵となるのは、
組織とともにスケールし既存ワークフローと調和するようなプロセスとツールの導入である。
```

### 10.1  何がドキュメントとして適格か

ここで述べるドキュメントは、エンジニアが業務遂行のために書く必要があるあらゆる補足的な文章をさす。
つまり、コードのコメントも含まれる。

### 10.2 なぜドキュメンテーションが必要なのか

ドキュメントは書いたものがすぐに恩恵に与れる類のものではないが、その後に何百回と読まれる可能性がある。
とてもスケールするものである。

ドキュメンテーションは以下のような質問に答えるのを手伝ってくれる。
```
● これらの設計上の決定は何故行われたのか。
● このコードを何故このやり方で実装したのか。
● 自分自身のコードを 2 年後に見ているとして、自分はこのコードを何故このやり方で実装したのか。
```

即時的に効果を得られないという理由以外に、なぜドキュメントを書くことが嫌われるか？

```
● エンジニアは、文章を書くことを、プログラミングのスキルとは別のスキルとみなすことが多い(このことが必ずしも事実ではないことの説明を試みていくことになるが、たとえ事実である場合でも、文章を書くことはソフトウェアエンジニアリングのスキルとは必ずしも別のスキルではない)。
● 自分が文章の書き手として有能であると感じてはいないエンジニアがいる。しかし、使えるドキュメンテーションを作成するのに英語が堪能である必要はない。自分自身の殻から少しだけ外にとにかく踏み出して、読み手の観点から物事を見てみなければならない。
● ツールの支援や開発者ワークフローへの統合が限られていることで、ドキュメンテーションを書くのがより難しくなっていることが多い。
● ドキュメンテーションが、余計な重荷、つまり別の保守対象とみなされ、既存コードの保守を楽にしてくれるようなものとはみなされていない。
```


ドキュメントが書き手、書き手の所属するグループに与える恩恵。

```
● ドキュメンテーションはAPIの定式化を補助する。ドキュメンテーションを書くことは、APIが意味をなしているかを理解する最も確実な方法である。往々にしてエンジニアは、ドキュメンテーションを書くこと自体を契機に、それを書かなければ疑問を呈することがなかったであろう設計上の決定を再検討するに至る。APIの説明や定義ができないのであれば、おそらくそのAPIの設計は不十分だ。
● ドキュメンテーションは、保守のロードマップと、履歴の記録を提供する。いかなる場合でもコード内で凝ったことをやるのは避けるべきだが、自分が2年前に書いたコードを見つめて間違っている点を見つけ出そうと試みる場合、良質なコメントが大いに助けになる。
● ドキュメンテーションは、コードをよりプロフェッショナルに見せ、アクセス数の増加を牽引する。開発者は自然と、しっかりドキュメント化されたAPIを、設計が比較的優れたAPIであると推測するだろう。それが常に事実とは限らないが、それらに高い相関性があることは少なくない。この利益はうわべだけのものに聞こえるが、全くそうではない。製品に良質なドキュメンテーションがあるかどうかは通常、製品の保守にどの程度力が入れられることになるかを非常に明確に示すものとなる。
● ドキュメンテーションがあると、他のユーザーの質問を誘発することが比較的少なくなるだろう。ドキュメンテーションを書く者にとって、これがおそらく最大の利益である。誰かに何かを一度ならず何度も説明しなければならないとしたら、通常はそのプロセスをドキュメント化することが合理的である。
```

### 10.3 ドキュメンテーションはコードのようなものである

ドキュメンテーションは以下のようなものであるべき。

```
● 従うべき内部的なポリシーかルールを持つ
● ソースコントロールシステムの管理下に置かれる
● そのドキュメントを保守する責任を持つ明確なオーナーシップがある
● 変更についてレビューを経る(そしてドキュメント化対象のコードとともに変更される)
● コード内でバグが追跡されるように、ドキュメントの問題が追跡されるようにする
● 定期的に評価される(ある点ではテストされる)
● 可能なら、正確性や鮮度等の面で計測される(この点についてはまだツールが追いついていない)
```

```
ドキュメンテーションをソースコントロール下に移すのは、最初は大いに論争の的になった。
多くのエンジニアが、情報の自由の砦としてのGooWikiを廃止すると、ドキュメンテーション作成の障壁(レビューが要ること、ドキュメントのオーナーが要ること、等)
が高くなるせいでドキュメンテーションの品質が劣化すると確信していた。
しかしそうはならなかった。ドキュメントの品質は上がったのだ。
```

### 10.4 対象読者を認識せよ

```
自分の対象読者はかつて自分がいたところにいるものの、自分が最近身につけたドメイン知識が対象読者には欠けているのだ ということを、肝に銘じておこう。
```

#### 10.4.1 対象読者の類型

対象読者のレベルいかんに関わらず、ドキュメントを短く保つことが良い。

対象読者を捜索者、遭遇者で分ける。

```
● 捜索者は、自分の欲しい物がわかっているエンジニアで、目にしているものが要件を満たすかどうかを知りたがっている。この対象読者に道を示す工夫として鍵となるのは、一貫性である。例えばコードのファイル内で、このグループに向けてリファレンスのドキュメンテーションを書いているなら、読者が素早くリファレンスを走り読みすれば探しているものが見つかることがわかるように、自分のコメント群が似通った形式を踏襲するようにしておきたい。
● 遭遇者は、自分が正確には何を欲しいのかわかっていないかもしれない。遭遇者は、自分が取り掛かっているものの実装方法について曖昧な考えを持っているだけかもしれない。この対象読者にとって鍵となるのは、明確性である。見ているコードの目的を説明する概要か前置きを(例えばファイル冒頭で)提供すべきだ。ドキュメントが対象読者にとって適切ではない場合を特定することも役に立つ。多くのGoogleのドキュメントは「TL;DR:GoogleのC++コンパイラーに関心がない場合、ここで読み進めるのをやめることができる」のような「TL;DR宣言文」で始まる。
```

利用者(APIユーザー)、提供者(PJメンバ)の区分もある。

### 10.5 ドキュメンテーションの類型

1つのドキュメントで複数のことをやろうとすることは避けるべき。

ドキュメントには類型があるが、それを混ぜないこと。

```
● コードのコメントが含まれたリファレンスドキュメンテーション
● デザインドキュメント
● チュートリアル
● 概念的ドキュメンテーション
● ランディングページ(landing page)
```

#### 10.5.1 リファレンスドキュメンテーション

---

### 10.7 ドキュメンテーション哲学

Googleでどうやっているかというよりは、技術的な文章の書き方のベストプラクティスを述べている章。

#### 10.7.1 誰が、何を、いつ、どこで、なぜ

5wを省きがち。howが一番大事なのはそうだが、書かないと分かりづらい。

```
● WHOは前に論じた。それは対象読者だ。しかし、ドキュメント内で明示的に対象読者を指摘して対応するようにもしないといけないことがある。例:「このドキュメントは、『秘密の魔術師』プロジェクトの新人エンジニア用である。」
● WHATは、そのドキュメントの目的を特定する。例:「このドキュメントは、テスト環境でFrobberサーバーを起動させるために設計されたチュートリアルである。」単にWHATを書くだけでも、ドキュメントを適切に組み立てるのに役立つことが時にはある。WHATに当てはまらない情報を追加しだすことがあれば、その情報は別のドキュメントに移した方がよいかもしれない。
● WHENは、そのドキュメントが作成されたとき、レビューされたとき、更新されたときを特定する。ソースコード内のドキュメントはこの日付が暗黙的に記載されており、他のある公開処理の仕組みではこれは自動化されてもいる。しかし、それ以外の場合、ドキュメント自体にそのドキュメントが書かれた(もしくは最後に更新された)日付を必ず記載すべきだ。
● WHEREもまた暗に示されている場合が多いが、そのドキュメントがどこに存在すべきかを決定しなければならない。通常、選ばれる場所はある種のバージョンコントロールシステム下であるべきで、理想的にはそのドキュメントがドキュメント化している対象のソースコードとともに存在すべきだ。しかし別の目的向けであれば他の形式でも機能する。Googleでは、特に設計の問題について、共同作業を簡単に行うためにGoogleDocsをよく使う。しかしある時点で、どんな共有ドキュメントも議論というよりは永続的な履歴の記録となる。その時点でそのドキュメントは、明確なオーナーシップやバージョンコントロールや責任を備えた、もっと永続的などこかの場所に移すべきだ。
● WHYはそのドキュメントの目的を確立する。そのドキュメントの読後に覚えておくことが期待される教訓を要約しなければならない。経験則上良いやり方は、ドキュメントの導入部でWHYを確立するというものだ。要約を書く際には、元の期待に沿っているかどうかを検証すべきである(そして、検証結果に従って修正しなければならない)。
```

whereはなるほどなという感じ。まずどこかで練って、永続化する段階でversion管理下に置く。

#### 10.7.2 始まり、中盤、終わり



#### 10.7.3 優れたドキュメンテーションの特徴的要素

完全性、正確性、明確性のこと。
全てを揃えることは難しく、そのドキュメントの性質によってどの特徴を備えるべきかかわる。

#### 10.7.4 ドキュメントを廃止する

なんの目的も果たしていないドキュメントは捨てるか古いとマークするかすべき。

### 10.8 テクニカルライターが必要なのはどんな時か

自分達のプロジェクトを外から見た時の情報を書きたい時は一考に値するかもしれない。
自分達のPJに必要なものは申し分なく書ける。

### 10.9 結論

Googleにおいてもドキュメントはテストほど第一級の扱いを受けていない。

### 10.10 要約

```
- ドキュメンテーションは、長期的かつスケールの観点から見て、極めて重要である。
- ドキュメンテーションの変更は、既存の開発者ワークフローを活用すべきである。
- ドキュメントは 1 つの目的に専念したものにとどめておかなければならない。
- ドキュメンテーションは対象読者に向けて書くべきであり、自分自身のために書くべきではない。
```

