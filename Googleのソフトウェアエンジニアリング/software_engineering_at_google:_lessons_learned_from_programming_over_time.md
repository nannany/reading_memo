プログラミングというよりはエンジニアリングについての本。

持続可能なソフトウェアエコシステムについて、Googleの知見を述べていく本。

トピックとしては大きく、
- 文化
- プロセス
- ツール

について扱っていく。


# 第1部 主題

## 1章 ソフトウェアエンジニアリングとは何か

プログラミングとソフトウェアエンジニアリングの違いは3つ。

- 時間
- スケール
- トレードオフ

```
本書が目指すのは、Googleで、何万人ものエンジニアと世界中に広がるコンピュートリソースとを用いて、何十年も存続する見込みのソフトウェアの構築と保守を行う際に、効果があると突き止められたものを公開することだ。
```

### 1.1 時間と変化

google検索、linuxカーネル、apache httpサーバーなどは宿題やスタートアップのコードとは違い長期間動作することが求められる。

アップグレードを最初から計画していなかったpjでは下記の理由から移行に苦痛が伴う。

- プロジェクトでまだ行われたことのないタスクを実行することになるため、より多くの隠れた前提条件が組み込まれている。
- アップグレードを試みるエンジニアは、この種のタスクの経験がある可能性が低い。
- どちらかといえばインクリメンタル(incremental:段階的に増える)なアップグレードでは なく複数年分のアップグレードをやっているので、アップグレードのサイズが通常より大きい場合が多い。

#### 1.1.1 Hyrumの法則

Hyrumの法則
```
あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様として何を約束しているかは重要ではない。
作られたシステムが持つあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである。
```

これでピンとくるか？？複雑度はAPIが使われるに従って上がる、という理解をした。
APIを公開して、暗黙の依存関係ができて、それが複雑度につながる。

#### 1.1.2 例: ハッシュの順序付け

ハッシュの順序付けを例にとって、Hyrumの法則について説明している。

ハッシュテーブルは内部的には順序を持っているが、ハッシュ実装者が意図してそうなっているというよりは勝手にそうなったもの。
このような意図せずに発生した仕様に依存して何者かが作成されると厄介。
これがHyrumの法則の一例。`作られたシステムが持つあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである。`

#### 1.1.3 「何も変化しない」状態をとにかく目指すのはどうか
