プログラミングというよりはエンジニアリングについての本。

持続可能なソフトウェアエコシステムについて、Googleの知見を述べていく本。

トピックとしては大きく、
- 文化
- プロセス
- ツール

について扱っていく。


# 第1部 主題

## 1章 ソフトウェアエンジニアリングとは何か

プログラミングとソフトウェアエンジニアリングの違いは3つ。

- 時間
- スケール
- トレードオフ

```
本書が目指すのは、Googleで、何万人ものエンジニアと世界中に広がるコンピュートリソースとを用いて、何十年も存続する見込みのソフトウェアの構築と保守を行う際に、効果があると突き止められたものを公開することだ。
```

### 1.1 時間と変化

google検索、linuxカーネル、apache httpサーバーなどは宿題やスタートアップのコードとは違い長期間動作することが求められる。

アップグレードを最初から計画していなかったpjでは下記の理由から移行に苦痛が伴う。

- プロジェクトでまだ行われたことのないタスクを実行することになるため、より多くの隠れた前提条件が組み込まれている。
- アップグレードを試みるエンジニアは、この種のタスクの経験がある可能性が低い。
- どちらかといえばインクリメンタル(incremental:段階的に増える)なアップグレードでは なく複数年分のアップグレードをやっているので、アップグレードのサイズが通常より大きい場合が多い。

#### 1.1.1 Hyrumの法則

Hyrumの法則
```
あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様として何を約束しているかは重要ではない。
作られたシステムが持つあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである。
```

これでピンとくるか？？複雑度はAPIが使われるに従って上がる、という理解をした。
APIを公開して、暗黙の依存関係ができて、それが複雑度につながる。

#### 1.1.2 例: ハッシュの順序付け

ハッシュの順序付けを例にとって、Hyrumの法則について説明している。

ハッシュテーブルは内部的には順序を持っているが、ハッシュ実装者が意図してそうなっているというよりは勝手にそうなったもの。
このような意図せずに発生した仕様に依存して何者かが作成されると厄介。
これがHyrumの法則の一例。`作られたシステムが持つあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである。`

#### 1.1.3 「何も変化しない」状態をとにかく目指すのはどうか

持続可能性に投資していない長期プロジェクトは大きなリスクがある。

### 1.2 スケールと効率

#### 1.2.1 スケールしないポリシー

```
少し練習すれば、スケーリングについて難のある属性を持つポリシーを容易に見つけられるようになる。
通常、そうしたポリシーを特定するには、エンジニア1人に課される作業を考えた上で、組織が10倍か100倍スケールアップ(scaleup)†42する場合を想像してみればよい。
組織が10倍大きくなったら、標本(sample)とした1人のエンジニアが保持する作業量を10倍に増やすだろうか。
エンジニアがこなさなければならない作業量は、組織のサイズに応じて変動する、関数の値として増大するか。
その作業はコードベースのサイズに伴ってスケールアップするか。
これらのいずれかが真であるならば、その作業を自動化するか最適化するための何らかのメカニズム(mechanism:仕組み、機構)は設置されているか。
そのメカニズムがないならば、スケーリング上の問題がある状態だ。
```

#### 1.2.2 よくスケールするポリシー

組織が発展するのに伴ってコスト改善につながるのは、どんな種類のポリシーだろうか。

```
製品が、インフラストラ クチャーの変更の結果として障害や他の問題に陥った場合、問題が継続的インテグレーション
(Continuous Integration/CI)†51システムでのテストで表面化していなかったならば、インフラス トラクチャーの変更に落ち度はない
```
というポリシーが例に挙げられていた。

知識共有については3章でのべる。

#### 1.2.3 例：コンパイラーのアップグレード

https://ja.wikipedia.org/wiki/%E6%8A%95%E6%A9%9F%E7%9A%84%E5%AE%9F%E8%A1%8C#:~:text=%E6%8A%95%E6%A9%9F%E7%9A%84%E5%AE%9F%E8%A1%8C%EF%BC%88%E3%81%A8%E3%81%86%E3%81%8D%E3%81%A6%E3%81%8D,%E3%81%A7%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82

ビヨンセルールは導入できたら楽だなと思った。
インフラ改善を行った際に、特定のCIを回すことができれば、それはインフラ改善の影響ではないとするポリシー。

#### 1.2.4 左への移動

---

## 10章 ドキュメンテーション

```
エンジニアが質の高いドキュメンテーションをより楽に書けるようにするための鍵となるのは、
組織とともにスケールし既存ワークフローと調和するようなプロセスとツールの導入である。
```

### 10.1  何がドキュメントとして適格か

ここで述べるドキュメントは、エンジニアが業務遂行のために書く必要があるあらゆる補足的な文章をさす。
つまり、コードのコメントも含まれる。

### 10.2 なぜドキュメンテーションが必要なのか

ドキュメントは書いたものがすぐに恩恵に与れる類のものではないが、その後に何百回と読まれる可能性がある。
とてもスケールするものである。

ドキュメンテーションは以下のような質問に答えるのを手伝ってくれる。
```
● これらの設計上の決定は何故行われたのか。
● このコードを何故このやり方で実装したのか。
● 自分自身のコードを 2 年後に見ているとして、自分はこのコードを何故このやり方で実装したのか。
```

即時的に効果を得られないという理由以外に、なぜドキュメントを書くことが嫌われるか？

```
● エンジニアは、文章を書くことを、プログラミングのスキルとは別のスキルとみなすことが多い(このことが必ずしも事実ではないことの説明を試みていくことになるが、たとえ事実である場合でも、文章を書くことはソフトウェアエンジニアリングのスキルとは必ずしも別のスキルではない)。
● 自分が文章の書き手として有能であると感じてはいないエンジニアがいる。しかし、使えるドキュメンテーションを作成するのに英語が堪能である必要はない。自分自身の殻から少しだけ外にとにかく踏み出して、読み手の観点から物事を見てみなければならない。
● ツールの支援や開発者ワークフローへの統合が限られていることで、ドキュメンテーションを書くのがより難しくなっていることが多い。
● ドキュメンテーションが、余計な重荷、つまり別の保守対象とみなされ、既存コードの保守を楽にしてくれるようなものとはみなされていない。
```


ドキュメントが書き手、書き手の所属するグループに与える恩恵。

```
● ドキュメンテーションはAPIの定式化を補助する。ドキュメンテーションを書くことは、APIが意味をなしているかを理解する最も確実な方法である。往々にしてエンジニアは、ドキュメンテーションを書くこと自体を契機に、それを書かなければ疑問を呈することがなかったであろう設計上の決定を再検討するに至る。APIの説明や定義ができないのであれば、おそらくそのAPIの設計は不十分だ。
● ドキュメンテーションは、保守のロードマップと、履歴の記録を提供する。いかなる場合でもコード内で凝ったことをやるのは避けるべきだが、自分が2年前に書いたコードを見つめて間違っている点を見つけ出そうと試みる場合、良質なコメントが大いに助けになる。
● ドキュメンテーションは、コードをよりプロフェッショナルに見せ、アクセス数の増加を牽引する。開発者は自然と、しっかりドキュメント化されたAPIを、設計が比較的優れたAPIであると推測するだろう。それが常に事実とは限らないが、それらに高い相関性があることは少なくない。この利益はうわべだけのものに聞こえるが、全くそうではない。製品に良質なドキュメンテーションがあるかどうかは通常、製品の保守にどの程度力が入れられることになるかを非常に明確に示すものとなる。
● ドキュメンテーションがあると、他のユーザーの質問を誘発することが比較的少なくなるだろう。ドキュメンテーションを書く者にとって、これがおそらく最大の利益である。誰かに何かを一度ならず何度も説明しなければならないとしたら、通常はそのプロセスをドキュメント化することが合理的である。
```

### 10.3 ドキュメンテーションはコードのようなものである

ドキュメンテーションは以下のようなものであるべき。

```
● 従うべき内部的なポリシーかルールを持つ
● ソースコントロールシステムの管理下に置かれる
● そのドキュメントを保守する責任を持つ明確なオーナーシップがある
● 変更についてレビューを経る(そしてドキュメント化対象のコードとともに変更される)
● コード内でバグが追跡されるように、ドキュメントの問題が追跡されるようにする
● 定期的に評価される(ある点ではテストされる)
● 可能なら、正確性や鮮度等の面で計測される(この点についてはまだツールが追いついていない)
```

```
ドキュメンテーションをソースコントロール下に移すのは、最初は大いに論争の的になった。
多くのエンジニアが、情報の自由の砦としてのGooWikiを廃止すると、ドキュメンテーション作成の障壁(レビューが要ること、ドキュメントのオーナーが要ること、等)
が高くなるせいでドキュメンテーションの品質が劣化すると確信していた。
しかしそうはならなかった。ドキュメントの品質は上がったのだ。
```

### 10.4 対象読者を認識せよ

```
自分の対象読者はかつて自分がいたところにいるものの、自分が最近身につけたドメイン知識が対象読者には欠けているのだ ということを、肝に銘じておこう。
```

#### 10.4.1 対象読者の類型

対象読者のレベルいかんに関わらず、ドキュメントを短く保つことが良い。

対象読者を捜索者、遭遇者で分ける。

```
● 捜索者は、自分の欲しい物がわかっているエンジニアで、目にしているものが要件を満たすかどうかを知りたがっている。この対象読者に道を示す工夫として鍵となるのは、一貫性である。例えばコードのファイル内で、このグループに向けてリファレンスのドキュメンテーションを書いているなら、読者が素早くリファレンスを走り読みすれば探しているものが見つかることがわかるように、自分のコメント群が似通った形式を踏襲するようにしておきたい。
● 遭遇者は、自分が正確には何を欲しいのかわかっていないかもしれない。遭遇者は、自分が取り掛かっているものの実装方法について曖昧な考えを持っているだけかもしれない。この対象読者にとって鍵となるのは、明確性である。見ているコードの目的を説明する概要か前置きを(例えばファイル冒頭で)提供すべきだ。ドキュメントが対象読者にとって適切ではない場合を特定することも役に立つ。多くのGoogleのドキュメントは「TL;DR:GoogleのC++コンパイラーに関心がない場合、ここで読み進めるのをやめることができる」のような「TL;DR宣言文」で始まる。
```

利用者(APIユーザー)、提供者(PJメンバ)の区分もある。

### 10.5 ドキュメンテーションの類型

1つのドキュメントで複数のことをやろうとすることは避けるべき。

ドキュメントには類型があるが、それを混ぜないこと。

```
● コードのコメントが含まれたリファレンスドキュメンテーション
● デザインドキュメント
● チュートリアル
● 概念的ドキュメンテーション
● ランディングページ(landing page)
```

#### 10.5.1 リファレンスドキュメンテーション

---

### 10.7 ドキュメンテーション哲学

Googleでどうやっているかというよりは、技術的な文章の書き方のベストプラクティスを述べている章。

#### 10.7.1 誰が、何を、いつ、どこで、なぜ

5wを省きがち。howが一番大事なのはそうだが、書かないと分かりづらい。

```
● WHOは前に論じた。それは対象読者だ。しかし、ドキュメント内で明示的に対象読者を指摘して対応するようにもしないといけないことがある。例:「このドキュメントは、『秘密の魔術師』プロジェクトの新人エンジニア用である。」
● WHATは、そのドキュメントの目的を特定する。例:「このドキュメントは、テスト環境でFrobberサーバーを起動させるために設計されたチュートリアルである。」単にWHATを書くだけでも、ドキュメントを適切に組み立てるのに役立つことが時にはある。WHATに当てはまらない情報を追加しだすことがあれば、その情報は別のドキュメントに移した方がよいかもしれない。
● WHENは、そのドキュメントが作成されたとき、レビューされたとき、更新されたときを特定する。ソースコード内のドキュメントはこの日付が暗黙的に記載されており、他のある公開処理の仕組みではこれは自動化されてもいる。しかし、それ以外の場合、ドキュメント自体にそのドキュメントが書かれた(もしくは最後に更新された)日付を必ず記載すべきだ。
● WHEREもまた暗に示されている場合が多いが、そのドキュメントがどこに存在すべきかを決定しなければならない。通常、選ばれる場所はある種のバージョンコントロールシステム下であるべきで、理想的にはそのドキュメントがドキュメント化している対象のソースコードとともに存在すべきだ。しかし別の目的向けであれば他の形式でも機能する。Googleでは、特に設計の問題について、共同作業を簡単に行うためにGoogleDocsをよく使う。しかしある時点で、どんな共有ドキュメントも議論というよりは永続的な履歴の記録となる。その時点でそのドキュメントは、明確なオーナーシップやバージョンコントロールや責任を備えた、もっと永続的などこかの場所に移すべきだ。
● WHYはそのドキュメントの目的を確立する。そのドキュメントの読後に覚えておくことが期待される教訓を要約しなければならない。経験則上良いやり方は、ドキュメントの導入部でWHYを確立するというものだ。要約を書く際には、元の期待に沿っているかどうかを検証すべきである(そして、検証結果に従って修正しなければならない)。
```

whereはなるほどなという感じ。まずどこかで練って、永続化する段階でversion管理下に置く。

#### 10.7.2 始まり、中盤、終わり



#### 10.7.3 優れたドキュメンテーションの特徴的要素

完全性、正確性、明確性のこと。
全てを揃えることは難しく、そのドキュメントの性質によってどの特徴を備えるべきかかわる。

#### 10.7.4 ドキュメントを廃止する

なんの目的も果たしていないドキュメントは捨てるか古いとマークするかすべき。

### 10.8 テクニカルライターが必要なのはどんな時か

自分達のプロジェクトを外から見た時の情報を書きたい時は一考に値するかもしれない。
自分達のPJに必要なものは申し分なく書ける。

### 10.9 結論

Googleにおいてもドキュメントはテストほど第一級の扱いを受けていない。

### 10.10 要約

```
- ドキュメンテーションは、長期的かつスケールの観点から見て、極めて重要である。
- ドキュメンテーションの変更は、既存の開発者ワークフローを活用すべきである。
- ドキュメントは 1 つの目的に専念したものにとどめておかなければならない。
- ドキュメンテーションは対象読者に向けて書くべきであり、自分自身のために書くべきではない。
```

