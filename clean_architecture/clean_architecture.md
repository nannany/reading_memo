# 序文

* アーキテクチャのルールはいつの時代も変わらない。

# 第一部 イントロダクション

## 1章 設計とアーキテクチャ

* ソフトウェアアーキテクチャの目的は、求められるシステムを構築・保守するために必要な人材を最小限に抑えることである
* 短期的にも、長期的にも、クリーンなコードを書くほうが早い

## 2章 2つの価値のお話

* ここでの2つの価値は、振る舞いとアーキテクチャ。
* ソフトウェア開発チームには、機能の緊急性よりもアーキテクチャの重要性を強く主張する義務がある

# 第二部 構成要素から始めよ：プログラミングパラダイム

## 3章 パラダイムの概要

* 構造化プログラミング：直接的な制御の移行に規律を課すものである。
* オブジェクト指向プログラミング：間接的な制御の移行に規律を課すものである。
* 関数型プログラミング：代入に規律を課すものである。
* これらのパラダイムは、何をすべきでないか、を伝えている。

## 4章 構造化プログラミング

## 5章 オブジェクト指向プログラミング

* OOとは「ポリモーフィズムを使用することで、システムにあるすべてのソースコードの依存関係を絶対的に制御する能力」


## 6章 関数型プログラミング

* 十分な記憶容量と処理能力があれば、アプリケーションを完全に不変にできる

# 第三部 設計の原則

* SOLID原則

## 7章 SRP：単一責任の原則

* SRP：モジュールはたった一つのアクターに対して責務を負うべきである

## 8章 OCP：オープン・クローズドの原則


## 9章 LSP：リスコフの置換原則

* リスコフの置換原則はアーキテクチャレベルにも適用できる


## 10章 ISP：インターフェース分離の原則

* 必要としないものに依存していると、思わぬトラブルに巻き込まれる

## 11章 DIP：依存関係逆転の原則

* システム内の変化しやすい具象要素には依存したくない

# 第四部 コンポーネントの原則

## 12章 コンポーネント

* コンポーネントはデプロイの単位を表す

## 13章 コンポーネントの凝集性

* 再利用・リリース等価の原則（REP）：一つのコンポーネントを形成するクラスやモジュールは、まとめてリリース可能であるべき
* 閉鎖性共通の原則（CCP）：同じタイミングで変更されることが多いクラスは一つにまとめておく
* 全再利用の原則（CRP）：密結合していないクラスを同じコンポーネントにまとめるべきでない
* 上記は互いに相反するところがある。プロジェクトのフェーズによって何を重視するか変わってくる




## 17章 バウンダリー：境界線を引く

* 優れたアーキテクチャは決定を先延ばしにできる

### 結合の悲しい物語

* 早くに方式を決め込みすぎて失敗した例が多い

### FitNesse

* ずっとDBの決定をせずに開発を進めることができた

### あなたの境界線は何か？いつ境界線を引くのか？

* ビジネスルールからDBには依存しないようにする。DBからビジネスルールに依存するようにする

### 入力と出力はどうする？

* GUIがビジネスルールに依存する

### プラグインアーキテクチャ

### プラグインの戦い

### まとめ

* コアなビジネスロジックのコンポーネントに向かって、他のコンポーネントは依存の矢印を向けるべき

## 18章 境界の解剖学

### 境界を超える

* 

### 恐怖のモノリス

* 制御の流れの依存性を逆転させることで、下位レベルが上位レベルに依存するようにする。

### デプロイコンポーネント

### スレッド

### ローカルプロセス

### サービス

### まとめ

* レイテンシに関わる境界とそうでない境界が混在している


## 19章 方針とレベル

* 同じ理由、時期で変更される方針は、同じレベルの同じコンポーネントにまとめておく

### レベル

* レベルの定義は、入力と出力からどれだけ離れているか。入出力から離れているほど高くなる
* 低レベルのコンポーネントが、高レベルのコンポーネントに依存するようにする

### まとめ


## 20章 ビジネスルール

* システムによる自動化に関わらず存在する、ビジネスルール、データをそれぞれ、最重要ビジネスルール、最重要ビジネスデータと呼ぶ
* 最重要ビジネスルール、最重要ビジネスデータに関するオブジェクトをエンティティと呼ぶ

### エンティティ

