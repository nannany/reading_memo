# はじめに

### 近年のIT業界について説明

データベースや分散システムがめっちゃ発達しましたよ。

### データ指向についての定義
そもそもデータ指向とは？

```
本書では、CPUのサイクルがボトルネックとなる演算指向のアプリケーションに対して、
データの量や複雑さ、変化の速度が主な課題であるアプリケーションのことをデータ指向と呼びます。
```

### この本の目的

* 技術の進歩は早くとも、その裏には原理原則がある。
* データシステムがどのように動作するかだけではなく、なぜそのような動きになるかを見出していく。

## 本書が対象とする読者

* たとえば数百万のユーザーを持つ Web アプリケーションやモバイルアプリケーションをサ ポートするために、データシステムをスケーラブルにする方法を学びたい。
* アプリケーションの可用性を高め(すなわちダウンタイムを最小限にとどめ)、頑健な運用 を実現する必要がある。
* システムが成長し、要件や技術が変化していっても、長期的に見てシステムをメンテナンス しやすくする方法を知りたい。
* システムの動作に対して自然に関心があり、大きな Web サイトやオンラインサービスの内 部で何が起きているのかを知りたい。本書は、様々なデータベースやデータ処理のシステム の内部をブレークダウンしていきますが、そういったシステムの中にある賢明な考え方を探 索していくことは大変楽しいことです。

## 本書が対象とする範囲

```
本書で主に見ていくのはデータシステムのアーキテクチャであり、
データシステムが組み合わさってデータ指向のアプリケーションになっていく様子です。
本書には、デプロイメント、運用、 セキュリティ、管理やその他の領域を取り上げる紙面がありません。
これらは複雑で重要な話題で あり、本書では表面的に脚注で取り上げるようなやり方はしません。
これらは専門の書籍で学ぶのにふさわしい話題です。
```

## 本書の概要

1部であらゆるシステムの基礎概念
2部で分散配置されたデータに関すること
3部でデータセット間の情報のやり取りに関すること

# 第1部　データシステムの基礎

１〜４章ではあらゆるデータシステムに当てはまる基本的な概念を見ていく。

## 1章 信頼性、スケーラビリティ、メンテナンス性に優れたアプリケーション

```
本章では、まず私たちが実現しようとしている目標である、信頼性とスケーラビリティを持ちながらメンテナンスしやすいデータシステムの基礎を調べていきます。
そういったことが何を意味するのかを明確にし、それらについての考え方の概要を見て、今後の章で必要になる基礎を押さえていきます。
今後の章はレイヤーごとに進んでいき、データ指向アプリケーションを扱う際に考慮しなければならない設計上の様々な判断を見ていきます。
```


### 1.1 データシステムに関する考察

なぜデータベース、キュー、キャッシュをデータシステムとして一括りで捉えるのか？
いっぱいツールがあって、境界線が曖昧

データシステムの設計における重要な課題として、下記３点に焦点を当てる。

* 信頼性
  * システムは障害があったとしても正しく動き続けるべき
  * 1.2章参照
* スケーラビリティ
  * システムの成長に対して、無理のない方法で対応可能であるべき
  * 1.3章参照
* メンテナンス性
  * 時間が経つにつれて、システムには多くの様々な人々が関わる。こういった人々がシステムの生産性に関われるべき
  * 1.4章参照

### 1.2 信頼性

```
大まかに言って信頼性とは「何か 問題が生じたとしても正しく動作し続けること」と言えるでしょう。
```

```
妥当なのはある種のフォールトに対する耐性について議論することだけなのです。
```

```
本書で扱うフォールトの多くは回復が可能な種類のものです。
```

### 1.2.1 ハードウェアの障害

RAIDやら電源の二重化など、ハードウェアコンポーネントの冗長化で故障率を下げている。

### 1.2.2 ソフトウェアのエラー

システマティックなエラー

* ソフトウェアのバグ。問題のある特定の入力が与えられると、すべてのアプリケーションサーバーのインスタンスがクラッシュしてしまうようなものです。たとえば、2012年6月30日うるう秒の際には、Linuxカーネル中のバグのために多くのアプリケーションが同時にハングしてしまいました [9]。
* プロセスの暴走。CPU時間、メモリ、ディスク領域、ネットワーク帯域など、何らかの共 有リソースを使い切ってしまいます。
* システムが依存しているサービスの問題。システムが依存しているにもかかわらずサービス がスローダウンしてレスポンスを返さなくなったり、壊れたレスポンスを返したりし始めて しまうような場合。
* カスケード障害。これは、1 つのコンポーネント中の小さなフォールトが他のコンポーネン トのフォールトを引き起こし、そしてそのフォールトがさらなるフォールトを引き起こして いくような障害です [10]。

### 1.2.3 ヒューマンエラー

人は信頼できないので、それを踏まえて設計せよ。

* エラーの可能性が最小限になるようにシステムを設計する。たとえば、うまく設計された抽 象化、API、管理インターフェースは、「正しいこと」を行いやすく、「間違ったこと」を行 いにくくしてくれます。ただし、あまりにインターフェースの制約が強くなると、人々はそ れを回避しようとするようになるので、この方策のメリットが損なわれてしまいます。バラ ンスを適切に取るのが難しいところです。
* 人々が最も間違いを犯しやすい部分を、間違いがあれば障害につながりやすいところから分 離します。特に、完全な機能を持ったサンドボックス環境をプロダクション環境とは別に提 供し、実際のユーザーに影響することなく本物のデータを使って実体験を積めるようにする と良いでしょう。
* ユニットテストからシステム全体の結合テストやマニュアルテストまで、すべてのレベルで 徹底的なテストを行いましょう [3]。自動化テストは広く利用され、十分に理解されており、 特に通常の操作では滅多に生じないようなコーナーケースをカバーする上で有益です。
* ヒューマンエラーから迅速かつ容易にリカバリできるようにして、障害が発生した場合のイ ンパクトを最小化できるようにしておきましょう。たとえば、設定の変更のロールバックを 即座にできるようにしておいたり、新しいコードのロールアウトは徐々に行っていったり(こうすることで、予想外のバグがあっても影響されるユーザーを一部にとどめることがで きます)、データを計算し直すツールを提供したり(それまでの計算が正しくないことが判 明した場合に備えて)しましょう。
* パフォーマンスメトリクスやエラーの発生率など、詳細で明確なモニタリングの仕組みを セットアップしましょう。他のエンジニアリング分野では、これはテレメトリと呼ばれます (いったん離陸してしまったロケットで起こっていることを追跡し、障害について理解する ためにはテレメトリが欠かせません [14])。モニタリングを行えば、警告シグナルを早期に 受けることができ、何らかの前提や制約に反していないかをチェックできます。問題が生じた場合、その診断にはメトリクスが欠かせません。
* 優れた管理方法とトレーニングを実践しましょう。これは複雑で重要なことであり、本書の範囲を超えています。

### 1.2.4 信頼性の重要度

## 1.3 スケーラビリティ

### 1.3.1 負荷の表現

```
最適なパラメータの選択がどのようなものになるかは、システムのアーキテクチャに依存します。
Webサーバーなら毎秒のリクエスト数、データベースなら読み書きの比率、チャットルームなら同時アクティブユーザー数、
キャッシュならヒット率などがそうです。おそらくは、平均的な状況が問題になる場合もあれば、
あるいは少数の極端なケースが支配的なボトルネックになっている場合もあるでしょう。
```

Twitterのタイムラインの実装例を出している。これは面白い。

### 1.3.2 パフォーマンスの表現

バッチ処理だとスループット、オンラインシステムだとレスポンスタイムが大事

レスポンスタイムとレイテンシの違いの話、よくわからん。説明下手。

典型的なレスポンスタイムを知るにはパーセンタイルを用いるべき


**HOLブロッキング**
少数の遅いリクエストがキュー詰まりをおこし、それ以外のリクエストにも影響を及ぼすこと。


### 1.3.3 負荷への対処のアプローチ

水平スケール、垂直スケール
手動拡張、自動拡張（エラスティック）
様々なアプローチがある。

```
本書ではこの後、多くの種類の分散データシステムを取り上げ、それらがスケーラビリティだけでなく、
使いやすさやメンテナンス性という面も考慮してやりくりしていることを論じていきます。
```

```
本書では、これらのビルディングブロックやパターンについて述べていきます。
```

## 1.4 メンテナンス性

メンテを容易にするために気をつけるべき設計原理

* 運用性
* 単純性
* 進化性

### 1.4.1 運用性：運用担当者への配慮

運用で負う仕事。運用作業とはよく聞くものの、あまり具体例を上げてみたことないからためになった。

* システムの健全性をモニタリングし、その状態が悪くなれば素早くサービスを回復させる。
* システムの障害やパフォーマンスの低下といった問題の原因を発見する。
* ソフトウェアやプラットフォームを最新の状態に保つ。これにはセキュリティパッチも含まれる。
* 様々なシステムの相互作用に注目し、問題がありそうな変更があれば、それがダメージを生じさせる前に回避する。
* 将来の問題を予想し、それらを発生前に解決する(たとえばキャパシティプランニング)。
* デプロイメント、設定管理などのための優れたプラクティスやツールを確立する。
* プラットフォーム間でのアプリケーションの移動など、複雑なメンテナンスタスクを実行する。
* 設定変更の際にシステムのセキュリティのメンテナンスを行う。
* 運用で予想外のことが起こらないようにプロセスを定義し、プロダクション環境の安定を保つ。
* 個人の出入りがあっても、システムに関する組織の知識が保たれるようにする。

### 1.4.2 単純さ：複雑さの管理

複雑さを取り除く優れた手段が抽象化

### 1.4.3 進化性：変更への配慮

変更のしやすさと単純さは密接に関わる。


# まとめ

# 2章 データモデルとクエリ言語

様々なデータモデルの比較

クエリ言語とそれらのユースケースを見ていく

## 2.1 リレーショナルモデルとドキュメントモデル

基本的にはリレーショナルモデルが圧勝

この辺の偉大さは達人に学ぶSQLの13章RDB近代史が詳しい。

### 2.1.1 NoSQLの誕生

### 2.1.2 オブジェクトとリレーショナルのミスマッチ

リレーショナルデータベースとオブジェクト指向言語間のやりとりでは変換レイヤーが必要。
このモデル間の断絶のことをインピーダンスミスマッチという。

LinkedInの履歴書の例を出している。

履歴書みたいな、それで完結しているような物に関してはJSONで表現する方が向いているかもしれない。

jsonでの表現にも問題はある。それは４章で見ていく。データエンコードの話っぽい。

### 2.1.3 多対一と多対多の関係

複製の排除がデータベースの正規化の鍵となる考え方。
正規化に関しては３部でちゃんと見る。

ドキュメントデータベースは結合が弱かったりする。
正規化の概念もないから、やたら複製が生まれたりもする。

### 2.1.4 ドキュメントデータベースは歴史を繰り返すのか？

ドキュメントデータベースが直面する問題は1970年代あたりにも、
ネットワークモデルとリレーショナルモデルの文脈で同様の議論がされていた。

#### 2.1.4.1 ネットワークモデル

あるレコードに行き着くまでの経路が入り組んでいるので、データモデルに変更を加えるのが困難だった。

#### 2.1.4.2 リレーショナルモデル

データのアクセス方法はクエリオプティマイザが決めてくれる。

```
クエリオプティマイザがなければ、汎用のオプティマイザを書くよりも、
特定のクエリのためにアクセスパスを手作業でコーディングするほうが楽でしょう。
しかし、長い目で見れば勝っているのは汎用的なソリューションなのです。
```

#### 2.1.4.3 ドキュメントデータベースとの比較

ドキュメントデータベースとネットワークデータベースの共通点は、
ネストされたレコードを、どちらも独立したテーブルではなく親のレコードに保存する点。

多対多、多対一の表現の面ではリレーショナルモデルとドキュメントデータベースで基本的な違いはない。

### 2.1.5 今日のリレーショナルデータベースとドキュメントデータベース

rdbとドキュメントのデータモデルに関する比較をしていく。

```
ドキュメントデータモデルを支持する議論には、主にスキーマの柔軟性、ローカリティから来る
優れたパフォーマンス、そしてアプリケーションによってはデータ構造がアプリケーションのもの
に近いことがあります。逆にリレーショナルデータベースは、結合や多対一及び多対多の関係のサ
ポートに優れています。
```

#### 2.1.5.1 アプリケーションのコードをシンプルにしてくれるデータモデルは?

- アプリを単純にしてくれるのはドキュメントデータモデルの方かも
  - 一発でツリー構造のデータを引っ張れる

ごちゃごちゃ言ってるが、結論としては下記。データ間の関係性による。

```
どのようなデータモデルを用いればアプリケーションのコードがシンプルなものになるのかを一般論として述べることはできません。
これは、データのアイテム間に存在する関係の種類に依存します。データ間の関係性が強い場合、ドキュメントモデルは扱いにくく、
リレーショナルモデルは許容範囲であり、グラフモデルが最も自然です(p.51「2.3 グラフ型のデータモデル」参照)。
```

#### 2.1.5.2 ドキュメントモデルにおけるスキーマの柔軟性

- スキーマオンリード、スキーマオンライト
  - 読み込むときにチェックするか、書き込むときにチェックするか

どちらを選択するかは重要だよ。


#### 2.1.5.3 クエリのためのデータローカリティ

ローカリティ＝データの局所性のこと

例えば一つのWebページを表示するときに、必要なデータがまとまっていると早く返せるよね、みたいな話。

#### 2.1.5.4 ドキュメント及びリレーショナルデータベースの融合

最近はリレーショナルデータベースの一カラムとしてJSONを持つことができるようになってきている。

## 2.2 データのためのクエリ言語

- SQLは宣言的、IMSやCODASYLは命令的

### 2.2.1 Web 上での宣言的クエリ

命令的なクエリよりも宣言的なクエリの方が優れている。

### 2.2.2 MapReduce でのクエリ

MapReduceの全体像は10章を参照。

reduceがむずい。

## 2.3 グラフ型のデータモデル



----

# 7章 トランザクション

トランザクションにまつわる問題をみていき、そういった問題に対する保護策としてデータベースがどのようなアルゴリズムを用いているか調べていく。

## 7.1 トランザクションというとらえどころのない概念

トランザクションにはメリットと限界がある。それらのトレードオフを理解するために、トランザクションがもたらす保証の詳細を見ていく。

### 7.1.1 ACIDの意味

トランザクションが提供する安全性の保証はしばしばACIDという短縮語で表される。

ACID という言葉自体は結構曖昧なところがある。
それぞれの定義を掘り下げていく。

#### 7.1.1.1 原子性

DBの文脈では、原子性というよりは中断可能性といった方がいいかも。

#### 7.1.1.2 一貫性

一貫性という言葉で色々な意味を表すが、ACIDの文脈においては下記のような意味。

```
“ACIDにおける一貫性という概念は、データについて常に真でなければならない何らかの言明（不変性）があるということです。”
```

なので、外部キー制約などで一部担保することはできるものの、ここはデータベースだけで担保できるものではなく、アプリケーションでチェックしないといけないものである。

#### 7.1.1.3 分離性

```
“ACIDにおける分離性とは、並行して実行されたトランザクションがお互いから分離されており、お互いのつま先を踏みつけあうようなことがないという意味です。”
```

#### 7.1.1.4 永続性

```
“データベースシステムが目的とするのは、データを失う恐れなく保存できる安全な場所を提供することです。永続性は、トランザクションのコミットが成功したら、仮にハードウェアの障害やデータベースのクラッシュがあったとしても、そのトランザクションで書き込まれたすべてのデータは失われないことを約束するものです。”
```

### 7.1.2 単一オブジェクトと複数オブジェクトの操作

原子性
```
“一連の書き込みの途中でエラーが生じた場合、トランザクションを中断し、その時点までに行われた書き込みは破棄しなければなりません。言い換えれば、部分的な障害についてはユーザーが気にしなくすむよう、オールオアナッシングの保証を提供することによってデータベースが面倒を見ます。”
```

分離性
```
“並行に実行されているトランザクションがお互いに影響しあわないようにします。たとえばあるトランザクションがいくつかの書き込みを行った場合、別のトランザクションからはそれらの書き込みの一部だけが見えるようなことにはならず、すべての書き込みがまったく見えないか、すべての書き込みが見えるかのどちらかにします。”
```

#### 7.1.2.1 単一のオブジェクトへの書き込み

ここで言いたいことはよく理解できず。
そもそも単一のオブジェクトとはなんだ。

#### 7.1.2.2 複数オブジェクトのトランザクションの必要性


#### 7.1.2.3 エラーと中断の処理

リトライについて述べている。

## 7.2 弱い分離レベル

完璧なトランザクションの分離性を求めるとパフォーマンス上の問題となるので、ある種の並行性の問題だけを保護するようなシステムが一般的。

```
“このセクションでは、実際に利用されているいくつかの弱い（直列化可能ではない）分離性のレベルを見ていき、どういった種類のレース条件が生じうるのか、あるいは生じることがないのかを論じていきます。”
```

### 7.2.1 Read Committed

このレベルが保証することは2つ。

- データベースからの読み取りを行った際に見えるデータは、コミットされたもののみであること（ダーティリードは生じない）
- データベースへの書き込みを行う場合、上書きするのはコミットされたデータのみであること（ダーティライトは生じない）

#### 7.2.1.1 ダーティリードが生じないこと

ここは一般的なダーティリードの話

#### 7.2.1.2 ダーティライトが生じないこと

ダーティーライトは聞いたことなかった。

#### 7.2.1.3 read committedの実装

ダーティーライトを避けるにあたっては行ロックをとる。


### 7.2.2 スナップショット分離とリピータブルリード

ノンリピータブルリードについての説明。

バックアップを取るときなどは、ノンリピータブルリードを起こしてはならない。

これの対処としては、ある地点のスナップショット分離を用いる。

#### 7.2.2.1 スナップショット分離の実装

複数のバージョンの状態を管理することによって、一貫性のある状態でロングクエリを実行できるようにしてるみたい。

MVCCなる仕組みを用いて、複数のバージョンを保持する模様。

```
“この場合、進行中の複数のトランザクションからそれぞれ異なる時点のデータベースの状態が見えなければならないかもしれず、そうなればデータベースはオブジェクトの複数のコミット済みバージョンを保持しなければならなくなります。データベースはあるオブジェクトについて複数のバージョンを並べて管理することになるので、この手法はMVCC（multi-version concurrency control、マルチバージョン並行性制御）と呼ばれます。”
```

#### 7.2.2.2 一貫したスナップショットを見るための可視化ツール


