# はじめに

### 近年のIT業界について説明

データベースや分散システムがめっちゃ発達しましたよ。

### データ指向についての定義
そもそもデータ指向とは？

```
本書では、CPUのサイクルがボトルネックとなる演算指向のアプリケーションに対して、
データの量や複雑さ、変化の速度が主な課題であるアプリケーションのことをデータ指向と呼びます。
```

### この本の目的

* 技術の進歩は早くとも、その裏には原理原則がある。
* データシステムがどのように動作するかだけではなく、なぜそのような動きになるかを見出していく。

## 本書が対象とする読者

* たとえば数百万のユーザーを持つ Web アプリケーションやモバイルアプリケーションをサ ポートするために、データシステムをスケーラブルにする方法を学びたい。
* アプリケーションの可用性を高め(すなわちダウンタイムを最小限にとどめ)、頑健な運用 を実現する必要がある。
* システムが成長し、要件や技術が変化していっても、長期的に見てシステムをメンテナンス しやすくする方法を知りたい。
* システムの動作に対して自然に関心があり、大きな Web サイトやオンラインサービスの内 部で何が起きているのかを知りたい。本書は、様々なデータベースやデータ処理のシステム の内部をブレークダウンしていきますが、そういったシステムの中にある賢明な考え方を探 索していくことは大変楽しいことです。

## 本書が対象とする範囲

```
本書で主に見ていくのはデータシステムのアーキテクチャであり、
データシステムが組み合わさってデータ指向のアプリケーションになっていく様子です。
本書には、デプロイメント、運用、 セキュリティ、管理やその他の領域を取り上げる紙面がありません。
これらは複雑で重要な話題で あり、本書では表面的に脚注で取り上げるようなやり方はしません。
これらは専門の書籍で学ぶのにふさわしい話題です。
```

## 本書の概要

1部であらゆるシステムの基礎概念
2部で分散配置されたデータに関すること
3部でデータセット間の情報のやり取りに関すること

# 第1部　データシステムの基礎

１〜４章ではあらゆるデータシステムに当てはまる基本的な概念を見ていく。

## 1章 信頼性、スケーラビリティ、メンテナンス性に優れたアプリケーション

```
本章では、まず私たちが実現しようとしている目標である、信頼性とスケーラビリティを持ちながらメンテナンスしやすいデータシステムの基礎を調べていきます。
そういったことが何を意味するのかを明確にし、それらについての考え方の概要を見て、今後の章で必要になる基礎を押さえていきます。
今後の章はレイヤーごとに進んでいき、データ指向アプリケーションを扱う際に考慮しなければならない設計上の様々な判断を見ていきます。
```


### 1.1 データシステムに関する考察

なぜデータベース、キュー、キャッシュをデータシステムとして一括りで捉えるのか？
いっぱいツールがあって、境界線が曖昧

データシステムの設計における重要な課題として、下記３点に焦点を当てる。

* 信頼性
  * システムは障害があったとしても正しく動き続けるべき
  * 1.2章参照
* スケーラビリティ
  * システムの成長に対して、無理のない方法で対応可能であるべき
  * 1.3章参照
* メンテナンス性
  * 時間が経つにつれて、システムには多くの様々な人々が関わる。こういった人々がシステムの生産性に関われるべき
  * 1.4章参照

### 1.2 信頼性

```
大まかに言って信頼性とは「何か 問題が生じたとしても正しく動作し続けること」と言えるでしょう。
```

```
妥当なのはある種のフォールトに対する耐性について議論することだけなのです。
```

```
本書で扱うフォールトの多くは回復が可能な種類のものです。
```

### 1.2.1 ハードウェアの障害

RAIDやら電源の二重化など、ハードウェアコンポーネントの冗長化で故障率を下げている。

### 1.2.2 ソフトウェアのエラー

システマティックなエラー

* ソフトウェアのバグ。問題のある特定の入力が与えられると、すべてのアプリケーションサーバーのインスタンスがクラッシュしてしまうようなものです。たとえば、2012年6月30日うるう秒の際には、Linuxカーネル中のバグのために多くのアプリケーションが同時にハングしてしまいました [9]。
* プロセスの暴走。CPU時間、メモリ、ディスク領域、ネットワーク帯域など、何らかの共 有リソースを使い切ってしまいます。
* システムが依存しているサービスの問題。システムが依存しているにもかかわらずサービス がスローダウンしてレスポンスを返さなくなったり、壊れたレスポンスを返したりし始めて しまうような場合。
* カスケード障害。これは、1 つのコンポーネント中の小さなフォールトが他のコンポーネン トのフォールトを引き起こし、そしてそのフォールトがさらなるフォールトを引き起こして いくような障害です [10]。

### 1.2.3 ヒューマンエラー

人は信頼できないので、それを踏まえて設計せよ。

* エラーの可能性が最小限になるようにシステムを設計する。たとえば、うまく設計された抽 象化、API、管理インターフェースは、「正しいこと」を行いやすく、「間違ったこと」を行 いにくくしてくれます。ただし、あまりにインターフェースの制約が強くなると、人々はそ れを回避しようとするようになるので、この方策のメリットが損なわれてしまいます。バラ ンスを適切に取るのが難しいところです。
* 人々が最も間違いを犯しやすい部分を、間違いがあれば障害につながりやすいところから分 離します。特に、完全な機能を持ったサンドボックス環境をプロダクション環境とは別に提 供し、実際のユーザーに影響することなく本物のデータを使って実体験を積めるようにする と良いでしょう。
* ユニットテストからシステム全体の結合テストやマニュアルテストまで、すべてのレベルで 徹底的なテストを行いましょう [3]。自動化テストは広く利用され、十分に理解されており、 特に通常の操作では滅多に生じないようなコーナーケースをカバーする上で有益です。
* ヒューマンエラーから迅速かつ容易にリカバリできるようにして、障害が発生した場合のイ ンパクトを最小化できるようにしておきましょう。たとえば、設定の変更のロールバックを 即座にできるようにしておいたり、新しいコードのロールアウトは徐々に行っていったり(こうすることで、予想外のバグがあっても影響されるユーザーを一部にとどめることがで きます)、データを計算し直すツールを提供したり(それまでの計算が正しくないことが判 明した場合に備えて)しましょう。
* パフォーマンスメトリクスやエラーの発生率など、詳細で明確なモニタリングの仕組みを セットアップしましょう。他のエンジニアリング分野では、これはテレメトリと呼ばれます (いったん離陸してしまったロケットで起こっていることを追跡し、障害について理解する ためにはテレメトリが欠かせません [14])。モニタリングを行えば、警告シグナルを早期に 受けることができ、何らかの前提や制約に反していないかをチェックできます。問題が生じた場合、その診断にはメトリクスが欠かせません。
* 優れた管理方法とトレーニングを実践しましょう。これは複雑で重要なことであり、本書の範囲を超えています。

### 1.2.4 信頼性の重要度

## 1.3 スケーラビリティ

### 1.3.1 負荷の表現

```
最適なパラメータの選択がどのようなものになるかは、システムのアーキテクチャに依存します。
Webサーバーなら毎秒のリクエスト数、データベースなら読み書きの比率、チャットルームなら同時アクティブユーザー数、
キャッシュならヒット率などがそうです。おそらくは、平均的な状況が問題になる場合もあれば、
あるいは少数の極端なケースが支配的なボトルネックになっている場合もあるでしょう。
```

Twitterのタイムラインの実装例を出している。これは面白い。

### 1.3.2 パフォーマンスの表現

バッチ処理だとスループット、オンラインシステムだとレスポンスタイムが大事

レスポンスタイムとレイテンシの違いの話、よくわからん。説明下手。

典型的なレスポンスタイムを知るにはパーセンタイルを用いるべき


**HOLブロッキング**
少数の遅いリクエストがキュー詰まりをおこし、それ以外のリクエストにも影響を及ぼすこと。


### 1.3.3 負荷への対処のアプローチ

水平スケール、垂直スケール
手動拡張、自動拡張（エラスティック）
様々なアプローチがある。

```
本書ではこの後、多くの種類の分散データシステムを取り上げ、それらがスケーラビリティだけでなく、
使いやすさやメンテナンス性という面も考慮してやりくりしていることを論じていきます。
```

```
本書では、これらのビルディングブロックやパターンについて述べていきます。
```

## 1.4 メンテナンス性

メンテを容易にするために気をつけるべき設計原理

* 運用性
* 単純性
* 進化性

### 1.4.1 運用性：運用担当者への配慮

運用で負う仕事。運用作業とはよく聞くものの、あまり具体例を上げてみたことないからためになった。

* システムの健全性をモニタリングし、その状態が悪くなれば素早くサービスを回復させる。
* システムの障害やパフォーマンスの低下といった問題の原因を発見する。
* ソフトウェアやプラットフォームを最新の状態に保つ。これにはセキュリティパッチも含まれる。
* 様々なシステムの相互作用に注目し、問題がありそうな変更があれば、それがダメージを生じさせる前に回避する。
* 将来の問題を予想し、それらを発生前に解決する(たとえばキャパシティプランニング)。
* デプロイメント、設定管理などのための優れたプラクティスやツールを確立する。
* プラットフォーム間でのアプリケーションの移動など、複雑なメンテナンスタスクを実行する。
* 設定変更の際にシステムのセキュリティのメンテナンスを行う。
* 運用で予想外のことが起こらないようにプロセスを定義し、プロダクション環境の安定を保つ。
* 個人の出入りがあっても、システムに関する組織の知識が保たれるようにする。

### 1.4.2 単純さ：複雑さの管理

複雑さを取り除く優れた手段が抽象化

### 1.4.3 進化性：変更への配慮

変更のしやすさと単純さは密接に関わる。


# まとめ

# 2章 データモデルとクエリ言語

様々なデータモデルの比較

クエリ言語とそれらのユースケースを見ていく

## 2.1 リレーショナルモデルとドキュメントモデル

基本的にはリレーショナルモデルが圧勝

この辺の偉大さは達人に学ぶSQLの13章RDB近代史が詳しい。

### 2.1.1 NoSQLの誕生

### 2.1.2 オブジェクトとリレーショナルのミスマッチ

リレーショナルデータベースとオブジェクト指向言語間のやりとりでは変換レイヤーが必要。
このモデル間の断絶のことをインピーダンスミスマッチという。

LinkedInの履歴書の例を出している。

履歴書みたいな、それで完結しているような物に関してはJSONで表現する方が向いているかもしれない。

jsonでの表現にも問題はある。それは４章で見ていく。データエンコードの話っぽい。

### 2.1.3 多対一と多対多の関係

複製の排除がデータベースの正規化の鍵となる考え方。
正規化に関しては３部でちゃんと見る。

ドキュメントデータベースは結合が弱かったりする。
正規化の概念もないから、やたら複製が生まれたりもする。

### 2.1.4 ドキュメントデータベースは歴史を繰り返すのか？

ドキュメントデータベースが直面する問題は1970年代あたりにも、
ネットワークモデルとリレーショナルモデルの文脈で同様の議論がされていた。

#### 2.1.4.1 ネットワークモデル

あるレコードに行き着くまでの経路が入り組んでいるので、データモデルに変更を加えるのが困難だった。

#### 2.1.4.2 リレーショナルモデル

データのアクセス方法はクエリオプティマイザが決めてくれる。

```
クエリオプティマイザがなければ、汎用のオプティマイザを書くよりも、
特定のクエリのためにアクセスパスを手作業でコーディングするほうが楽でしょう。
しかし、長い目で見れば勝っているのは汎用的なソリューションなのです。
```

#### 2.1.4.3 ドキュメントデータベースとの比較

ドキュメントデータベースとネットワークデータベースの共通点は、
ネストされたレコードを、どちらも独立したテーブルではなく親のレコードに保存する点。

多対多、多対一の表現の面ではリレーショナルモデルとドキュメントデータベースで基本的な違いはない。

### 2.1.5 今日のリレーショナルデータベースとドキュメントデータベース

rdbとドキュメントのデータモデルに関する比較をしていく。

```
ドキュメントデータモデルを支持する議論には、主にスキーマの柔軟性、ローカリティから来る
優れたパフォーマンス、そしてアプリケーションによってはデータ構造がアプリケーションのもの
に近いことがあります。逆にリレーショナルデータベースは、結合や多対一及び多対多の関係のサ
ポートに優れています。
```

#### 2.1.5.1 アプリケーションのコードをシンプルにしてくれるデータモデルは?

- アプリを単純にしてくれるのはドキュメントデータモデルの方かも
  - 一発でツリー構造のデータを引っ張れる

ごちゃごちゃ言ってるが、結論としては下記。データ間の関係性による。

```
どのようなデータモデルを用いればアプリケーションのコードがシンプルなものになるのかを一般論として述べることはできません。
これは、データのアイテム間に存在する関係の種類に依存します。データ間の関係性が強い場合、ドキュメントモデルは扱いにくく、
リレーショナルモデルは許容範囲であり、グラフモデルが最も自然です(p.51「2.3 グラフ型のデータモデル」参照)。
```

#### 2.1.5.2 ドキュメントモデルにおけるスキーマの柔軟性

- スキーマオンリード、スキーマオンライト
  - 読み込むときにチェックするか、書き込むときにチェックするか

どちらを選択するかは重要だよ。


#### 2.1.5.3 クエリのためのデータローカリティ

ローカリティ＝データの局所性のこと

例えば一つのWebページを表示するときに、必要なデータがまとまっていると早く返せるよね、みたいな話。

#### 2.1.5.4 ドキュメント及びリレーショナルデータベースの融合

最近はリレーショナルデータベースの一カラムとしてJSONを持つことができるようになってきている。

### 2.2 データのためのクエリ言語

- SQLは宣言的、IMSやCODASYLは命令的

#### 2.2.1 Web 上での宣言的クエリ

命令的なクエリよりも宣言的なクエリの方が優れている。

#### 2.2.2 MapReduce でのクエリ

MapReduceの全体像は10章を参照。

reduceがむずい。

#### 2.3 グラフ型のデータモデル



----

