# はじめに

OAuthの歴史

この本の目標

* OAuth2.0 は何なのか
* なぜOAuthが機能するのか
* どのようにOAuth2.0を使って地震の問題を解決するのか

を理解する。

# 第1部 はじめの一歩

OAuth2.0の全体像をみていく

## 1. OAuth2.0とは何か？そして、なぜ気にかけるべきなのか？

### 1.1 OAuth2.0とは何か？

OAuthとはシステムを構成しているある要素から別の構成要素にアクセス権をわたすためのもの

OAuthを構成する要素

* リーソス所有者:通常は人
* 保護対象リソース:何らかのWebAPI
* クライアント:保護対象リソースに依って提供されるAPIを利用するソフトウェアすべて

これらの言葉を使って、OAuthの目的を再定義すると、  
**クライアントをリソース所有者の代わりとして保護対象リソースへアクセスさせる**


### 1.2 古き悪しき手法〜クレデンシャルの共有〜

ユーザのパスワードを再提示するような方法
* クライアントに渡したクレデンシャルがばれると。。
  * リソース所有者のあらゆる情報が引き出されうる。(パスワードの使いまわし)
  * ずっと保護対象リソースへのアクセスが許可されてしまう
* リソース所有者からのアクセスなのか、クライアントからなのかがわからない
  * 認可の制御ができない

クライアントに開発者キーみたいななんでもできるクレデンシャルを渡す方法
* クレデンシャルがばれると終わり

クライアントから保護対象リソースへアクセスするのを別パスワードにする
* ユーザビリティが悪い

----
クレデンシャルをクライアントとユーザーのそれぞれの組み合わせごとに別々に発行し、それを保護対象リソースで使えるようにしたい！

### 1.3 アクセス権の委譲

上記を実現するための仕組みがOAuth。
ここで新たに、認可サーバーという登場人物があらわれる

いわゆる認可コードフローだと、クライアントにクレデンシャル(id,passwordとか)が知られずに済む

#### 1.3.1 Basic認証にとって代わるものとパスワード共有に関するアンチパターン

もともと、HTTP経由のAPIがパスワードで保護されるようになったのはどんな経緯か？

#### 1.3.2 権限の委譲　～なぜ重要でどのように行われるのか？～

OAuthはユーザーの権限の一部をクライアントに委譲するよう、クライアントがユーザーにリクエストするための手段を提供している。

#### 1.3.3 ユーザー主導のセキュリティとユーザーの選択

TOFUの原則 ⇒ Trust On First Use
最初に権限に関する決定を下すと、システムはそのあともユーザーの決定を信頼して従うようになる。

3層のリスト
* ホワイトリスト
* グレーリスト
* ブラックリスト

### 1.4 OAuth2.0～良い点と悪い点、そして醜い点～

現時点ではこれ以上のものはない。

### 1.5 OAuth2.0でないものは何か？

**OAuthはHTTPプロトコルを使わずに定義されることはない**
機密情報となるシークレットと情報はネットワーク経由でやり取りされるため、ネットワーク上で機密に扱われるための仕組みの上で動かす必要がある。
 
**OAuthは認証のプロトコルではない** 
OAuthを使って認証を行う仕組みを構築することは可能。

**OAuthでは、あるユーザーから別のユーザーへの権限委譲の中身を定義していない**
OAuthではユーザーからユーザーへの権限委譲を定義していないが、UMAプロトコルではそういったことができるようになっている。

**OAuthは認可プロセスの仕組みを定義していない**
具体的な仕組みは定義していないようだ。

**OAuthはトークンのフォーマットを定義していない**
トークンがJWTであるべき、とかは言っていない。
ただ、トークンの中身がクライアントから見て不明瞭であるべきということを定義している。

**OAuth2.0は暗号に関する方法について定義していない**
どんな暗号化方法を使うかは定義されていない。OAuth1.0の時は決まっていたらしい

**OAuth2.0は単一のプロトコルではない**

### 1.6 まとめ

* OAuthとはトークンの取得方法とそのトークンの使用方法に関することである
* OAuthはシステムをまたいで認可を行えるようにする委譲プロトコルである
* OAuthはパスワード共有のようなアンチパターンを委譲プロトコルに置き換えており、より安全で、かつ、より使いやすいものになっている
* OAuthは自身が扱う問題の範囲を限定し、その問題を適切に解決することに専念しており、そのことが、OAuthをさらに大きなセキュリティの枠組みのなかで役割を果たすための一つの要素となっている

## 2. OAuthダンス~OAuthの構成要素間の相互作用

### 2.1 OAuth2.0プロトコルの概要～トークンの取得と使用～

* リソース所有者はクライアントにリソース所有者の代わりとしてふるまってほしいことを指示する
* クライアントは認可サーバーにリクエストし、そこで、リソース所有者にクライアントを認可するかどうかの判断を行わせる
* リソース所有者はクライアントを認可する
* クライアントは認可サーバーからトークンを受け取る
* クライアントは保護対象リソースにトークンを提示する

### 2.2 OAuth2.0における認可付与の詳細

リソース所有者の認可サーバに対するクライアント認可があまりピンとこないな。

最後のトークンリクエストではBasic認証をするのか。

### 2.3 クライアント、認可サーバー、リソース所有者、保護対象リソース

クライアントはトークンを意味不明な文字列として扱うべき

### 2.4 トークン、スコープ、認可付与

#### 2.4.1 アクセストークン

#### 2.4.2 スコープ

OAuthでは文字列で表現され、複数のスコープは空白で区切る

#### 2.4.3 リフレッシュトークン

リソース所有者を巻き込むことなく、新しいアクセストークンを取得できる仕組み

#### 2.4.4 認可付与

### 2.5 OAuthの構成要素間のやり取り

#### 2．5.1 バック・チャネル・コミュニケーション

ブラウザ等リソース所有者を介さない通信

#### 2.5.2 フロント・チャネル・コミュニケーション

ブラウザを仲介してやり取りする感じ

### 2.6 まとめ

* OAuthとはトークンの取得とトークンの使用に関することである
* OAuthの仕組みを構成する様々な要素がその認可プロセスにおいてそれぞれ異なる責任を持つようになっている
* OAuthの構成要素はHTTPの直接的な通信(バックチャネル)と間接的な通信(フロントチャネル)によってお互いにコミュニケーションを取っている

# 第2部 OAuth2.0環境の構築

## 3. シンプルなOAuthクライアントの構築

ここからは実装してくらしい

### 3.1 認可サーバへのOAuｔｈクライアントの登録

クライアントと認可サーバがお互いにやり取りを行うために、いくつかの情報をやり取りする必要がある。  
OAuthではどのようにやり取りをするのかの取り決めは定められていない。

クライアントは認可エンドポイントとトークンエンドポイントは最低限知っておく必要がある。

### 3.2 認可コード

#### 3.2.1 認可リクエストの送信

#### 3.2.2 認可サーバからのレスポンスの処理

#### 3.2.3 stateパラメータを使ったサイトをまたいだ攻撃に対する保護の追加

クライアントから認可エンドポイントにリダイレクトするときに、リクエストパラメータに付与し、認可サーバからクライアントにリダイレクトするときも同じ値をリクエストパラメータに付与する。

### 3.3 保護対象リソースへのトークンの使用

BearerトークンをAuthorizationヘッダーに入れる理由
* クエリパラメータに入れるとログにのこっちゃうかも
* formに入れる場合、保護対象リソース側で受け取れる種類に制限ができてしまう。formエンコードされたパラメータをうけとるPOST APIじゃないといけなくなる。
  * POSTに決まるのはなぜだ？？
  
### 3.4 アクセストークンのリフレッシュ

### 3.5 まとめ

* 認可コードによる付与方式を使ってトークンを取得するにはいくつかのわかりやすい手順を踏むことだけが要求される
* クライアントにとってリフレッシュ・トークンの機能が使えるようになっているのならばリフレッシュトークンを使うことで、エンドユーザーの手を煩わせることなく新しいアクセストークンを取得できるようになる。
* OAuth2.0のBearerトークンを使うことはトークンを取得することより、さらにシンプルになっている。HTTPコールにシンプルなHTTPヘッダーを追加することだけが要求される

## 4. シンプルなOAuthの保護対象リソースの構築

### 4.1 HTTPリクエストからのOAuthトークンの解析

Authorization、Bearerの文字はcase insensitive  
トークンはcase sensitive  

基本はAuthorizationヘッダにトークンを含める形式がいい。(3.3に理由あり)  

### 4.2 データストアにあるトークンとの比較

### 4.3 トークンの情報をもとにしたリソースの提供

#### 4.3.1 異なるスコープによる異なるアクション

トークンエンドポイントにアクセスしたときの戻りに、scopeがある。そこに何が許可されているのか書かれている  

#### 4.3.2 異なるスコープによる異なるデータの結果

scopeの値に応じて返す値を変えるような分岐を入れている  

#### 4.3.3 異なるユーザーによる異なるデータの取得

#### 4.3.4 さらなるアクセス制御

送られてくるリクエストの中身をどうするかの決定権はリソースサーバーが握る。  

### 4.4 まとめ

* トークンは受け取ったりリクエストから解析されて取り出される
* トークンは認可サーバーにて検証される
* レスポンスはトークンが何について有効なのかをもとに作成され、その結果となるレスポンスは決まった形式を一つしか取れないわけではない。

## 5. シンプルなOAuthの認可サーバーの構築

認可サーバがOAuthの仕組みのなかでもっとも複雑。  

### 5.1 OAuthクライアントの登録管理

クライアントID、クライアントシークレットは通常は認可サーバが生成する。

### 5.2 クライアントの認可

#### 5.2.1 認可エンドポイント

#### 5.2.2 クライアントの認可

### 5.3 トークンの発行


