# はじめに

OAuthの歴史

この本の目標

* OAuth2.0 は何なのか
* なぜOAuthが機能するのか
* どのようにOAuth2.0を使って自身の問題を解決するのか

を理解する。

# 第1部 はじめの一歩

OAuth2.0の全体像をみていく

## 1. OAuth2.0とは何か？そして、なぜ気にかけるべきなのか？

### 1.1 OAuth2.0とは何か？

OAuthとはシステムを構成しているある要素から別の構成要素にアクセス権をわたすためのもの

OAuthを構成する要素

* リーソス所有者:通常は人
* 保護対象リソース:何らかのWebAPI
* クライアント:保護対象リソースに依って提供されるAPIを利用するソフトウェアすべて

これらの言葉を使って、OAuthの目的を再定義すると、  
**クライアントをリソース所有者の代わりとして保護対象リソースへアクセスさせる**


### 1.2 古き悪しき手法〜クレデンシャルの共有〜

ユーザのパスワードを再提示するような方法
* クライアントに渡したクレデンシャルがばれると。。
  * リソース所有者のあらゆる情報が引き出されうる。(パスワードの使いまわし)
  * ずっと保護対象リソースへのアクセスが許可されてしまう
* リソース所有者からのアクセスなのか、クライアントからなのかがわからない
  * 認可の制御ができない

クライアントに開発者キーみたいななんでもできるクレデンシャルを渡す方法
* クレデンシャルがばれると終わり

クライアントから保護対象リソースへアクセスするのを別パスワードにする
* ユーザビリティが悪い

----
クレデンシャルをクライアントとユーザーのそれぞれの組み合わせごとに別々に発行し、それを保護対象リソースで使えるようにしたい！

### 1.3 アクセス権の委譲

上記を実現するための仕組みがOAuth。
ここで新たに、認可サーバーという登場人物があらわれる

いわゆる認可コードフローだと、クライアントにクレデンシャル(id,passwordとか)が知られずに済む

#### 1.3.1 Basic認証にとって代わるものとパスワード共有に関するアンチパターン

もともと、HTTP経由のAPIがパスワードで保護されるようになったのはどんな経緯か？

#### 1.3.2 権限の委譲　～なぜ重要でどのように行われるのか？～

OAuthはユーザーの権限の一部をクライアントに委譲するよう、クライアントがユーザーにリクエストするための手段を提供している。

#### 1.3.3 ユーザー主導のセキュリティとユーザーの選択

TOFUの原則 ⇒ Trust On First Use
最初に権限に関する決定を下すと、システムはそのあともユーザーの決定を信頼して従うようになる。

3層のリスト
* ホワイトリスト
* グレーリスト
* ブラックリスト

### 1.4 OAuth2.0～良い点と悪い点、そして醜い点～

現時点ではこれ以上のものはない。

### 1.5 OAuth2.0でないものは何か？

**OAuthはHTTPプロトコルを使わずに定義されることはない**
機密情報となるシークレットと情報はネットワーク経由でやり取りされるため、ネットワーク上で機密に扱われるための仕組みの上で動かす必要がある。(HTTPS)
 
**OAuthは認証のプロトコルではない** 
OAuthを使って認証を行う仕組みを構築することは可能。

**OAuthでは、あるユーザーから別のユーザーへの権限委譲の中身を定義していない**
OAuthではユーザーからユーザーへの権限委譲を定義していないが、UMAプロトコルではそういったことができるようになっている。

**OAuthは認可プロセスの仕組みを定義していない**
具体的な仕組みは定義していないようだ。

**OAuthはトークンのフォーマットを定義していない**
トークンがJWTであるべき、とかは言っていない。
ただ、トークンの中身がクライアントから見て不明瞭であるべきということを定義している。

**OAuth2.0は暗号に関する方法について定義していない**
どんな暗号化方法を使うかは定義されていない。OAuth1.0の時は決まっていたらしい

**OAuth2.0は単一のプロトコルではない**
ユースケースに合わせて、複数のフローがある。


### 1.6 まとめ

* OAuthとはトークンの取得方法とそのトークンの使用方法に関することである
* OAuthはシステムをまたいで認可を行えるようにする委譲プロトコルである
* OAuthはパスワード共有のようなアンチパターンを委譲プロトコルに置き換えており、より安全で、かつ、より使いやすいものになっている
* OAuthは自身が扱う問題の範囲を限定し、その問題を適切に解決することに専念しており、そのことが、OAuthをさらに大きなセキュリティの枠組みのなかで役割を果たすための一つの要素となっている

## 2. OAuthダンス~OAuthの構成要素間の相互作用

### 2.1 OAuth2.0プロトコルの概要～トークンの取得と使用～

OAuthのトランザクションは大きく2つに分けられる。
トークンの発行とトークンの使用に分割できる。

* リソース所有者はクライアントにリソース所有者の代わりとしてふるまってほしいことを指示する
* クライアントは認可サーバーにリクエストし、そこで、リソース所有者にクライアントを認可するかどうかの判断を行わせる
* リソース所有者はクライアントを認可する
* クライアントは認可サーバーからトークンを受け取る
* クライアントは保護対象リソースにトークンを提示する

### 2.2 OAuth2.0における認可付与の詳細

リソース所有者の認可サーバに対するクライアント認可があまりピンとこないな。

最後のトークンリクエストではBasic認証をするのか。

### 2.3 クライアント、認可サーバー、リソース所有者、保護対象リソース

クライアントはトークンを意味不明な文字列として扱うべき

ここでは主にアクターとなる構成要素の詳細説明をしている。

### 2.4 トークン、スコープ、認可付与

2.3で説明した以外の構成要素を述べている。

#### 2.4.1 アクセストークン

#### 2.4.2 スコープ

OAuthでは文字列で表現され、複数のスコープは空白で区切る

#### 2.4.3 リフレッシュトークン

リソース所有者を巻き込むことなく、新しいアクセストークンを取得できる仕組み

#### 2.4.4 認可付与

### 2.5 OAuthの構成要素間のやり取り

#### 2．5.1 バック・チャネル・コミュニケーション

ブラウザ等リソース所有者を介さない通信

#### 2.5.2 フロント・チャネル・コミュニケーション

ブラウザを仲介してやり取りする感じ

### 2.6 まとめ

* OAuthとはトークンの取得とトークンの使用に関することである
* OAuthの仕組みを構成する様々な要素がその認可プロセスにおいてそれぞれ異なる責任を持つようになっている
* OAuthの構成要素はHTTPの直接的な通信(バックチャネル)と間接的な通信(フロントチャネル)によってお互いにコミュニケーションを取っている

# 第2部 OAuth2.0環境の構築

## 3. シンプルなOAuthクライアントの構築

ここからは実装してくらしい

### 3.1 認可サーバへのOAuｔｈクライアントの登録

クライアントと認可サーバがお互いにやり取りを行うために、いくつかの情報をやり取りする必要がある。  
OAuthではどのようにやり取りをするのかの取り決めは定められていない。

クライアントは認可エンドポイントとトークンエンドポイントは最低限知っておく必要がある。

### 3.2 認可コード

#### 3.2.1 認可リクエストの送信

#### 3.2.2 認可サーバからのレスポンスの処理

#### 3.2.3 stateパラメータを使ったサイトをまたいだ攻撃に対する保護の追加

クライアントから認可エンドポイントにリダイレクトするときに、リクエストパラメータに付与し、認可サーバからクライアントにリダイレクトするときも同じ値をリクエストパラメータに付与する。

### 3.3 保護対象リソースへのトークンの使用

BearerトークンをAuthorizationヘッダーに入れる理由
* クエリパラメータに入れるとログにのこっちゃうかも
* formに入れる場合、保護対象リソース側で受け取れる種類に制限ができてしまう。formエンコードされたパラメータをうけとるPOST APIじゃないといけなくなる。
  * POSTに決まるのはなぜだ？？
  
### 3.4 アクセストークンのリフレッシュ

### 3.5 まとめ

* 認可コードによる付与方式を使ってトークンを取得するにはいくつかのわかりやすい手順を踏むことだけが要求される
* クライアントにとってリフレッシュ・トークンの機能が使えるようになっているのならばリフレッシュトークンを使うことで、エンドユーザーの手を煩わせることなく新しいアクセストークンを取得できるようになる。
* OAuth2.0のBearerトークンを使うことはトークンを取得することより、さらにシンプルになっている。HTTPコールにシンプルなHTTPヘッダーを追加することだけが要求される

## 4. シンプルなOAuthの保護対象リソースの構築

### 4.1 HTTPリクエストからのOAuthトークンの解析

Authorization、Bearerの文字はcase insensitive  
トークンはcase sensitive  

基本はAuthorizationヘッダにトークンを含める形式がいい。(3.3に理由あり)  

### 4.2 データストアにあるトークンとの比較

### 4.3 トークンの情報をもとにしたリソースの提供

#### 4.3.1 異なるスコープによる異なるアクション

トークンエンドポイントにアクセスしたときの戻りに、scopeがある。そこに何が許可されているのか書かれている  

#### 4.3.2 異なるスコープによる異なるデータの結果

scopeの値に応じて返す値を変えるような分岐を入れている  

#### 4.3.3 異なるユーザーによる異なるデータの取得

#### 4.3.4 さらなるアクセス制御

送られてくるリクエストの中身をどうするかの決定権はリソースサーバーが握る。  

### 4.4 まとめ

* トークンは受け取ったりリクエストから解析されて取り出される
* トークンは認可サーバーにて検証される
* レスポンスはトークンが何について有効なのかをもとに作成され、その結果となるレスポンスは決まった形式を一つしか取れないわけではない。

## 5. シンプルなOAuthの認可サーバーの構築

認可サーバがOAuthの仕組みのなかでもっとも複雑。  

### 5.1 OAuthクライアントの登録管理

クライアントID、クライアントシークレットは通常は認可サーバが生成する。

### 5.2 クライアントの認可

#### 5.2.1 認可エンドポイント

#### 5.2.2 クライアントの認可

### 5.3 トークンの発行

クライアントからトークンエンドポイントにPOSTリクエストが来るところ

#### 5.3.1 クライアントの認証

どのクライアントがリクエストを行っているのかを検証。  

Basic認証をするのが一般的。  
Authorizationヘッダに、ユーザー名、パスワードを転んでつないだものをbase64エンコーディングした値をぶち込む。

####  5.3.2 認可付与のリクエストに関する処理

まず、`grant_type` パラメータをチェックして付与方式をチェック。
ここでは `authorization_code`の場合を扱っている。
サポート対象の方式でなければエラーを返す。

そのあと、認可コードが有効なものであるかをチェックし、有効だったらすぐにその認可コードを無効にする。

そのあと、アクセストークンを生成し、格納する。

そして、アクセストークンと`token_type`をJsonボディ内に格納し、返却する。

### 5.4 リフレッシュトークンのサポートの追加

### 5.5 スコープのサポートの追加

スコープがなぜ空白区切りであらわされるのか？(なぜ配列にしないのか)
⇒
フロントチャネルにおいてはクエリパラメータを使わねばならないが、クエリパラメータでは配列を表せないから。  
formも同様にきつい。

### 5.6 まとめ

* フロント・チャネルとバック・チャネルのコミュニケーションを扱うには同じようなリクエストとレスポンスであっても異なるテクニックが要求される
* 認可コードによる付与（AuthorizationCodeGrant）のフローでは、データを複数の手順を通して受け渡していく必要があり、最後にアクセス・トークンを手に入れるようになっている
* 認可サーバーに対する攻撃を行える箇所は多数存在し、それらすべての箇所で適切な対応が行われるようにしなければならない
* リフレッシュ・トークンはアクセス・トークンとともに発行され、ユーザーを介入させずに新しいアクセス・トークンを生成するのに使われる
* スコープはアクセス・トークンにおける権限を制限する


## 6. 実際の環境におけるOAuth2.0

### 6.1 認可における付与方式

#### 6.1.1 インプリシット付与方式

ブラウザ内で動作するようなアプリがクライアントだと、認可コードをブラウザを通してクライアントに渡してもメリットがない。  
メリットがなくなる理由は、クライアントのみがシークレットを知っている、という状況を作れないから。ブラウザにあるアプリだと、だれでもシークレットみれちゃう。   

そんな場合に、認可コードとトークンを交換するのは無駄なので、省いた形式がインプリシット付与方式。

response_typeをtokenにする。

この方式ではリフレッシュトークンは生成しない。

#### 6.1.2 クライアントクレデンシャルによる付与方式

クライアントは自身のクレデンシャルをトークンと交換する。  
クライアントはユーザーの代わりとしてではなく自分自身のために処理を行うため、バックチャネルのみ。

#### 6.1.3 リソース所有者のクレデンシャルによる付与方式

クライアントはリソース所有者にパスワード入力を促し、受け取ったクライアントが認可サーバにリクエストして、トークンを受け取る。

リソース所有者はクライアントと直接やり取りをし、認可サーバとは直接やり取りしない。

このフローではリフレッシュトークンの利用があり得る。

#### 6.1.4 アサーションによる付与方式

#### 6.1.5 適切な付与方式の選択

### 6.2 クライアントの種類

クライアントの種類は大きく分けて3種類ある。Webアプリケーション、ブラウザ内アプリケーション、ネイティブアプリケーションだ。

#### 6.2.1 Webアプリケーション

#### 6.2.2 ブラウザ内アプリケーション

#### 6.2.3 ネイティブアプリケーション

ネイティブでは、フロントチャネルのリクエスト、レスポンスを行う仕組みが必要。それらの候補となるのが以下。

* ローカルホストで稼働する埋め込みのWebサーバーの使用
* アプリケーションに向けた何らか外部へのプッシュ通知機能を持つリモートのWebサーバの使用
* 自作のURIスキームの使用

モバイルアプリケーションだと3つ目が一番よくつかわれる。

#### 6.2.4 シークレットの扱い方

クライアントアプリが認可サーバに対して自身の認証を行うときにクライアントシークレットを用いる。

* 構成時シークレット： クライアントのすべてのコピーが保持するもの  
* 実行時シークレット： 各インスタンスが保持するもの

クライアントシークレットは構成時シークレット。  
アクセストークン、リフレッシュトークン、認可コードは実行時シークレット。

* 公開クライアント： 構成時シークレットを保持することができない。ブラウザで実行されるアプリ、ネイティブアプリなど  
  * クライアントの認可サーバに対する認証の対処法として、PKCEを使ったAuthorization Code Grantを行う
* 機密クライアント： 構成時シークレットを保持することができる。Webアプリ
  * 認可サーバはどうやってクライアントシークレットを知るの？Dynamic Client Registration
  
### 6.3 まとめ

* 標準的な認可コードによる付与方式(Authorization Code Grant Type)は異なる状況下においていくつかの方法で最適化できるようになっている
* インプリシット付与方式(Implicit Grant Type)は外部のクライアントを持たないブラウザ内アプリケーションで使われる
* クライアント・クレデンシャルによる付与方式(Client Credentials Grant Type)とアサーションによる付与方式(Assertion grant Type)は明示的なリソース所有者をもたないサーバーのアプリケーションで使われる
* リソース所有者のクレデンシャルによる付与方式(Resource Owner Credentials Grant Type)は基本的に使うべきではなく、それ以外の選択肢が本当にない場合に限り使うべきである
* OAuthの使用に関して、Webアプリケーション、ブラウザ内アプリケーション、ネイティブアプリケーションはそれぞれ独特の癖を持っているが、それらすべてに共通する核となる部分もある
* 機密クライアント(Confidential Client)はクライアント・シークレットを保持するが、公開クライアント(Public Client)は保持しない

# ブラウザで動作するアプリの20200723でのベストプラクティス

ブラウザ上で動作するJavaScriptアプリとか、SPAもそう。

[ベストプラクティス](https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps-06)

* ブラウザ内アプリのMUST要件
  * 認可コード付与方式とPKCEを使え
    * 認可コード横取り攻撃対策
  * CSRF対策にstateを使え
  * 認可リクエスト時に送ったURIと完全一致したリクエストのみさばく
* 認可サーバのMUST要件
  * 登録URIと送られてきたURIの完全一致をみろ
  * PKCEをサポートしろ
  * リフレッシュトークンをブラウザ内アプリに発行する際には、
    * リフレッシュトークン発行毎に変える
    * 有効期限を定める
    



# ネイティブアプリ

[仕様](https://tools.ietf.org/html/rfc8252)

[AppAuth](https://appauth.io/)

## ベストプラクティス

```
   For authorizing users in native apps, the best current practice is to
   perform the OAuth authorization request in an external user-agent
   (typically the browser) rather than an embedded user-agent (such as
   one implemented with web-views).
```

WebViewではなく、ブラウザで認可リクエストをしにこい。

WebView使用による欠点は以下にある
[欠点](https://tools.ietf.org/html/rfc8252#section-8.12)

パブリッククライアントなので、やっぱりPKCEに準拠しないといけないようだ。

```
パブリックネイティブアプリクライアントは、OAuthに対するコード交換のためのプルーフキー (Proof Key for Code Exchange)拡張(PKCE [RFC7636])
を実装しなければならず[MUST]、認可サーバーは、セクショ ン8.1で詳述されている理由から、そのようなクライアントのためにPKCEをサポートしな ければならない[MUST]。
```

クライアントがリダイレクトを受け取る方法が7章に書かれている。

* カスタムURIスキーム
  * FAPIという基準によると、クライアントが用いるリダイレクトURIスキームはhttps出なければならないので、これは使えない。
  * これだとアプリでURIが衝突する可能性があるらしい
* app-claimed https
  * AndroidだとAppLinks, iOSだとUniversal Linksと呼ばれる
  * これが最も悪意ある他のアプリに通信傍受される可能性が低い
  * なんにせよPKCEを使って正当なクライアントしか認可コードでトークン交換できないようにする
* ローカルループバックアドレスを使う
  * localhostは非推奨

8章でセキュリティに関すること述べている。

* インプリシット付与方式はPKCEで保護されないので非推奨
* ネイティブアプリはパブリッククライアントであることを強調
* 組み込みユーザーエージェントつまり、WebViewを使うべきでないことを強調
  * 組み込みユーザーエージェントは他のアプリ、ブラウザと情報共有しないため、認証要求回数が増える
  * アプリからWebView内のコンテンツを触ることはできるが、端末のブラウザは触れない。よって、悪意のあるアプリ対策になる？
    * アプリ実装者に向けてというより、OAuth全体の仕組みをみて、セキュリティの向上につながる
* CSRFを防ぐためにstateの付与推奨


# 第3部 OAuth2.0の実装と脆弱性

## 7. よく狙われるクライアントの脆弱性

### 7.1. 一般的なクライアントのセキュリティ

### 7.2. クライアントに対するCSRF攻撃

stateで回避。

### 7.3. クライアント・クレデンシャルの不当な取得

dynamic client registration をすることで、インスタンスごとにクレデンシャルを持つことができる。

### 7.4. リダイレクトURIの登録

#### 7.4.1. HTTPリファラーを利用した認可コードの不正な取得

リファラー？  
⇒ どのページからリクエストが来ているのか参照できるようにしたヘッダ。

前提として、
* 攻撃者は脆弱性のあるクライアントに悪意あるコンテンツを埋め込んでいる
  * <Img src="https://attackersite.com/"> みたいなのが含まれたページを用意する

攻撃者はredirect_uriを仕込んだページにしたURIを作って、フィッシングなどでユーザーに踏ませる。  
踏んで、ユーザーが認可を行ったら、仕込んだページに認可コード付きでリダイレクトする。  
仕込んであったImgタグによって、そのページから攻撃者のサーバにリクエストが送られる。  
そのリクエストのRefererヘッダに認可コードが含まれている。

#### 7.4.2. オープンリダイレクトによるトークンの不正な取得

### 7.5. 認可コードの不正な取得

### 7.6. トークンの取得

トークンのやり取りにクエリパラメータは利用してはいけない。  

* アクセスログに残る
* そのurlをそのまま掲示板にコピペするやつもいるかも
* Refererにトークンのっちゃう
とうとうの理由がある。
Authorizationヘッダを使うべき。

### 7.7. ネイティブアプリでのベストプラクティス

WebViewを使うな

* WebViewだと、入力した中身をクライアントアプリケーションに知られてしまう
* WebViewだとCookieとか使えないから、都度都度ログインが必要になってくる
* カスタムURIスキームを使う場合は世界で一意となるような命名をする。そうしないと認可コード横取りの危険がある

### 7.8. まとめ

* 仕様で提案されているようにstateパラメータを使うようにする
* 付与方式について理解し、対象のアプリケーションで使うべき正しい付与を選択するようにする
* ネイティブアプリではインプリシット付与方式を使うべきでない
* ネイティブアプリのクライアントでclient_secretを保護することは動的クライアント登録のように実行時に構成情報を設定できない限り不可能である
* 登録されたredirect_uriはできるだけ完全一致するようにすべきである
* access_tokenをURIパラメータに渡さなくて済むのであれば、決して渡してはいけない









#### 10.4.1. PKCE(Proof Key for Code Exchange)

認可コード横取り攻撃の対策として使うことが多い。  

認可コードと後続のトークンリクエストを安全に紐づけるための仕組み
