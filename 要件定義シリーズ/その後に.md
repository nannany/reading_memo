# 第1部 システム設計ってなんだろう？

## chapter 01 システムとは何か

## chapter 02 プロセスとは何か

仕事のここでの定義
何らかの成果と、その成果を出すために行う行動のまとまり

## chapter 03 システム設計とは何か

具体的に何をすればよいのか？
要件をアーキテクチャにマッピングする

本書で想定するアーキテクチャ
* フロント層・バック層・DB層の3層構造
* フロント層は、モバイルやIoTにおけるエッジ層/フィールド層も想定して、いわゆるリッチクライアント型とする
  * いわゆるネイティブアプリやSPAなど、GUIを自前で独立して制御するもの
* フロント側とバック層の間の通信はWebにより行い、電文の送受信で実現するものとする
  * バック側の言語がPHPやJSPなどであっても、UIとしてのHTMLを生成してフロント側に送出するのではなく、 データのみを送り、フロント側はそのデータを受信して自前でUIを構築する形になる
* DB層は単なるデータベースだけでなく、いわゆるDAOなどのデータアクセスの手段まで含めたものとする
  * 詳細はchapter15以降

# 第2部 システム設計のその前に

## chapter 04 要件定義とは何か

要件定義
作って欲しい人と作る人の間の合意事項

## chapter 05 要件定義のサンプルケース

# 第3部 システム設計の詳細

## chapter 06 改めてシステム設計とは何か

システム設計とは、  
要件をアーキテクチャにマッピングすること

バック層はフロント層に従属し、DB層はバック層に従属する
そのため、まずはフロント層から設計する

## chapter 07 フロント層 UI設計を行う

フロント層の役割は、ユーザーの期待に応えること

UIデザインの仕事は大きく2つ
* UIデザインの標準ガイドラインを定める
* 標準ガイドラインに沿いながら個別のUIデザインを決める

標準ガイドラインを決めるには3つ必要
* 要件（の全体感）
* プラットフォームのUIデザインガイドライン
* 昨今のデザイントレンドなどの知見

UIの要素は大きく2つ
* 情報構造
* ビジュアルデザイン

UI設計をする＝ある程度のレイアウトデザインをする

[ノンデザイナーズ・デザインブック](https://www.amazon.co.jp/dp/B01LW1BC2L)がいいらしい

* 近接
  * 関連項目を近くに集める
* 整列
  * 見えない直線等を想定し、各要素をその直線に沿わせる
* 反復
  * コンポーネントの反復的な話？
* コントラスト

## chapter 08 フロント層 UI設計の手順

IFDAM図をインプットにする

手順的には以下の感じ
1. 項目をUI上に配置する
  * 近接と整列を意識
  * 項目統制
2. UIの分割を検討する
  * レイアウトを描いて検討する
3. 分割に伴う画面遷移と画面間の機能について検討する
4. 画面遷移の変更に伴う操作手順の再確認と操作性の検討を行う

エラー画面は次の取るべき行動がわかるようにすべし
というか、そもそもエラー画面は出さないようできないか検討する

## chapter 09 フロント層 要件定義としてのUI設計

UI設計は実は要件定義という仕事の一部

**システムが提供する機能ではなく、システムを利用するユーザーの行動単位で考える**

UI設計の材料、成果物は
* 材料
  * 要件定義工程におけるIFDAM図
* 成果
  * UIレイアウト
  * 今回の修正が反映されたIFDAM図
  * (できれば)操作手順書

## chapter 10 フロント層 機能を設計する

モジュール化を行う
* インターフェースを定義
* 実装部を定義

## chapter 11 フロント層 モジュールのインターフェースを定義する

順接、分岐、反復の制御の組み合わせでモジュールを分割していく

IFDAM図をインプットとして、設計したい機能を1つ選択する。その機能について、インターフェースをまず決める。
インターフェースとは、
* 機能名
* 入力
* 出力
をさす。

### 機能名
機能名はVOを意識して書く。
また、
* きちんと語尾まで書く
* 受動態ではなく能動態で書く
* 否定表現を能動表現にする
に気を付ける。

### 入出力定義

## chapter 12 フロント層 モジュールの実装を定義する

末端の機能であるかどうかを判断する。末端の機能とは何かというと、
* リクエスト/レスポンス（別のサービスに依頼して結果を受け取る）
* デリベーション（導出・加工・変換・計算）
* 判定（Boolean）
* バリデーション（エラーメッセージつき）
* DBからのデータ取得（SELECT）
* DBへのデータ保存（INSERT,UPDATE,DELETE）
* その他（メール送信や他サーバ連携、通知処理など）

## chapter 13 フロント層 実装定義をやってみよう

順接、分岐、反復に縛りをもうける。

* 順接
  * できることは「他のモジュールを呼び出す」だけ
  * 呼び出すことができるモジュールの数は基本３つ
  * 最大５つまではおけ
* 分岐
  * 条件は別モジュールの呼び出しのみ
  * 条件による分岐はTHENのみ、つまりELSEは使わない
* 反復
  * ループ内で実行するのは別モジュールの呼び出しのみとする
  
## chapter 14 バック層 バック層を設計する

バック層の存在意義

バック層についての歴史が語られているが、主張としてはなんなんだ？

## chapter 15 DB層 モジュールのインターフェースを定義する

## chapter 16 DB層 テーブル設計を行う

## chapter 17 DB層 実装を定義する

ビジネスの写像を行うのはDBではなく、バック層にシフトしてきている。
昔は伝票をDBに登録するようなシステムが多くあった。

テーブル設計における状態の表現は難しい。状態をデータ構造として表現する方法はいくつかある。
* フラグ型
* 状態マスター
* 複数フラグ型
* 複数項目の外部テーブル
* 状態テーブル型
* サブセット型

状態テーブル方が無難。

DB層のサービス化を徹底するなら、いっそテーブルごとにモジュール化してしまって、JOINとかの操作が一切怒らないようにするのもありかも。
作者的にはおすすめではないらしいが。
いまだに、マイクロサービスにおけるマスタデータのあり方として議論が続けられている。


## chapter 18 システム設計の成果

# 第4部 実務とシステム設計

## chapter 19 マルチサイクルによるスコープ管理

1つのIFDAM図単位でUI〜バック〜DBまで作ってしまう感じ。

テストの考え方のところのインタラクションのレベルで確認ってつまりどういうこと？

## chapter 20 正しい「率」による進捗管理

本当に重要なのは残管理

## chapter 21 共通化の罠

共通化チームを最初から作ってしまうと、共通化チームは仕事をすすめるために、各チームに仕様の提出を求める一方、各チームは共通化チームにどこが共通化できるのかを求める。
このようなデッドロックが発生してしまう。

そのため、共通化を最初から望むことはやめるべき。

# まとめ システム設計のその先に

